{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Git Refresher Whether you're a seasoned developer or a code maintainer, this repository is designed to help you enhance your Git skills and streamline your version control workflows. Basic Topics Advanced Topics Other Topics Configuration Aliases SSH Keys Starting a Project Tagging Signing Commits Staging Changes Branches Plumbing Tools Undoing Changes Advanced Merge Search Tools Remotes Patching Rerere Inspect & Compare Ignoring Files Debugging Temporary Commits Bundling Interactive Staging Replace CherryPicking Attrributes Checkout Notes Submodules Worktree This material is a work in progress, so your feedback is welcome. The best way to provide that feedback is to click here and create an issue in this GitHub repository . External Links This site is heavily inspired by Pro Git . Videos Lecture","title":"Home"},{"location":"#welcome-to-git-refresher","text":"Whether you're a seasoned developer or a code maintainer, this repository is designed to help you enhance your Git skills and streamline your version control workflows. Basic Topics Advanced Topics Other Topics Configuration Aliases SSH Keys Starting a Project Tagging Signing Commits Staging Changes Branches Plumbing Tools Undoing Changes Advanced Merge Search Tools Remotes Patching Rerere Inspect & Compare Ignoring Files Debugging Temporary Commits Bundling Interactive Staging Replace CherryPicking Attrributes Checkout Notes Submodules Worktree This material is a work in progress, so your feedback is welcome. The best way to provide that feedback is to click here and create an issue in this GitHub repository .","title":"Welcome to Git Refresher"},{"location":"#external-links","text":"This site is heavily inspired by Pro Git .","title":"External Links"},{"location":"#videos","text":"Lecture","title":"Videos"},{"location":"git_refresh/","text":"Git is a distributed version control system (VCS) designed to track changes in source code during software development. It was created by Linus Torvalds in 2005 and has become the de facto standard for version control in the software development industry. Key Concepts Version Control: Git allows developers to track changes made to their codebase over time. This includes recording who made the changes, what changes were made, and when the changes occurred. Distributed System: Git is decentralized, meaning that each developer has a complete copy of the entire project history on their local machine. This allows for flexibility in development and collaboration. Branching: Git excels at branching, enabling developers to work on multiple independent features or bug fixes simultaneously. Branches can be created, merged, and deleted without affecting the main codebase until changes are ready to be integrated. Collaboration: Git facilitates collaboration among developers. Multiple contributors can work on the same project simultaneously without interfering with each other's work. Changes are merged together seamlessly. History and Accountability Git maintains a detailed history of all changes made to a project. This history provides accountability by attributing each change to a specific user, making it easy to trace the evolution of the codebase. Importance of Git Collaboration: Git enables efficient collaboration among developers working on the same project. It allows multiple team members to contribute simultaneously, track changes, and merge their work seamlessly. Versioning: Git provides a reliable versioning system, allowing developers to track changes over time. This is crucial for understanding the evolution of a project, reverting to previous states, and identifying when and by whom specific changes were made. Branching and Experimentation Git's branching model allows developers to experiment with new features or bug fixes in isolation. This promotes a more organized and controlled development process, with the ability to merge changes into the main codebase when they are ready. Fault Tolerance: The distributed nature of Git ensures that each developer has a complete copy of the repository. This redundancy minimizes the risk of data loss and provides a safety net in case of system failures. Open Source Ecosystem: Git is the foundation for many open-source projects and contributes to the collaborative nature of the software development community. Platforms like GitHub, GitLab, and Bitbucket leverage Git to host and manage repositories, fostering a rich ecosystem of shared code. In summary, Git is important because it enhances collaboration, provides effective version control, and empowers developers to work efficiently and reliably on software projects of any scale.","title":"Git"},{"location":"git_refresh/#key-concepts","text":"Version Control: Git allows developers to track changes made to their codebase over time. This includes recording who made the changes, what changes were made, and when the changes occurred. Distributed System: Git is decentralized, meaning that each developer has a complete copy of the entire project history on their local machine. This allows for flexibility in development and collaboration. Branching: Git excels at branching, enabling developers to work on multiple independent features or bug fixes simultaneously. Branches can be created, merged, and deleted without affecting the main codebase until changes are ready to be integrated. Collaboration: Git facilitates collaboration among developers. Multiple contributors can work on the same project simultaneously without interfering with each other's work. Changes are merged together seamlessly. History and Accountability Git maintains a detailed history of all changes made to a project. This history provides accountability by attributing each change to a specific user, making it easy to trace the evolution of the codebase.","title":"Key Concepts"},{"location":"git_refresh/#importance-of-git","text":"Collaboration: Git enables efficient collaboration among developers working on the same project. It allows multiple team members to contribute simultaneously, track changes, and merge their work seamlessly. Versioning: Git provides a reliable versioning system, allowing developers to track changes over time. This is crucial for understanding the evolution of a project, reverting to previous states, and identifying when and by whom specific changes were made. Branching and Experimentation Git's branching model allows developers to experiment with new features or bug fixes in isolation. This promotes a more organized and controlled development process, with the ability to merge changes into the main codebase when they are ready. Fault Tolerance: The distributed nature of Git ensures that each developer has a complete copy of the repository. This redundancy minimizes the risk of data loss and provides a safety net in case of system failures. Open Source Ecosystem: Git is the foundation for many open-source projects and contributes to the collaborative nature of the software development community. Platforms like GitHub, GitLab, and Bitbucket leverage Git to host and manage repositories, fostering a rich ecosystem of shared code. In summary, Git is important because it enhances collaboration, provides effective version control, and empowers developers to work efficiently and reliably on software projects of any scale.","title":"Importance of Git"},{"location":"Advanced/git_advmerge/","text":"Merge Conflicts Merge conflicts occur when Git is unable to automatically resolve differences between branches. You can resolve conflicts manually by editing the conflicting files and then committing the changes. Git\u2019s philosophy is to be smart about determining when a merge resolution is unambiguous, but if there is a conflict, it does not try to be clever about automatically resolving it. Therefore, if you wait too long to merge two branches that diverge quickly, you can run into some issues. git merge feature-branch # Resolve conflicts in conflicted files git add <resolved-file> git commit First of all, if at all possible, try to make sure your working directory is clean before doing a merge that may have conflicts. If you have work in progress, either commit it to a temporary branch or stash it. This makes it so that you can undo anything you try here. If you have unsaved changes in your working directory when you try a merge, some of these tips may help you preserve that work. Aborting a Merge If you encounter issues during a merge and want to abort the process, you can use: git merge --abort The --abort option tries to revert back to your state before you ran the merge. The only cases where it may not be able to do this perfectly would be if you had unstashed, uncommitted changes in your working directory when you ran it, otherwise it should work fine. If for some reason you just want to start over, you can also run git reset --hard HEAD , and your repository will be back to the last committed state. Remember that any uncommitted work will be lost, so make sure you don\u2019t want any of your changes. Ignoring Whitespace To ignore whitespace changes during a merge, you can use the -Xignore-space-change or -Xignore-all-space option. If you see that you have a lot of whitespace issues in a merge, you can simply abort it and do it again, this time with -Xignore-all-space or -Xignore-space-change. The first option ignores whitespace completely when comparing lines, the second treats sequences of one or more whitespace characters as equivalent. git merge -Xignore-space-change feature-branch This can be identified when looking at the conflict because every line is removed on one side and added again on the other. By default, Git sees all of these lines as being changed, so it can\u2019t merge the files. This is a lifesaver if you have someone on your team who likes to occasionally reformat everything from spaces to tabs or vice-versa. Manual File Re-merging Accessing the three versions of a file in a conflict can be useful for debugging or troubleshooting. Suppose we have three versions of the hello.rb file: hello.common.rb (common ancestor), hello.ours.rb (current version), and hello.theirs.rb (version to be merged). git show :1:hello.rb > hello.common.rb git show :2:hello.rb > hello.ours.rb git show :3:hello.rb > hello.theirs.rb Note: The :1:hello.rb is just a shorthand for looking up that blob SHA-1. The git merge-file command is used to merge changes from three different versions of a file: a common ancestor, the current version, and the version to be merged. This command is particularly useful when resolving merge conflicts manually or when automating the merge process in scripts. git merge-file [ -p | --stdout ] <current-file> <base-file> <other-file> -p or --stdout : Optional flag to output the merged content to standard output instead of modifying files directly. <current-file> : The file as it exists in the current branch. <base-file> : The common ancestor file before any changes were made. <other-file> : The file to be merged into the current branch. Merging Changes from Three Versions git merge-file -p hello.ours.rb hello.common.rb hello.theirs.rb > hello.rb This command merges the changes from hello.common.rb (common ancestor), hello.ours.rb (current version), and hello.theirs.rb (version to be merged) and outputs the merged content to hello.rb . Manual Conflict Resolution : Use git merge-file to resolve merge conflicts manually by inspecting and editing the merged content before committing. Automated Merge Process : Integrate git merge-file into scripts or automated processes to perform merges without manual intervention, such as during continuous integration workflows. To compare your result to what you had in your branch before the merge, in other words, to see what the merge introduced, you can run git diff --ours . If we want to see how the result of the merge differed from what was on their side, you can run git diff --theirs . Finally, you can see how the file has changed from both sides with git diff --base . Checking Out Conflicts Perhaps we\u2019re not happy with the resolution at this point for some reason, or maybe manually editing one or both sides still didn\u2019t work well and we need more context. For example, imagine we have two longer lived branches that each have a few commits in them but create a legitimate content conflict when merged. $ git log --graph --oneline --decorate --all * f1270f7 ( HEAD, master ) Update README * 9af9d3b Create README * 694971d Update phrase to 'hola world' | * e3eb223 ( mundo ) Add more tests | * 7cff591 Create initial testing script | * c3ffff1 Change text to 'hello mundo' | / * b7dcc89 Initial hello world code We now have three unique commits that live only on the master branch and three others that live on the mundo branch. If we try to merge the mundo branch in, we get a conflict. $ git merge mundo Auto-merging hello.rb CONFLICT ( content ) : Merge conflict in hello.rb Automatic merge failed ; fix conflicts and then commit the result. We would like to see what the merge conflict is. If we open up the file, we\u2019ll see something like this: #! /usr/bin/env ruby def hello <<<<<< < HEAD puts 'hola world' ======= puts 'hello mundo' >>>>>>> mundo end hello () Both sides of the merge added content to this file, but some of the commits modified the file in the same place that caused this conflict. One helpful tool is git checkout with the --conflict option. This will re-checkout the file again and replace the merge conflict markers. This can be useful if you want to reset the markers and try to resolve them again. git checkout --conflict <file> You can pass --conflict either diff3 or merge (which is the default). If you pass it diff3, Git will use a slightly different version of conflict markers, not only giving you the \u201cours\u201d and \u201ctheirs\u201d versions, but also the \u201cbase\u201d version inline to give you more context. git checkout --conflict = diff3 hello.rb Once we run that, the file will look like this instead: #! /usr/bin/env ruby def hello <<<<<< < ours puts 'hola world' |||||| | base puts 'hello world' ======= puts 'hello mundo' >>>>>>> theirs end hello () If you like this format, you can set it as the default for future merge conflicts by setting the merge.conflictstyle setting to diff3. git config --global merge.conflictstyle diff3 The git checkout command can also take --ours and --theirs options, which can be a really fast way of just choosing either one side or the other without merging things at all. This can be particularly useful for conflicts of binary files where you can simply choose one side, or where you only want to merge certain files in from another branch\u2009\u2014\u2009you can do the merge and then checkout certain files from one side or the other before committing. Merge Log AQnother useful tool when resolving merge conflicts is git log. This can help you get context on what may have contributed to the conflicts. Reviewing a little bit of history to remember why two lines of development were touching the same area of code can be really helpful sometimes. To get a full list of all of the unique commits that were included in either branch involved in this merge, we can use the \u201ctriple dot\u201d. git log --oneline --left-right HEAD...MERGE_HEAD We can further simplify this though to give us much more specific context. If we add the --merge option to git log, it will only show the commits in either side of the merge that touch a file that\u2019s currently conflicted. git log --oneline --left-right --merge If you run that with the -p option instead, you get just the diffs to the file that ended up in conflict. This can be really helpful in quickly giving you the context you need to help understand why something conflicts and how to more intelligently resolve it. Combined Diff Format Since Git stages any merge results that are successful, when you run git diff while in a conflicted merge state, you only get what is currently still in conflict. This can be helpful to see what you still have to resolve. When you run git diff directly after a merge conflict, it will give you information in a rather unique diff output format. git diff diff --cc hello.rb index 0399cd5,59727f0..0000000 --- a/hello.rb +++ b/hello.rb @@@ -1,7 -1,7 +1,11 @@@ #! /usr/bin/env ruby def hello ++<<<<<<< HEAD + puts 'hola world' ++======= + puts 'hello mundo' ++>>>>>>> mundo end hello() The format is called \u201cCombined Diff\u201d and gives you two columns of data next to each line. The first column shows you if that line is different (added or removed) between the \u201cours\u201d branch and the file in your working directory and the second column does the same between the \u201ctheirs\u201d branch and your working directory copy. So in that example you can see that the <<<<<<< and >>>>>>> lines are in the working copy but were not in either side of the merge. This makes sense because the merge tool stuck them in there for our context, but we\u2019re expected to remove them. If we resolve the conflict and run git diff again, we\u2019ll see the same thing, but it\u2019s a little more useful. vim hello.rb git diff diff --cc hello.rb index 0399cd5,59727f0..0000000 --- a/hello.rb +++ b/hello.rb @@@ -1,7 -1,7 +1,7 @@@ #! /usr/bin/env ruby def hello - puts 'hola world' - puts 'hello mundo' ++ puts 'hola mundo' end hello() This shows us that \u201chola world\u201d was in our side but not in the working copy, that \u201chello mundo\u201d was in their side but not in the working copy and finally that \u201chola mundo\u201d was not in either side but is now in the working copy. This can be useful to review before committing the resolution. You can also get this from the git log for any merge to see how something was resolved after the fact. Git will output this format if you run git show on a merge commit, or if you add a --cc option to a git log -p (which by default only shows patches for non-merge commits). git log --cc -p -1 Undoing Merges Now that you know how to create a merge commit, you\u2019ll probably make some by mistake. One of the great things about working with Git is that it\u2019s okay to make mistakes, because it\u2019s possible (and in many cases easy) to fix them. There are two ways to approach this problem, depending on what your desired outcome is. Fix the References If the unwanted merge commit only exists on your local repository, the easiest and best solution is to move the branches so that they point where you want them to. In most cases, if you follow the errant git merge with git reset --hard HEAD~, this will reset the branch pointers to what they were before the merge. To undo a merge commit and reset the branch to its state before the merge, you can use git reset --hard . git reset --hard HEAD^ reset --hard usually goes through three steps: Move the branch HEAD points to. In this case, we want to move master to where it was before the merge commit (C6). Make the index look like HEAD. Make the working directory look like the index. The downside of this approach is that it\u2019s rewriting history, which can be problematic with a shared repository. This approach also won\u2019t work if any other commits have been created since the merge; moving the refs would effectively lose those changes. Reverse the Commit If moving the branch pointers around isn\u2019t going to work for you, Git gives you the option of making a new commit which undoes all the changes from an existing one. Git calls this operation a \u201crevert\u201d. To reverse a merge commit, you can use git revert . git revert -m 1 <merge-commit> git revert -m 1 HEAD Other types of Merges So far we\u2019ve covered the normal merge of two branches, normally handled with what is called the \u201crecursive\u201d strategy of merging. There are other ways to merge branches together however. Our or Theirs Preference During a merge, you can specify whether to prefer changes from the current branch ( --ours ) or the merged branch ( --theirs ). By default, when Git sees a conflict between two branches being merged, it will add merge conflict markers into your code and mark the file as conflicted and let you resolve it. If you would prefer for Git to simply choose a specific side and ignore the other side instead of letting you manually resolve the conflict, you can pass the merge command either a -Xours or -Xtheirs. If Git sees this, it will not add conflict markers. Any differences that are mergeable, it will merge. Any differences that conflict, it will simply choose the side you specify in whole, including binary files. git merge -Xours feature-branch git merge -Xtheirs feature-branch This option can also be passed to the git merge-file command we saw earlier by running something like git merge-file --ours for individual file merges. If you want to do something like this but not have Git even try to merge changes from the other side in, there is a more draconian option, which is the \u201cours\u201d merge strategy. This is different from the \u201cours\u201d recursive merge option. This will basically do a fake merge. It will record a new merge commit with both branches as parents, but it will not even look at the branch you\u2019re merging in. It will simply record as the result of the merge the exact code in your current branch. git merge -s ours mundo Merge made by the 'ours' strategy. git diff HEAD HEAD~ You can see that there is no difference between the branch we were on and the result of the merge. This can often be useful to basically trick Git into thinking that a branch is already merged when doing a merge later on. For example, say you branched off a release branch and have done some work on it that you will want to merge back into your master branch at some point. In the meantime some bugfix on master needs to be backported into your release branch. You can merge the bugfix branch into the release branch and also merge -s ours the same branch into your master branch (even though the fix is already there) so when you later merge the release branch again, there are no conflicts from the bugfix. Subtree Merging The idea of the subtree merge is that you have two projects, and one of the projects maps to a subdirectory of the other one. When you specify a subtree merge, Git is often smart enough to figure out that one is a subtree of the other and merge appropriately. An example of this will be adding a separate project into an existing project and then merging the code of the second into a subdirectory of the first. So, we\u2019ll add the Rack application to our project. We\u2019ll add the Rack project as a remote reference in our own project and then check it out into its own branch: git remote add rack_remote https://github.com/rack/rack git fetch rack_remote --no-tags git checkout -b rack_branch rack_remote/master Now we have the root of the Rack project in our rack_branch branch and our own project in the master branch. If you check out one and then the other, you can see that they have different project roots. In this case, we want to pull the Rack project into our master project as a subdirectory. We can do that in Git with git read-tree. read-tree reads the root tree of one branch into your current staging area and working directory. We just switched back to your master branch, and we pull the rack_branch branch into the rack subdirectory of our master branch of our main project. git read-tree --prefix = rack/ -u rack_branch When we commit, it looks like we have all the Rack files under that subdirectory\u2009\u2014\u2009as though we copied them in from a tarball. What gets interesting is that we can fairly easily merge changes from one of the branches to the other. So, if the Rack project updates, we can pull in upstream changes by switching to that branch and pulling it in. git checkout rack_branch git pull Then, we can merge those changes back into our master branch. To pull in the changes and prepopulate the commit message, use the --squash option, as well as the recursive merge strategy\u2019s -Xsubtree option. The recursive strategy is the default here, but we include it for clarity. git checkout master git merge --squash -s recursive -Xsubtree = rack rack_branch All the changes from the Rack project are merged in and ready to be committed locally. You can also do the opposite\u2009\u2014\u2009make changes in the rack subdirectory of your master branch and then merge them into your rack_branch branch later to submit them to the maintainers or push them upstream. This gives us a way to have a workflow somewhat similar to the submodule workflow without using submodules. We can keep branches with other related projects in our repository and subtree merge them into our project occasionally. It is nice in some ways, for example all the code is committed to a single place. However, it has other drawbacks in that it\u2019s a bit more complex and easier to make mistakes in reintegrating changes or accidentally pushing a branch into an unrelated repository. Another slightly weird thing is that to get a diff between what you have in your rack subdirectory and the code in your rack_branch branch\u2009\u2014\u2009to see if you need to merge them\u2009\u2014\u2009you can\u2019t use the normal diff command. Instead, you must run git diff-tree with the branch you want to compare to. git diff-tree -p rack_branch Or, to compare what is in your rack subdirectory with what the master branch on the server was the last time you fetched, you can run: git diff-tree -p rack_remote/master","title":"Advanced Merge"},{"location":"Advanced/git_advmerge/#merge-conflicts","text":"Merge conflicts occur when Git is unable to automatically resolve differences between branches. You can resolve conflicts manually by editing the conflicting files and then committing the changes. Git\u2019s philosophy is to be smart about determining when a merge resolution is unambiguous, but if there is a conflict, it does not try to be clever about automatically resolving it. Therefore, if you wait too long to merge two branches that diverge quickly, you can run into some issues. git merge feature-branch # Resolve conflicts in conflicted files git add <resolved-file> git commit First of all, if at all possible, try to make sure your working directory is clean before doing a merge that may have conflicts. If you have work in progress, either commit it to a temporary branch or stash it. This makes it so that you can undo anything you try here. If you have unsaved changes in your working directory when you try a merge, some of these tips may help you preserve that work.","title":"Merge Conflicts"},{"location":"Advanced/git_advmerge/#aborting-a-merge","text":"If you encounter issues during a merge and want to abort the process, you can use: git merge --abort The --abort option tries to revert back to your state before you ran the merge. The only cases where it may not be able to do this perfectly would be if you had unstashed, uncommitted changes in your working directory when you ran it, otherwise it should work fine. If for some reason you just want to start over, you can also run git reset --hard HEAD , and your repository will be back to the last committed state. Remember that any uncommitted work will be lost, so make sure you don\u2019t want any of your changes.","title":"Aborting a Merge"},{"location":"Advanced/git_advmerge/#ignoring-whitespace","text":"To ignore whitespace changes during a merge, you can use the -Xignore-space-change or -Xignore-all-space option. If you see that you have a lot of whitespace issues in a merge, you can simply abort it and do it again, this time with -Xignore-all-space or -Xignore-space-change. The first option ignores whitespace completely when comparing lines, the second treats sequences of one or more whitespace characters as equivalent. git merge -Xignore-space-change feature-branch This can be identified when looking at the conflict because every line is removed on one side and added again on the other. By default, Git sees all of these lines as being changed, so it can\u2019t merge the files. This is a lifesaver if you have someone on your team who likes to occasionally reformat everything from spaces to tabs or vice-versa.","title":"Ignoring Whitespace"},{"location":"Advanced/git_advmerge/#manual-file-re-merging","text":"Accessing the three versions of a file in a conflict can be useful for debugging or troubleshooting. Suppose we have three versions of the hello.rb file: hello.common.rb (common ancestor), hello.ours.rb (current version), and hello.theirs.rb (version to be merged). git show :1:hello.rb > hello.common.rb git show :2:hello.rb > hello.ours.rb git show :3:hello.rb > hello.theirs.rb Note: The :1:hello.rb is just a shorthand for looking up that blob SHA-1. The git merge-file command is used to merge changes from three different versions of a file: a common ancestor, the current version, and the version to be merged. This command is particularly useful when resolving merge conflicts manually or when automating the merge process in scripts. git merge-file [ -p | --stdout ] <current-file> <base-file> <other-file> -p or --stdout : Optional flag to output the merged content to standard output instead of modifying files directly. <current-file> : The file as it exists in the current branch. <base-file> : The common ancestor file before any changes were made. <other-file> : The file to be merged into the current branch. Merging Changes from Three Versions git merge-file -p hello.ours.rb hello.common.rb hello.theirs.rb > hello.rb This command merges the changes from hello.common.rb (common ancestor), hello.ours.rb (current version), and hello.theirs.rb (version to be merged) and outputs the merged content to hello.rb . Manual Conflict Resolution : Use git merge-file to resolve merge conflicts manually by inspecting and editing the merged content before committing. Automated Merge Process : Integrate git merge-file into scripts or automated processes to perform merges without manual intervention, such as during continuous integration workflows. To compare your result to what you had in your branch before the merge, in other words, to see what the merge introduced, you can run git diff --ours . If we want to see how the result of the merge differed from what was on their side, you can run git diff --theirs . Finally, you can see how the file has changed from both sides with git diff --base .","title":"Manual File Re-merging"},{"location":"Advanced/git_advmerge/#checking-out-conflicts","text":"Perhaps we\u2019re not happy with the resolution at this point for some reason, or maybe manually editing one or both sides still didn\u2019t work well and we need more context. For example, imagine we have two longer lived branches that each have a few commits in them but create a legitimate content conflict when merged. $ git log --graph --oneline --decorate --all * f1270f7 ( HEAD, master ) Update README * 9af9d3b Create README * 694971d Update phrase to 'hola world' | * e3eb223 ( mundo ) Add more tests | * 7cff591 Create initial testing script | * c3ffff1 Change text to 'hello mundo' | / * b7dcc89 Initial hello world code We now have three unique commits that live only on the master branch and three others that live on the mundo branch. If we try to merge the mundo branch in, we get a conflict. $ git merge mundo Auto-merging hello.rb CONFLICT ( content ) : Merge conflict in hello.rb Automatic merge failed ; fix conflicts and then commit the result. We would like to see what the merge conflict is. If we open up the file, we\u2019ll see something like this: #! /usr/bin/env ruby def hello <<<<<< < HEAD puts 'hola world' ======= puts 'hello mundo' >>>>>>> mundo end hello () Both sides of the merge added content to this file, but some of the commits modified the file in the same place that caused this conflict. One helpful tool is git checkout with the --conflict option. This will re-checkout the file again and replace the merge conflict markers. This can be useful if you want to reset the markers and try to resolve them again. git checkout --conflict <file> You can pass --conflict either diff3 or merge (which is the default). If you pass it diff3, Git will use a slightly different version of conflict markers, not only giving you the \u201cours\u201d and \u201ctheirs\u201d versions, but also the \u201cbase\u201d version inline to give you more context. git checkout --conflict = diff3 hello.rb Once we run that, the file will look like this instead: #! /usr/bin/env ruby def hello <<<<<< < ours puts 'hola world' |||||| | base puts 'hello world' ======= puts 'hello mundo' >>>>>>> theirs end hello () If you like this format, you can set it as the default for future merge conflicts by setting the merge.conflictstyle setting to diff3. git config --global merge.conflictstyle diff3 The git checkout command can also take --ours and --theirs options, which can be a really fast way of just choosing either one side or the other without merging things at all. This can be particularly useful for conflicts of binary files where you can simply choose one side, or where you only want to merge certain files in from another branch\u2009\u2014\u2009you can do the merge and then checkout certain files from one side or the other before committing.","title":"Checking Out Conflicts"},{"location":"Advanced/git_advmerge/#merge-log","text":"AQnother useful tool when resolving merge conflicts is git log. This can help you get context on what may have contributed to the conflicts. Reviewing a little bit of history to remember why two lines of development were touching the same area of code can be really helpful sometimes. To get a full list of all of the unique commits that were included in either branch involved in this merge, we can use the \u201ctriple dot\u201d. git log --oneline --left-right HEAD...MERGE_HEAD We can further simplify this though to give us much more specific context. If we add the --merge option to git log, it will only show the commits in either side of the merge that touch a file that\u2019s currently conflicted. git log --oneline --left-right --merge If you run that with the -p option instead, you get just the diffs to the file that ended up in conflict. This can be really helpful in quickly giving you the context you need to help understand why something conflicts and how to more intelligently resolve it.","title":"Merge Log"},{"location":"Advanced/git_advmerge/#combined-diff-format","text":"Since Git stages any merge results that are successful, when you run git diff while in a conflicted merge state, you only get what is currently still in conflict. This can be helpful to see what you still have to resolve. When you run git diff directly after a merge conflict, it will give you information in a rather unique diff output format. git diff diff --cc hello.rb index 0399cd5,59727f0..0000000 --- a/hello.rb +++ b/hello.rb @@@ -1,7 -1,7 +1,11 @@@ #! /usr/bin/env ruby def hello ++<<<<<<< HEAD + puts 'hola world' ++======= + puts 'hello mundo' ++>>>>>>> mundo end hello() The format is called \u201cCombined Diff\u201d and gives you two columns of data next to each line. The first column shows you if that line is different (added or removed) between the \u201cours\u201d branch and the file in your working directory and the second column does the same between the \u201ctheirs\u201d branch and your working directory copy. So in that example you can see that the <<<<<<< and >>>>>>> lines are in the working copy but were not in either side of the merge. This makes sense because the merge tool stuck them in there for our context, but we\u2019re expected to remove them. If we resolve the conflict and run git diff again, we\u2019ll see the same thing, but it\u2019s a little more useful. vim hello.rb git diff diff --cc hello.rb index 0399cd5,59727f0..0000000 --- a/hello.rb +++ b/hello.rb @@@ -1,7 -1,7 +1,7 @@@ #! /usr/bin/env ruby def hello - puts 'hola world' - puts 'hello mundo' ++ puts 'hola mundo' end hello() This shows us that \u201chola world\u201d was in our side but not in the working copy, that \u201chello mundo\u201d was in their side but not in the working copy and finally that \u201chola mundo\u201d was not in either side but is now in the working copy. This can be useful to review before committing the resolution. You can also get this from the git log for any merge to see how something was resolved after the fact. Git will output this format if you run git show on a merge commit, or if you add a --cc option to a git log -p (which by default only shows patches for non-merge commits). git log --cc -p -1","title":"Combined Diff Format"},{"location":"Advanced/git_advmerge/#undoing-merges","text":"Now that you know how to create a merge commit, you\u2019ll probably make some by mistake. One of the great things about working with Git is that it\u2019s okay to make mistakes, because it\u2019s possible (and in many cases easy) to fix them. There are two ways to approach this problem, depending on what your desired outcome is.","title":"Undoing Merges"},{"location":"Advanced/git_advmerge/#fix-the-references","text":"If the unwanted merge commit only exists on your local repository, the easiest and best solution is to move the branches so that they point where you want them to. In most cases, if you follow the errant git merge with git reset --hard HEAD~, this will reset the branch pointers to what they were before the merge. To undo a merge commit and reset the branch to its state before the merge, you can use git reset --hard . git reset --hard HEAD^ reset --hard usually goes through three steps: Move the branch HEAD points to. In this case, we want to move master to where it was before the merge commit (C6). Make the index look like HEAD. Make the working directory look like the index. The downside of this approach is that it\u2019s rewriting history, which can be problematic with a shared repository. This approach also won\u2019t work if any other commits have been created since the merge; moving the refs would effectively lose those changes.","title":"Fix the References"},{"location":"Advanced/git_advmerge/#reverse-the-commit","text":"If moving the branch pointers around isn\u2019t going to work for you, Git gives you the option of making a new commit which undoes all the changes from an existing one. Git calls this operation a \u201crevert\u201d. To reverse a merge commit, you can use git revert . git revert -m 1 <merge-commit> git revert -m 1 HEAD","title":"Reverse the Commit"},{"location":"Advanced/git_advmerge/#other-types-of-merges","text":"So far we\u2019ve covered the normal merge of two branches, normally handled with what is called the \u201crecursive\u201d strategy of merging. There are other ways to merge branches together however.","title":"Other types of Merges"},{"location":"Advanced/git_advmerge/#our-or-theirs-preference","text":"During a merge, you can specify whether to prefer changes from the current branch ( --ours ) or the merged branch ( --theirs ). By default, when Git sees a conflict between two branches being merged, it will add merge conflict markers into your code and mark the file as conflicted and let you resolve it. If you would prefer for Git to simply choose a specific side and ignore the other side instead of letting you manually resolve the conflict, you can pass the merge command either a -Xours or -Xtheirs. If Git sees this, it will not add conflict markers. Any differences that are mergeable, it will merge. Any differences that conflict, it will simply choose the side you specify in whole, including binary files. git merge -Xours feature-branch git merge -Xtheirs feature-branch This option can also be passed to the git merge-file command we saw earlier by running something like git merge-file --ours for individual file merges. If you want to do something like this but not have Git even try to merge changes from the other side in, there is a more draconian option, which is the \u201cours\u201d merge strategy. This is different from the \u201cours\u201d recursive merge option. This will basically do a fake merge. It will record a new merge commit with both branches as parents, but it will not even look at the branch you\u2019re merging in. It will simply record as the result of the merge the exact code in your current branch. git merge -s ours mundo Merge made by the 'ours' strategy. git diff HEAD HEAD~ You can see that there is no difference between the branch we were on and the result of the merge. This can often be useful to basically trick Git into thinking that a branch is already merged when doing a merge later on. For example, say you branched off a release branch and have done some work on it that you will want to merge back into your master branch at some point. In the meantime some bugfix on master needs to be backported into your release branch. You can merge the bugfix branch into the release branch and also merge -s ours the same branch into your master branch (even though the fix is already there) so when you later merge the release branch again, there are no conflicts from the bugfix.","title":"Our or Theirs Preference"},{"location":"Advanced/git_advmerge/#subtree-merging","text":"The idea of the subtree merge is that you have two projects, and one of the projects maps to a subdirectory of the other one. When you specify a subtree merge, Git is often smart enough to figure out that one is a subtree of the other and merge appropriately. An example of this will be adding a separate project into an existing project and then merging the code of the second into a subdirectory of the first. So, we\u2019ll add the Rack application to our project. We\u2019ll add the Rack project as a remote reference in our own project and then check it out into its own branch: git remote add rack_remote https://github.com/rack/rack git fetch rack_remote --no-tags git checkout -b rack_branch rack_remote/master Now we have the root of the Rack project in our rack_branch branch and our own project in the master branch. If you check out one and then the other, you can see that they have different project roots. In this case, we want to pull the Rack project into our master project as a subdirectory. We can do that in Git with git read-tree. read-tree reads the root tree of one branch into your current staging area and working directory. We just switched back to your master branch, and we pull the rack_branch branch into the rack subdirectory of our master branch of our main project. git read-tree --prefix = rack/ -u rack_branch When we commit, it looks like we have all the Rack files under that subdirectory\u2009\u2014\u2009as though we copied them in from a tarball. What gets interesting is that we can fairly easily merge changes from one of the branches to the other. So, if the Rack project updates, we can pull in upstream changes by switching to that branch and pulling it in. git checkout rack_branch git pull Then, we can merge those changes back into our master branch. To pull in the changes and prepopulate the commit message, use the --squash option, as well as the recursive merge strategy\u2019s -Xsubtree option. The recursive strategy is the default here, but we include it for clarity. git checkout master git merge --squash -s recursive -Xsubtree = rack rack_branch All the changes from the Rack project are merged in and ready to be committed locally. You can also do the opposite\u2009\u2014\u2009make changes in the rack subdirectory of your master branch and then merge them into your rack_branch branch later to submit them to the maintainers or push them upstream. This gives us a way to have a workflow somewhat similar to the submodule workflow without using submodules. We can keep branches with other related projects in our repository and subtree merge them into our project occasionally. It is nice in some ways, for example all the code is committed to a single place. However, it has other drawbacks in that it\u2019s a bit more complex and easier to make mistakes in reintegrating changes or accidentally pushing a branch into an unrelated repository. Another slightly weird thing is that to get a diff between what you have in your rack subdirectory and the code in your rack_branch branch\u2009\u2014\u2009to see if you need to merge them\u2009\u2014\u2009you can\u2019t use the normal diff command. Instead, you must run git diff-tree with the branch you want to compare to. git diff-tree -p rack_branch Or, to compare what is in your rack subdirectory with what the master branch on the server was the last time you fetched, you can run: git diff-tree -p rack_remote/master","title":"Subtree Merging"},{"location":"Advanced/git_alias/","text":"In Git In Git, aliases are shortcuts or custom commands that you can create to simplify and streamline your workflow. They can be particularly useful to reduce typing and remember complex commands. Here's a step-by-step guide on how to add useful aliases, along with some suggestions for commonly used and helpful aliases: 1. Adding Git Aliases Open your terminal and run the following command to open the global Git configuration file in your default text editor: git config --global --edit This command opens the global configuration file in your preferred text editor. If you haven't configured a text editor, Git will prompt you to choose one. 2. Adding Aliases to the Configuration File Inside the configuration file, add the following section to set up aliases: [ alias ] alias_name = actual_git_command Replace alias_name with the desired alias and actual_git_command with the Git command or series of commands you want to associate with the alias. 3. Example Aliases Here are some commonly used and helpful aliases: [ alias ] # Show a compact and colorful log lg = log --graph --pretty = format: '%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --date = relative # Show the current branch current-branch = symbolic-ref --short HEAD # Show a concise status st = status -s # Commit all changes with a message ca = !git add -A && git commit -m # Show the diff of the last commit last-commit-diff = diff HEAD^ HEAD 4. Explanation of Some Aliases lg : Displays a compact and colorful log. current-branch : Shows the current branch. st : Provides a concise status of the repository. ca : Commits all changes with a message. Usage: git ca \"Commit message\" . last-commit-diff : Shows the diff of the last commit. 5. Save and Exit Save the configuration file and exit your text editor. 6. Using Aliases After adding aliases, you can use them in the terminal like regular Git commands. For example: git lg This will execute the log alias and display a compact and colorful log. 7. Additional Tips Choose aliases that align with your workflow and make common tasks more efficient. Keep aliases short and memorable. Test your aliases in a safe environment before using them extensively. Creating and using Git aliases can significantly improve your productivity and make Git commands more convenient. Feel free to customize these aliases to suit your preferences and workflow. In Bash Setting up aliases in Bash involves editing your Bash profile file. The Bash profile file is a script that runs whenever you start a new terminal session. Here's a step-by-step guide on how to set up aliases in Bash: 1. Open Your Bash Profile Open your Bash profile file in a text editor. The Bash profile is usually one of the following files, depending on your operating system: For Linux/macOS: ~/.bashrc or ~/.bash_profile For Windows using Git Bash: ~/.bashrc If the file doesn't exist, you can create it. # For Linux/macOS nano ~/.bashrc # or use your preferred text editor # For Windows using Git Bash nano ~/.bashrc # or use your preferred text editor or using VScode # For Linux/macOS code ~/.bashrc # or use your preferred text editor # For Windows using Git Bash code ~/.bashrc # or use your preferred text editor 2. Add Your Aliases In your Bash profile, add lines for each alias you want to create. The syntax is as follows: alias alias_name = 'actual_command' Replace alias_name with the desired alias and actual_command with the actual command or series of commands you want to associate with the alias. 3. Example Aliases Here are some example aliases: # Git aliases alias gst = 'git status' alias gl = 'git log' alias gll = 'git log --oneline' alias glog = 'git log --oneline --decorate --graph' alias gamend = 'git commit --amend' alias gr = 'git remote -v' alias gb = 'git branch' alias gba = 'git branch -a' alias gd = 'git diff' alias gds = 'git diff --staged' alias gsub = 'git submodule sync; git submodule update --init --recursive' alias gsreset = 'git submodule foreach --recursive git reset --hard' alias gf = 'git fetch --all --prune --tags --prune-tags --progress' alias gc = 'git commit' # Navigation aliases alias cdproj = 'cd ~/projects' alias cddownloads = 'cd ~/Downloads' alias cddesktop = 'cd ~/Desktop' alias .. = 'cd ..' alias ... = 'cd ../..' alias .... = 'cd ../../..' # Shortcuts for common commands alias ll = 'ls -alF' alias la = 'ls -A' alias cp = 'cp -i' alias mv = 'mv -i' alias rm = 'rm -i' # \ud83e\udd18 alias yolo = 'git push --force' # useful for daily stand-up # See https://dev.to/maxpou/git-cheat-sheet-advanced-3a17 git-standup () { AUTHOR = ${ AUTHOR := \"`git config user.name`\" } since = yesterday if [[ $( date +%u ) == 1 ]] ; then since = \"2 days ago\" fi git log --color --graph --pretty = format: '%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --since \" $since \" --author = \" $AUTHOR \" } 4. Save and Exit Save your changes and exit the text editor. For Nano, press Ctrl + X , then Y to confirm saving, and Enter to exit. For other editors, follow their respective save and exit commands. 5. Reload Your Bash Profile To apply the changes without restarting your terminal, either close and reopen the terminal or use the source command: source ~/.bashrc This command reloads the Bash profile, making your new aliases immediately available. 6. Verify Your Aliases To verify that your aliases are set up correctly, you can use the alias command: alias This will display a list of all defined aliases in your current session. Now you can use your aliases in the terminal for quick and convenient access to frequently used commands. Customize the aliases to match your workflow and make your command-line experience more efficient. In Powersell In PowerShell, you can add aliases using your PowerShell profile script. The profile script is a PowerShell script that is automatically executed when you start a PowerShell session. Here's a step-by-step guide on how to add aliases in PowerShell: 1. Open Your PowerShell Profile Open your PowerShell profile script in a text editor. If you don't have a profile, you can create one. The profile script is usually located at one of the following paths: Current User, Current Host (for all users): $PROFILE.AllUsersCurrentHost Current User, Current Host (for the current user): $PROFILE.CurrentUserCurrentHost All Users, All Hosts (for all users): $PROFILE.AllUsersAllHosts Current User, All Hosts (for the current user): $PROFILE.CurrentUserAllHosts To open your profile script, you can use the following command: notepad $PROFILE This command opens the profile script in Notepad. If the file doesn't exist, PowerShell will prompt you to create it. or use VSCode to open your profile script: code $PROFILE 2. Add Your Aliases In your PowerShell profile, add lines for each alias you want to create. The syntax is as follows: function alias_name { actual_command } Replace alias_name with the desired alias and actual_command with the actual command or series of commands you want to associate with the alias. 3. Example Aliases Here are some example aliases: # Git aliases function gs { git status } function ga { git add } function gc { git commit } function gp { git push } function gl { git log - -oneline } # Navigation aliases function cdproj { Set-Location C :\\ Projects } function cddownloads { Set-Location C :\\ Users \\ YourUsername \\ Downloads } function cddesktop { Set-Location C :\\ Users \\ YourUsername \\ Desktop } # Shortcuts for common commands function ll { Get-ChildItem -Force } 4. Save and Exit Save your changes and exit the text editor. 5. Reload Your PowerShell Profile To apply the changes without restarting PowerShell, you can use the Import-Module cmdlet: Import-Module $PROFILE 6. Verify Your Aliases To verify that your aliases are set up correctly, you can use the Get-Alias cmdlet: Get-Alias This will display a list of all defined aliases in your current PowerShell session. Now you can use your aliases in the PowerShell console for quick and convenient access to frequently used commands. Customize the aliases to match your workflow and make your PowerShell experience more efficient.","title":"Aliases"},{"location":"Advanced/git_alias/#in-git","text":"In Git, aliases are shortcuts or custom commands that you can create to simplify and streamline your workflow. They can be particularly useful to reduce typing and remember complex commands. Here's a step-by-step guide on how to add useful aliases, along with some suggestions for commonly used and helpful aliases:","title":"In Git"},{"location":"Advanced/git_alias/#1-adding-git-aliases","text":"Open your terminal and run the following command to open the global Git configuration file in your default text editor: git config --global --edit This command opens the global configuration file in your preferred text editor. If you haven't configured a text editor, Git will prompt you to choose one.","title":"1. Adding Git Aliases"},{"location":"Advanced/git_alias/#2-adding-aliases-to-the-configuration-file","text":"Inside the configuration file, add the following section to set up aliases: [ alias ] alias_name = actual_git_command Replace alias_name with the desired alias and actual_git_command with the Git command or series of commands you want to associate with the alias.","title":"2. Adding Aliases to the Configuration File"},{"location":"Advanced/git_alias/#3-example-aliases","text":"Here are some commonly used and helpful aliases: [ alias ] # Show a compact and colorful log lg = log --graph --pretty = format: '%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --date = relative # Show the current branch current-branch = symbolic-ref --short HEAD # Show a concise status st = status -s # Commit all changes with a message ca = !git add -A && git commit -m # Show the diff of the last commit last-commit-diff = diff HEAD^ HEAD","title":"3. Example Aliases"},{"location":"Advanced/git_alias/#4-explanation-of-some-aliases","text":"lg : Displays a compact and colorful log. current-branch : Shows the current branch. st : Provides a concise status of the repository. ca : Commits all changes with a message. Usage: git ca \"Commit message\" . last-commit-diff : Shows the diff of the last commit.","title":"4. Explanation of Some Aliases"},{"location":"Advanced/git_alias/#5-save-and-exit","text":"Save the configuration file and exit your text editor.","title":"5. Save and Exit"},{"location":"Advanced/git_alias/#6-using-aliases","text":"After adding aliases, you can use them in the terminal like regular Git commands. For example: git lg This will execute the log alias and display a compact and colorful log.","title":"6. Using Aliases"},{"location":"Advanced/git_alias/#7-additional-tips","text":"Choose aliases that align with your workflow and make common tasks more efficient. Keep aliases short and memorable. Test your aliases in a safe environment before using them extensively. Creating and using Git aliases can significantly improve your productivity and make Git commands more convenient. Feel free to customize these aliases to suit your preferences and workflow.","title":"7. Additional Tips"},{"location":"Advanced/git_alias/#in-bash","text":"Setting up aliases in Bash involves editing your Bash profile file. The Bash profile file is a script that runs whenever you start a new terminal session. Here's a step-by-step guide on how to set up aliases in Bash:","title":"In Bash"},{"location":"Advanced/git_alias/#1-open-your-bash-profile","text":"Open your Bash profile file in a text editor. The Bash profile is usually one of the following files, depending on your operating system: For Linux/macOS: ~/.bashrc or ~/.bash_profile For Windows using Git Bash: ~/.bashrc If the file doesn't exist, you can create it. # For Linux/macOS nano ~/.bashrc # or use your preferred text editor # For Windows using Git Bash nano ~/.bashrc # or use your preferred text editor or using VScode # For Linux/macOS code ~/.bashrc # or use your preferred text editor # For Windows using Git Bash code ~/.bashrc # or use your preferred text editor","title":"1. Open Your Bash Profile"},{"location":"Advanced/git_alias/#2-add-your-aliases","text":"In your Bash profile, add lines for each alias you want to create. The syntax is as follows: alias alias_name = 'actual_command' Replace alias_name with the desired alias and actual_command with the actual command or series of commands you want to associate with the alias.","title":"2. Add Your Aliases"},{"location":"Advanced/git_alias/#3-example-aliases_1","text":"Here are some example aliases: # Git aliases alias gst = 'git status' alias gl = 'git log' alias gll = 'git log --oneline' alias glog = 'git log --oneline --decorate --graph' alias gamend = 'git commit --amend' alias gr = 'git remote -v' alias gb = 'git branch' alias gba = 'git branch -a' alias gd = 'git diff' alias gds = 'git diff --staged' alias gsub = 'git submodule sync; git submodule update --init --recursive' alias gsreset = 'git submodule foreach --recursive git reset --hard' alias gf = 'git fetch --all --prune --tags --prune-tags --progress' alias gc = 'git commit' # Navigation aliases alias cdproj = 'cd ~/projects' alias cddownloads = 'cd ~/Downloads' alias cddesktop = 'cd ~/Desktop' alias .. = 'cd ..' alias ... = 'cd ../..' alias .... = 'cd ../../..' # Shortcuts for common commands alias ll = 'ls -alF' alias la = 'ls -A' alias cp = 'cp -i' alias mv = 'mv -i' alias rm = 'rm -i' # \ud83e\udd18 alias yolo = 'git push --force' # useful for daily stand-up # See https://dev.to/maxpou/git-cheat-sheet-advanced-3a17 git-standup () { AUTHOR = ${ AUTHOR := \"`git config user.name`\" } since = yesterday if [[ $( date +%u ) == 1 ]] ; then since = \"2 days ago\" fi git log --color --graph --pretty = format: '%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --since \" $since \" --author = \" $AUTHOR \" }","title":"3. Example Aliases"},{"location":"Advanced/git_alias/#4-save-and-exit","text":"Save your changes and exit the text editor. For Nano, press Ctrl + X , then Y to confirm saving, and Enter to exit. For other editors, follow their respective save and exit commands.","title":"4. Save and Exit"},{"location":"Advanced/git_alias/#5-reload-your-bash-profile","text":"To apply the changes without restarting your terminal, either close and reopen the terminal or use the source command: source ~/.bashrc This command reloads the Bash profile, making your new aliases immediately available.","title":"5. Reload Your Bash Profile"},{"location":"Advanced/git_alias/#6-verify-your-aliases","text":"To verify that your aliases are set up correctly, you can use the alias command: alias This will display a list of all defined aliases in your current session. Now you can use your aliases in the terminal for quick and convenient access to frequently used commands. Customize the aliases to match your workflow and make your command-line experience more efficient.","title":"6. Verify Your Aliases"},{"location":"Advanced/git_alias/#in-powersell","text":"In PowerShell, you can add aliases using your PowerShell profile script. The profile script is a PowerShell script that is automatically executed when you start a PowerShell session. Here's a step-by-step guide on how to add aliases in PowerShell:","title":"In Powersell"},{"location":"Advanced/git_alias/#1-open-your-powershell-profile","text":"Open your PowerShell profile script in a text editor. If you don't have a profile, you can create one. The profile script is usually located at one of the following paths: Current User, Current Host (for all users): $PROFILE.AllUsersCurrentHost Current User, Current Host (for the current user): $PROFILE.CurrentUserCurrentHost All Users, All Hosts (for all users): $PROFILE.AllUsersAllHosts Current User, All Hosts (for the current user): $PROFILE.CurrentUserAllHosts To open your profile script, you can use the following command: notepad $PROFILE This command opens the profile script in Notepad. If the file doesn't exist, PowerShell will prompt you to create it. or use VSCode to open your profile script: code $PROFILE","title":"1. Open Your PowerShell Profile"},{"location":"Advanced/git_alias/#2-add-your-aliases_1","text":"In your PowerShell profile, add lines for each alias you want to create. The syntax is as follows: function alias_name { actual_command } Replace alias_name with the desired alias and actual_command with the actual command or series of commands you want to associate with the alias.","title":"2. Add Your Aliases"},{"location":"Advanced/git_alias/#3-example-aliases_2","text":"Here are some example aliases: # Git aliases function gs { git status } function ga { git add } function gc { git commit } function gp { git push } function gl { git log - -oneline } # Navigation aliases function cdproj { Set-Location C :\\ Projects } function cddownloads { Set-Location C :\\ Users \\ YourUsername \\ Downloads } function cddesktop { Set-Location C :\\ Users \\ YourUsername \\ Desktop } # Shortcuts for common commands function ll { Get-ChildItem -Force }","title":"3. Example Aliases"},{"location":"Advanced/git_alias/#4-save-and-exit_1","text":"Save your changes and exit the text editor.","title":"4. Save and Exit"},{"location":"Advanced/git_alias/#5-reload-your-powershell-profile","text":"To apply the changes without restarting PowerShell, you can use the Import-Module cmdlet: Import-Module $PROFILE","title":"5. Reload Your PowerShell Profile"},{"location":"Advanced/git_alias/#6-verify-your-aliases_1","text":"To verify that your aliases are set up correctly, you can use the Get-Alias cmdlet: Get-Alias This will display a list of all defined aliases in your current PowerShell session. Now you can use your aliases in the PowerShell console for quick and convenient access to frequently used commands. Customize the aliases to match your workflow and make your PowerShell experience more efficient.","title":"6. Verify Your Aliases"},{"location":"Advanced/git_branch/","text":"Branching in Git is a powerful feature that allows developers to diverge from the main line of development (usually referred to as the master branch) and work on separate, isolated lines of development. Each branch represents an independent line of development, enabling multiple features, fixes, or experiments to be worked on simultaneously without interfering with each other. Branching can be a crucial part of software development, as it allows teams to work collaboratively on different features or fixes simultaneously while maintaining a clear and organized codebase. Isolating work in branches, changing context, and integrating changes into the main line of development can help streamline the development process and improve collaboration. What are Branches? A branch in Git is simply a lightweight movable pointer to one commit. The default branch name in Git is master. As you start making commits, you\u2019re given a master branch that points to the last commit you made. Every time you commit, the master branch pointer moves forward automatically. The pointer HEAD tells you where you are in the repository. When you switch branches, HEAD moves to the tip of the new branch. Main Branches Master Branch: By convention, the master branch is often used to represent the main line of development. It typically contains stable, production-ready code. Main Branch (Post-Git 2.28): Some projects have adopted renaming the default branch from master to main . The main branch serves the same purpose as the master branch, but the naming convention aims to promote more inclusive language. Creating Branches Creating a New Branch: To create a new branch, use the git branch <branch-name> command. Optionally, you can switch to the new branch immediately with git checkout -b <branch-name> or git switch -c <branch-name> . git branch feature-branch Switching Branches: To switch between branches, use the git checkout <branch-name> command or git switch <branch-name> . 1. git checkout git checkout feature-branch 2. git switch Introduced in Git version 2.23, git switch is specifically designed for branch switching. It offers a more intuitive and safer way to switch branches compared to git checkout . git switch <branch-name> Both git switch and git checkout are used for switching branches in Git. git switch is specifically designed for branch switching and offers a safer and more intuitive experience compared to git checkout . While git checkout remains a versatile command for various Git operations, git switch is recommended for branch switching to promote consistency and safety in your workflow. git checkout is a multi-purpose tool, capable of switching branches, discarding changes, and even creating new branches. Conversely, git switch is more specialized, focusing solely on switching and creating branches. Viewing Branches Listing Branches: To list all branches in the repository, use the git branch command. git branch An asterisk ( * ) in the output indicates that the branch you are currently on is the currently active branch. The git branch -a command is used to list all branches in a Git repository, including both local branches and remote branches. git branch -a git branch : This is the Git command used to manage branches in a repository. -a (or --all ): This option tells Git to list both local branches and remote branches. When you run git branch -a , Git will list all branches in the repository, including: Local Branches: Branches that exist only in your local repository. Remote Branches: Branches that exist on the remote repository (e.g., on GitHub, GitLab). Remote Tracking Branches: Local representations of remote branches, used for tracking changes from the remote repository. The output typically looks like this: * main feature-branch remotes/origin/HEAD -> origin/main remotes/origin/main remotes/origin/feature-branch The branches listed without the remotes/ prefix are local branches. The branches listed with the remotes/ prefix are remote branches. origin is the default name for the remote repository, but you may see other names if you have multiple remotes configured. Useful flags To display information about branches, you can use the following flags: -v, --verbose : Displays additional information about each branch, showing the commit message or commit SHA of the last commit on each branch. -vv : Displays more verbose information about each branch, including tracking information. -l, --list : Lists branches matching the given pattern. -a, --all : Lists all branches in the repository, including local and remote branches. -r, --remote : Lists only remote branches. To manage branches, you can use the following flags: -d, --delete : Deletes the specified branch. -D : Shortcut for --delete --force . Deletes the specified branch forcibly, even if it has unmerged changes. -m, --move : Renames the specified branch locally. # Rename the branch locally git branch --move bad-branch-name corrected-branch-name # Push the branch to the remote repository git push --set-upstream origin corrected-branch-name # delete bad branch in the remote repository git push origin --delete bad-branch-name -c, --copy : Copies the specified branch. To filter branches, you can use the following flags: --merged : Lists only branches that have been merged into the current branch. --no-merged : Lists only branches that have not been merged into the current branch. --contains : Lists only branches that contain the specified commit. --no-contains : Lists only branches that do not contain the specified commit. --points-at : Lists only branches that point at the specified commit. --no-points-at : Lists only branches that do not point at the specified commit. --merged and --no-merged will, if not given a commit or branch name as an argument, show you what is, respectively, merged or not merged into your current branch. But if you provide an additional argument to ask about the merge state with respect to some other branch without checking that other branch out first, as in, what is not merged into the master branch? git branch --no-merged master Merging Branches Let's do another commit on the feature-branch branch. We will want eventually to merge this commit into the main branch. However, other collaborators are working on the other features (hotfixes) and create another branch for a hotfix. Fast-forward merges To merge changes from one branch into another, use the git merge <branch-name> command. However you have to first checkout to the branch you want to merge into. git checkout master git merge hotfix-branch You\u2019ll notice the phrase \u201cfast-forward\u201d in that merge. Because the commit pointed to by the branch hotfix (d45a6) you merged in was directly ahead of the commit (fe456) you\u2019re on, Git simply moves the pointer forward. Git simplifies things by moving the pointer forward because there is no divergent work to merge together\u2009\u2014\u2009this is called a \u201cfast-forward\u201d. Deleting Branches Now, that the hotfix branch is no longer needed, we can delete it. To delete a branch, use the git branch -d <branch-name> command. git branch -d hotfix-branch Recursive merge Now we can switch back to our work-in-progress branch in order to continue working on our project. git checkout feature-branch And do more commits on the feature branch. As you can see, now there is a divergent work to merge. Because the commit on the branch you\u2019re on isn\u2019t a direct ancestor of the branch you\u2019re merging in. To merge merge changes into the master branch, we must first switch to the master branch. then we can merge the feature branch into the master branch. git checkout master then git merge feature-branch You will notice the info: Merge made by the 'recursive' strategy. Git does a simple three-way merge, using the two snapshots pointed to by the branch tips and the common ancestor of the two. Instead of just moving the branch pointer forward, Git creates a new snapshot that results from this three-way merge and automatically creates a new commit that points to it. This is referred to as a merge commit, and is special in that it has more than one parent. Now that our work is merged in, we have no further need for the feature branch. We can close the issue in the issue-tracking system, and delete the branch: git branch -d feature-branch Merging conflicts If you changed the same part of the same file differently in the two branches you\u2019re merging, Git won\u2019t be able to merge them cleanly. In this case, you\u2019ll see a merge conflict in the output, and Git will tell you which files you need to resolve the conflict with. Git hasn\u2019t automatically created a new merge commit. It has paused the process while you resolve the conflict. If you want to see which files are unmerged at any point after a merge conflict, you can run git status. git status Anything that has merge conflicts and hasn\u2019t been resolved is listed as unmerged. Git adds standard conflict-resolution markers to the files that have conflicts, so you can open them manually and resolve those conflicts. Merge conflicts are recognized by VS Code. Differences are highlighted and there are inline actions to accept either one or both changes. These inline actions are shown in the editor at the top of the merge conflict. Once the conflicts are resolved, stage the conflicting file so you can commit those changes. This resolution of the merge conflict needs to be done in Git. The <<<<<<<<<, =======, and >>>>>>> lines need to be completely removed. After you\u2019ve resolved each of these sections in each conflicted file, run git add on each file to mark it as resolved. Staging the file marks it as resolved in Git. If you want to use a graphical tool to resolve these issues, you can run git mergetool, which fires up an appropriate visual merge tool and walks you through the conflicts. After you exit the merge tool, Git asks you if the merge was successful. If you tell the script that it was, it stages the file to mark it as resolved for you. You can run git status again to verify that all conflicts have been resolved. If you\u2019re happy with that, and you verify that everything that had conflicts has been staged, you can type git commit to finalize the merge commit. 3-way merge editor To help you resolve merge conflicts, VS Code provides a 3-way merge editor where you can interactively accept incoming and current changes and view and edit the resulting merged file. The 3-way merge editor is opened by selecting the Resolve in Merge Editor button in the bottom right corner of a file with Git merge conflicts. The 3-way merge editor displays separate views for Incoming changes (on the left), Current changes (on the right), and the Result of the merge (at the bottom). Conflicts are highlighted and can be resolved by using the CodeLens buttons. The 3-way merge editor allows you to resolve conflicts by accepting either one or both changes. You can also manually edit the result of the merge. For some conflicts, the merge editor shows an Accept Combination button. Accepting the combination resolves the current conflict by smartly merging both changes. This is especially useful for changes in the same line that don't touch the same characters. Use the Ignore buttons to accept neither the incoming nor current change, but mark the conflict as resolved. This resets the conflicting area to the state before any changes were made. You can use the conflict counter in the right of the result editor to keep track of how many unresolved conflicts are remaining. Clicking on the counter jumps to the next unresolved conflict. Once all conflicts are resolved, you can complete the merge by selecting Complete Merge in the bottom right corner. This stages the file and closes the merge editor. Selecting the three dots (\u00b7\u00b7\u00b7) in the top right corner of the merge editor opens a context menu with additional options. You can switch to a vertical layout and display the base view, which shows the state of the file before any changes were made. The three dots next to Incoming, Current, and Result offer options for each view, such as showing a side-by-side diff against base, accepting all changes, or resetting the result. Sometimes the \u00b0Resolve in Merge Editor\u00b0 button is not visible. If this happens, you can open the 3-way merge editor by opening the file in the editor and typing git mergetool. This will open the 3-way merge editor. Branching Strategies Git encourages workflows that branch and merge often, even multiple times in a day. Understanding and mastering this feature gives you a powerful and unique tool and can entirely change the way that you develop. The way Git branches is incredibly lightweight, making branching operations nearly instantaneous, and switching back and forth between branches generally just as fast. Feature Branching: Create a separate branch for each new feature or task. This isolates changes related to specific features, making them easier to manage and review. Release Branching: Create branches for each release to stabilize the codebase before deployment. Hotfix Branching: Create branches to fix critical issues in production code quickly. Branching Best Practices Use Descriptive Names: Choose meaningful names for branches to indicate their purpose or associated feature. Keep Branches Short-Lived: Merge branches into the main line of development once their purpose is served to avoid branch clutter. Regularly Update Branches: Keep branches up-to-date with changes in the main line of development by frequently merging or rebasing. Review Branches: Encourage code review and collaboration by reviewing changes made in feature branches before merging them. Remote Branches Pushing a Branch: To push a local branch to a remote repository, use the git push <remote-name> <branch-name> command. git push origin feature-branch Tracking Remote Branches: After pushing a branch to the remote repository, it can be tracked. This means Git remembers the relationship between the local branch and its corresponding remote branch. git checkout -b feature-branch origin/feature-branch The git branch --set-upstream-to command is used to set up the tracking relationship between a local branch and a remote branch. This command tells Git which remote branch the local branch should track, allowing you to push and pull changes to and from the correct remote branch without specifying it each time. git branch --set-upstream-to = <remote>/<branch> <remote> : The name of the remote repository. <branch> : The name of the remote branch. git branch --set-upstream-to = origin/main This command sets the tracking relationship for the current branch to the specified remote branch ( main in this example) in the origin remote repository. After running this command, Git knows that when you push or pull changes from the current branch, it should interact with the main branch in the origin remote repository. Syncing Changes After setting up tracking, you can simply use git push and git pull without specifying the remote branch, as Git already knows where to push and pull changes from. This command can also be used in combination with git push -u or git push --set-upstream to set up tracking and push changes to the remote branch in one step. Rebasing In Git, there are two main ways to integrate changes from one branch into another: the merge and the rebase. The Basic Rebase The merge command performs a three-way merge between the two latest branch snapshots (d45a6 and a615b) and the most recent common ancestor of the two (fe456), creating a new snapshot (and commit 1ac5b). However, there is another way: you can take the patch of the change that was introduced in a615b and reapply it on top of d45a6. In Git, this is called rebasing. With the rebase command, you can take all the changes that were committed on one branch and replay them on a different branch. This operation works by going to the common ancestor of the two branches (the one you\u2019re on and the one you\u2019re rebasing onto), getting the diff introduced by each commit of the branch you\u2019re on, saving those diffs to temporary files, resetting the current branch to the same commit as the branch you are rebasing onto, and finally applying each change in turn. git checkout feature-branch git rebase master At this point, you can go back to the master branch and do a fast-forward merge. git checkout master git merge feature-branch Rebasing makes for a cleaner history. If you examine the log of a rebased branch, it looks like a linear history: it appears that all the work happened in series, even when it originally happened in parallel. --onto flag The --onto flag in the git rebase command is used to specify a new base (or starting point) for the rebase operation. This flag allows you to reapply a series of commits onto a different branch or commit, effectively changing the parent of the commits being rebased. git rebase --onto <new_base> <old_base> <branch> <new_base> : Specifies the new base commit or branch where you want the series of commits to be reapplied. <old_base> : Specifies the original base commit or branch from which the series of commits should be moved. <branch> : Specifies the branch containing the commits you want to rebase. Steps: Identify the Commits to Rebase: The rebase operation will take the commits from <old_base> up to (but not including) the current branch's tip. Detach the Commits: The commits to be rebased are temporarily detached from their original base. Apply the Commits to the New Base: The detached commits are then applied one by one on top of the <new_base> . Reattach the Branch: Finally, the branch pointer is moved to the last commit that was applied, completing the rebase operation. Use Cases: Restructuring Commit History: You can use --onto to move a series of commits from one branch to another, effectively restructuring the commit history. Creating Feature Branches: If you started working on a feature branch from the wrong starting point, you can use --onto to rebase your changes onto the correct branch or commit. Example: Suppose you have the following commit history: A -- B -- C (feature) / ... -- X -- Y -- Z (master) To move commits B and C from the feature branch onto master , you can use: git rebase --onto master feature~2 feature After the rebase, the commit history would look like: B' -- C' (feature) / ... -- X -- Y -- Z -- A -- B -- C (master) In this example, B' and C' represent the rebased commits on the feature branch, applied on top of the master branch. The original B and C commits are effectively moved onto the master branch. Notes: Always exercise caution when using git rebase , especially with --onto , as it rewrites commit history. Make sure you understand the implications of rebasing and its potential impact on collaboration and shared branches. Do not rebase commits that exist outside your repository and that people may have based work on. When you rebase stuff, you\u2019re abandoning existing commits and creating new ones that are similar but different. If you push commits somewhere and others pull them down and base work on them, and then you rewrite those commits with git rebase and push them up again, your collaborators will have to re-merge their work and things will get messy when you try to pull their work back into yours.","title":"Branching"},{"location":"Advanced/git_branch/#what-are-branches","text":"A branch in Git is simply a lightweight movable pointer to one commit. The default branch name in Git is master. As you start making commits, you\u2019re given a master branch that points to the last commit you made. Every time you commit, the master branch pointer moves forward automatically. The pointer HEAD tells you where you are in the repository. When you switch branches, HEAD moves to the tip of the new branch.","title":"What are Branches?"},{"location":"Advanced/git_branch/#main-branches","text":"Master Branch: By convention, the master branch is often used to represent the main line of development. It typically contains stable, production-ready code. Main Branch (Post-Git 2.28): Some projects have adopted renaming the default branch from master to main . The main branch serves the same purpose as the master branch, but the naming convention aims to promote more inclusive language.","title":"Main Branches"},{"location":"Advanced/git_branch/#creating-branches","text":"Creating a New Branch: To create a new branch, use the git branch <branch-name> command. Optionally, you can switch to the new branch immediately with git checkout -b <branch-name> or git switch -c <branch-name> . git branch feature-branch Switching Branches: To switch between branches, use the git checkout <branch-name> command or git switch <branch-name> .","title":"Creating Branches"},{"location":"Advanced/git_branch/#1-git-checkout","text":"git checkout feature-branch","title":"1. git checkout"},{"location":"Advanced/git_branch/#2-git-switch","text":"Introduced in Git version 2.23, git switch is specifically designed for branch switching. It offers a more intuitive and safer way to switch branches compared to git checkout . git switch <branch-name> Both git switch and git checkout are used for switching branches in Git. git switch is specifically designed for branch switching and offers a safer and more intuitive experience compared to git checkout . While git checkout remains a versatile command for various Git operations, git switch is recommended for branch switching to promote consistency and safety in your workflow. git checkout is a multi-purpose tool, capable of switching branches, discarding changes, and even creating new branches. Conversely, git switch is more specialized, focusing solely on switching and creating branches.","title":"2. git switch"},{"location":"Advanced/git_branch/#viewing-branches","text":"Listing Branches: To list all branches in the repository, use the git branch command. git branch An asterisk ( * ) in the output indicates that the branch you are currently on is the currently active branch. The git branch -a command is used to list all branches in a Git repository, including both local branches and remote branches. git branch -a git branch : This is the Git command used to manage branches in a repository. -a (or --all ): This option tells Git to list both local branches and remote branches. When you run git branch -a , Git will list all branches in the repository, including: Local Branches: Branches that exist only in your local repository. Remote Branches: Branches that exist on the remote repository (e.g., on GitHub, GitLab). Remote Tracking Branches: Local representations of remote branches, used for tracking changes from the remote repository. The output typically looks like this: * main feature-branch remotes/origin/HEAD -> origin/main remotes/origin/main remotes/origin/feature-branch The branches listed without the remotes/ prefix are local branches. The branches listed with the remotes/ prefix are remote branches. origin is the default name for the remote repository, but you may see other names if you have multiple remotes configured.","title":"Viewing Branches"},{"location":"Advanced/git_branch/#useful-flags","text":"To display information about branches, you can use the following flags: -v, --verbose : Displays additional information about each branch, showing the commit message or commit SHA of the last commit on each branch. -vv : Displays more verbose information about each branch, including tracking information. -l, --list : Lists branches matching the given pattern. -a, --all : Lists all branches in the repository, including local and remote branches. -r, --remote : Lists only remote branches. To manage branches, you can use the following flags: -d, --delete : Deletes the specified branch. -D : Shortcut for --delete --force . Deletes the specified branch forcibly, even if it has unmerged changes. -m, --move : Renames the specified branch locally. # Rename the branch locally git branch --move bad-branch-name corrected-branch-name # Push the branch to the remote repository git push --set-upstream origin corrected-branch-name # delete bad branch in the remote repository git push origin --delete bad-branch-name -c, --copy : Copies the specified branch. To filter branches, you can use the following flags: --merged : Lists only branches that have been merged into the current branch. --no-merged : Lists only branches that have not been merged into the current branch. --contains : Lists only branches that contain the specified commit. --no-contains : Lists only branches that do not contain the specified commit. --points-at : Lists only branches that point at the specified commit. --no-points-at : Lists only branches that do not point at the specified commit. --merged and --no-merged will, if not given a commit or branch name as an argument, show you what is, respectively, merged or not merged into your current branch. But if you provide an additional argument to ask about the merge state with respect to some other branch without checking that other branch out first, as in, what is not merged into the master branch? git branch --no-merged master","title":"Useful flags"},{"location":"Advanced/git_branch/#merging-branches","text":"Let's do another commit on the feature-branch branch. We will want eventually to merge this commit into the main branch. However, other collaborators are working on the other features (hotfixes) and create another branch for a hotfix.","title":"Merging Branches"},{"location":"Advanced/git_branch/#fast-forward-merges","text":"To merge changes from one branch into another, use the git merge <branch-name> command. However you have to first checkout to the branch you want to merge into. git checkout master git merge hotfix-branch You\u2019ll notice the phrase \u201cfast-forward\u201d in that merge. Because the commit pointed to by the branch hotfix (d45a6) you merged in was directly ahead of the commit (fe456) you\u2019re on, Git simply moves the pointer forward. Git simplifies things by moving the pointer forward because there is no divergent work to merge together\u2009\u2014\u2009this is called a \u201cfast-forward\u201d.","title":"Fast-forward merges"},{"location":"Advanced/git_branch/#deleting-branches","text":"Now, that the hotfix branch is no longer needed, we can delete it. To delete a branch, use the git branch -d <branch-name> command. git branch -d hotfix-branch","title":"Deleting Branches"},{"location":"Advanced/git_branch/#recursive-merge","text":"Now we can switch back to our work-in-progress branch in order to continue working on our project. git checkout feature-branch And do more commits on the feature branch. As you can see, now there is a divergent work to merge. Because the commit on the branch you\u2019re on isn\u2019t a direct ancestor of the branch you\u2019re merging in. To merge merge changes into the master branch, we must first switch to the master branch. then we can merge the feature branch into the master branch. git checkout master then git merge feature-branch You will notice the info: Merge made by the 'recursive' strategy. Git does a simple three-way merge, using the two snapshots pointed to by the branch tips and the common ancestor of the two. Instead of just moving the branch pointer forward, Git creates a new snapshot that results from this three-way merge and automatically creates a new commit that points to it. This is referred to as a merge commit, and is special in that it has more than one parent. Now that our work is merged in, we have no further need for the feature branch. We can close the issue in the issue-tracking system, and delete the branch: git branch -d feature-branch","title":"Recursive merge"},{"location":"Advanced/git_branch/#merging-conflicts","text":"If you changed the same part of the same file differently in the two branches you\u2019re merging, Git won\u2019t be able to merge them cleanly. In this case, you\u2019ll see a merge conflict in the output, and Git will tell you which files you need to resolve the conflict with. Git hasn\u2019t automatically created a new merge commit. It has paused the process while you resolve the conflict. If you want to see which files are unmerged at any point after a merge conflict, you can run git status. git status Anything that has merge conflicts and hasn\u2019t been resolved is listed as unmerged. Git adds standard conflict-resolution markers to the files that have conflicts, so you can open them manually and resolve those conflicts. Merge conflicts are recognized by VS Code. Differences are highlighted and there are inline actions to accept either one or both changes. These inline actions are shown in the editor at the top of the merge conflict. Once the conflicts are resolved, stage the conflicting file so you can commit those changes. This resolution of the merge conflict needs to be done in Git. The <<<<<<<<<, =======, and >>>>>>> lines need to be completely removed. After you\u2019ve resolved each of these sections in each conflicted file, run git add on each file to mark it as resolved. Staging the file marks it as resolved in Git. If you want to use a graphical tool to resolve these issues, you can run git mergetool, which fires up an appropriate visual merge tool and walks you through the conflicts. After you exit the merge tool, Git asks you if the merge was successful. If you tell the script that it was, it stages the file to mark it as resolved for you. You can run git status again to verify that all conflicts have been resolved. If you\u2019re happy with that, and you verify that everything that had conflicts has been staged, you can type git commit to finalize the merge commit.","title":"Merging conflicts"},{"location":"Advanced/git_branch/#3-way-merge-editor","text":"To help you resolve merge conflicts, VS Code provides a 3-way merge editor where you can interactively accept incoming and current changes and view and edit the resulting merged file. The 3-way merge editor is opened by selecting the Resolve in Merge Editor button in the bottom right corner of a file with Git merge conflicts. The 3-way merge editor displays separate views for Incoming changes (on the left), Current changes (on the right), and the Result of the merge (at the bottom). Conflicts are highlighted and can be resolved by using the CodeLens buttons. The 3-way merge editor allows you to resolve conflicts by accepting either one or both changes. You can also manually edit the result of the merge. For some conflicts, the merge editor shows an Accept Combination button. Accepting the combination resolves the current conflict by smartly merging both changes. This is especially useful for changes in the same line that don't touch the same characters. Use the Ignore buttons to accept neither the incoming nor current change, but mark the conflict as resolved. This resets the conflicting area to the state before any changes were made. You can use the conflict counter in the right of the result editor to keep track of how many unresolved conflicts are remaining. Clicking on the counter jumps to the next unresolved conflict. Once all conflicts are resolved, you can complete the merge by selecting Complete Merge in the bottom right corner. This stages the file and closes the merge editor. Selecting the three dots (\u00b7\u00b7\u00b7) in the top right corner of the merge editor opens a context menu with additional options. You can switch to a vertical layout and display the base view, which shows the state of the file before any changes were made. The three dots next to Incoming, Current, and Result offer options for each view, such as showing a side-by-side diff against base, accepting all changes, or resetting the result. Sometimes the \u00b0Resolve in Merge Editor\u00b0 button is not visible. If this happens, you can open the 3-way merge editor by opening the file in the editor and typing git mergetool. This will open the 3-way merge editor.","title":"3-way merge editor"},{"location":"Advanced/git_branch/#branching-strategies","text":"Git encourages workflows that branch and merge often, even multiple times in a day. Understanding and mastering this feature gives you a powerful and unique tool and can entirely change the way that you develop. The way Git branches is incredibly lightweight, making branching operations nearly instantaneous, and switching back and forth between branches generally just as fast. Feature Branching: Create a separate branch for each new feature or task. This isolates changes related to specific features, making them easier to manage and review. Release Branching: Create branches for each release to stabilize the codebase before deployment. Hotfix Branching: Create branches to fix critical issues in production code quickly.","title":"Branching Strategies"},{"location":"Advanced/git_branch/#branching-best-practices","text":"Use Descriptive Names: Choose meaningful names for branches to indicate their purpose or associated feature. Keep Branches Short-Lived: Merge branches into the main line of development once their purpose is served to avoid branch clutter. Regularly Update Branches: Keep branches up-to-date with changes in the main line of development by frequently merging or rebasing. Review Branches: Encourage code review and collaboration by reviewing changes made in feature branches before merging them.","title":"Branching Best Practices"},{"location":"Advanced/git_branch/#remote-branches","text":"Pushing a Branch: To push a local branch to a remote repository, use the git push <remote-name> <branch-name> command. git push origin feature-branch Tracking Remote Branches: After pushing a branch to the remote repository, it can be tracked. This means Git remembers the relationship between the local branch and its corresponding remote branch. git checkout -b feature-branch origin/feature-branch The git branch --set-upstream-to command is used to set up the tracking relationship between a local branch and a remote branch. This command tells Git which remote branch the local branch should track, allowing you to push and pull changes to and from the correct remote branch without specifying it each time. git branch --set-upstream-to = <remote>/<branch> <remote> : The name of the remote repository. <branch> : The name of the remote branch. git branch --set-upstream-to = origin/main This command sets the tracking relationship for the current branch to the specified remote branch ( main in this example) in the origin remote repository. After running this command, Git knows that when you push or pull changes from the current branch, it should interact with the main branch in the origin remote repository. Syncing Changes After setting up tracking, you can simply use git push and git pull without specifying the remote branch, as Git already knows where to push and pull changes from. This command can also be used in combination with git push -u or git push --set-upstream to set up tracking and push changes to the remote branch in one step.","title":"Remote Branches"},{"location":"Advanced/git_branch/#rebasing","text":"In Git, there are two main ways to integrate changes from one branch into another: the merge and the rebase.","title":"Rebasing"},{"location":"Advanced/git_branch/#the-basic-rebase","text":"The merge command performs a three-way merge between the two latest branch snapshots (d45a6 and a615b) and the most recent common ancestor of the two (fe456), creating a new snapshot (and commit 1ac5b). However, there is another way: you can take the patch of the change that was introduced in a615b and reapply it on top of d45a6. In Git, this is called rebasing. With the rebase command, you can take all the changes that were committed on one branch and replay them on a different branch. This operation works by going to the common ancestor of the two branches (the one you\u2019re on and the one you\u2019re rebasing onto), getting the diff introduced by each commit of the branch you\u2019re on, saving those diffs to temporary files, resetting the current branch to the same commit as the branch you are rebasing onto, and finally applying each change in turn. git checkout feature-branch git rebase master At this point, you can go back to the master branch and do a fast-forward merge. git checkout master git merge feature-branch Rebasing makes for a cleaner history. If you examine the log of a rebased branch, it looks like a linear history: it appears that all the work happened in series, even when it originally happened in parallel.","title":"The Basic Rebase"},{"location":"Advanced/git_branch/#-onto-flag","text":"The --onto flag in the git rebase command is used to specify a new base (or starting point) for the rebase operation. This flag allows you to reapply a series of commits onto a different branch or commit, effectively changing the parent of the commits being rebased. git rebase --onto <new_base> <old_base> <branch> <new_base> : Specifies the new base commit or branch where you want the series of commits to be reapplied. <old_base> : Specifies the original base commit or branch from which the series of commits should be moved. <branch> : Specifies the branch containing the commits you want to rebase. Steps: Identify the Commits to Rebase: The rebase operation will take the commits from <old_base> up to (but not including) the current branch's tip. Detach the Commits: The commits to be rebased are temporarily detached from their original base. Apply the Commits to the New Base: The detached commits are then applied one by one on top of the <new_base> . Reattach the Branch: Finally, the branch pointer is moved to the last commit that was applied, completing the rebase operation. Use Cases: Restructuring Commit History: You can use --onto to move a series of commits from one branch to another, effectively restructuring the commit history. Creating Feature Branches: If you started working on a feature branch from the wrong starting point, you can use --onto to rebase your changes onto the correct branch or commit. Example: Suppose you have the following commit history: A -- B -- C (feature) / ... -- X -- Y -- Z (master) To move commits B and C from the feature branch onto master , you can use: git rebase --onto master feature~2 feature After the rebase, the commit history would look like: B' -- C' (feature) / ... -- X -- Y -- Z -- A -- B -- C (master) In this example, B' and C' represent the rebased commits on the feature branch, applied on top of the master branch. The original B and C commits are effectively moved onto the master branch. Notes: Always exercise caution when using git rebase , especially with --onto , as it rewrites commit history. Make sure you understand the implications of rebasing and its potential impact on collaboration and shared branches. Do not rebase commits that exist outside your repository and that people may have based work on. When you rebase stuff, you\u2019re abandoning existing commits and creating new ones that are similar but different. If you push commits somewhere and others pull them down and base work on them, and then you rewrite those commits with git rebase and push them up again, your collaborators will have to re-merge their work and things will get messy when you try to pull their work back into yours.","title":"--onto flag"},{"location":"Advanced/git_checkout/","text":"git checkout is a fundamental Git command used for switching branches, restoring files from previous commits, creating new branches, and more. It has been a core part of Git since its inception and remains widely used. However, Git has introduced newer commands like git switch and git restore that offer similar functionality and improved features. Features of git checkout Switching Branches git checkout <branch> Allows you to switch between branches in your repository. Creating New Branches git checkout -b <new-branch> Creates a new branch and switches to it in one step. Restoring Files git checkout <commit> -- <file> Restores a specific file from a previous commit to the working directory. Discarding Local Changes git checkout -- <file> Discards local changes made to a specific file and restores it to the state from the last commit. Checking Out Files from Other Branches git checkout <branch> -- <file> Checks out a specific file from another branch into the current branch's working directory. Comparison with Newer Commands Previous command New command Explanation git checkout <branch> git switch <branch> Both commands are used to switch branches. The new command git switch offers a clearer syntax for this task. git checkout N/A (use git status ) The git checkout command without arguments is often used to check the status of the repository. git checkout -b <new_branch> [<start_point>] git switch -c <new-branch> [<start-point>] Both commands are used to create and switch to a new branch. The new command git switch -c offers a clearer syntax for branch creation. git checkout -B <new_branch> [<start_point>] git switch -C <new-branch> [<start-point>] Both commands are used to forcibly create and switch to a new branch. The new command git switch -C offers a clearer syntax for this task. git checkout --orphan <new_branch> git switch --orphan <new-branch> Both commands are used to create a new orphan branch. git checkout --orphan <new_branch> <start_point> N/A (use git switch <start-point> then git switch --orphan <new-branch> ) There is no direct equivalent for this operation. You can achieve similar behavior by first switching to the start point and then creating the orphan branch. git checkout [--detach] <commit> git switch --detach <commit> Both commands are used to checkout a specific commit in a detached HEAD state. git checkout --detach [<branch>] git switch --detach [<branch>] Both commands are used to detach the HEAD from the current or specified branch. git checkout [--] <pathspec>\u2026 git restore [--] <pathspec>\u2026 Both commands are used to restore files in the working directory. The new command git restore provides a clearer syntax for this operation. git checkout --pathspec-from-file=<file> git restore --pathspec-from-file=<file> Both commands are used to restore files specified in a file. The new command git restore provides a clearer syntax for this operation. git checkout <tree-ish> [--] <pathspec>\u2026 git restore -s <tree> [--] <pathspec>\u2026 Both commands are used to restore files from a specific tree. The new command git restore provides a clearer syntax for this operation. git checkout <tree-ish> --pathspec-from-file=<file> git restore -s <tree> --pathspec-from-file=<file> Both commands are used to restore files specified in a file from a specific tree. The new command git restore provides a clearer syntax for this operation. git checkout -p [<tree-ish>] [--] [<pathspec>\u2026] git restore -p [-s <tree>] [--] [<pathspec>\u2026] Both commands are used to interactively restore changes from a specific tree. The new command git restore provides a clearer syntax for this operation. As shown by this comparison, some prior usages can be converted to the new commands by simply replacing the old command name (checkout) with the new one (switch, restore), whereas others require additional adjustment. Notable changes include: The -b/-B options for creating a new branch before switching are renamed to -c/-C. They also have long option variants (--create/--force-create), unlike before. --detach (or -d) is now always required when switching to a detached head, where it was previously optional for commits but required for branches. The source tree for restoring is now given by the -s (or --source) option, rather than being an inline argument. Switching using --force (or -f) now fails if there are unmerged entries, rather than ignoring them. --force has also been renamed to --discard-changes, with --force being kept as an alias. git switch Provides a clearer and more intuitive syntax specifically for switching branches. git restore Offers dedicated options for restoring files and discarding changes, providing a more explicit and versatile interface for these operations. Use Cases Simple Branch Switching For basic branch switching operations, git checkout remains a straightforward and commonly used command. File-Level Operations When performing file-level operations like restoring files from commits or discarding local changes, git checkout provides a concise syntax. Advanced Branch Management For more advanced branch management tasks or when using newer Git features, git switch and git restore may offer advantages in terms of clarity and functionality. git checkout is a versatile Git command with various features for branch switching, file restoration, and more. While newer commands like git switch and git restore offer some improvements and specialized functionality, git checkout remains a fundamental and widely used command in Git workflows. Depending on the specific task at hand and personal preference, you may choose to use git checkout or explore the capabilities of newer Git commands for branch and file management.","title":"Checkout"},{"location":"Advanced/git_checkout/#features-of-git-checkout","text":"Switching Branches git checkout <branch> Allows you to switch between branches in your repository. Creating New Branches git checkout -b <new-branch> Creates a new branch and switches to it in one step. Restoring Files git checkout <commit> -- <file> Restores a specific file from a previous commit to the working directory. Discarding Local Changes git checkout -- <file> Discards local changes made to a specific file and restores it to the state from the last commit. Checking Out Files from Other Branches git checkout <branch> -- <file> Checks out a specific file from another branch into the current branch's working directory.","title":"Features of git checkout"},{"location":"Advanced/git_checkout/#comparison-with-newer-commands","text":"Previous command New command Explanation git checkout <branch> git switch <branch> Both commands are used to switch branches. The new command git switch offers a clearer syntax for this task. git checkout N/A (use git status ) The git checkout command without arguments is often used to check the status of the repository. git checkout -b <new_branch> [<start_point>] git switch -c <new-branch> [<start-point>] Both commands are used to create and switch to a new branch. The new command git switch -c offers a clearer syntax for branch creation. git checkout -B <new_branch> [<start_point>] git switch -C <new-branch> [<start-point>] Both commands are used to forcibly create and switch to a new branch. The new command git switch -C offers a clearer syntax for this task. git checkout --orphan <new_branch> git switch --orphan <new-branch> Both commands are used to create a new orphan branch. git checkout --orphan <new_branch> <start_point> N/A (use git switch <start-point> then git switch --orphan <new-branch> ) There is no direct equivalent for this operation. You can achieve similar behavior by first switching to the start point and then creating the orphan branch. git checkout [--detach] <commit> git switch --detach <commit> Both commands are used to checkout a specific commit in a detached HEAD state. git checkout --detach [<branch>] git switch --detach [<branch>] Both commands are used to detach the HEAD from the current or specified branch. git checkout [--] <pathspec>\u2026 git restore [--] <pathspec>\u2026 Both commands are used to restore files in the working directory. The new command git restore provides a clearer syntax for this operation. git checkout --pathspec-from-file=<file> git restore --pathspec-from-file=<file> Both commands are used to restore files specified in a file. The new command git restore provides a clearer syntax for this operation. git checkout <tree-ish> [--] <pathspec>\u2026 git restore -s <tree> [--] <pathspec>\u2026 Both commands are used to restore files from a specific tree. The new command git restore provides a clearer syntax for this operation. git checkout <tree-ish> --pathspec-from-file=<file> git restore -s <tree> --pathspec-from-file=<file> Both commands are used to restore files specified in a file from a specific tree. The new command git restore provides a clearer syntax for this operation. git checkout -p [<tree-ish>] [--] [<pathspec>\u2026] git restore -p [-s <tree>] [--] [<pathspec>\u2026] Both commands are used to interactively restore changes from a specific tree. The new command git restore provides a clearer syntax for this operation. As shown by this comparison, some prior usages can be converted to the new commands by simply replacing the old command name (checkout) with the new one (switch, restore), whereas others require additional adjustment. Notable changes include: The -b/-B options for creating a new branch before switching are renamed to -c/-C. They also have long option variants (--create/--force-create), unlike before. --detach (or -d) is now always required when switching to a detached head, where it was previously optional for commits but required for branches. The source tree for restoring is now given by the -s (or --source) option, rather than being an inline argument. Switching using --force (or -f) now fails if there are unmerged entries, rather than ignoring them. --force has also been renamed to --discard-changes, with --force being kept as an alias.","title":"Comparison with Newer Commands"},{"location":"Advanced/git_checkout/#git-switch","text":"Provides a clearer and more intuitive syntax specifically for switching branches.","title":"git switch"},{"location":"Advanced/git_checkout/#git-restore","text":"Offers dedicated options for restoring files and discarding changes, providing a more explicit and versatile interface for these operations.","title":"git restore"},{"location":"Advanced/git_checkout/#use-cases","text":"Simple Branch Switching For basic branch switching operations, git checkout remains a straightforward and commonly used command. File-Level Operations When performing file-level operations like restoring files from commits or discarding local changes, git checkout provides a concise syntax. Advanced Branch Management For more advanced branch management tasks or when using newer Git features, git switch and git restore may offer advantages in terms of clarity and functionality. git checkout is a versatile Git command with various features for branch switching, file restoration, and more. While newer commands like git switch and git restore offer some improvements and specialized functionality, git checkout remains a fundamental and widely used command in Git workflows. Depending on the specific task at hand and personal preference, you may choose to use git checkout or explore the capabilities of newer Git commands for branch and file management.","title":"Use Cases"},{"location":"Advanced/git_cherry/","text":"git cherry-pick is a powerful Git command used to apply individual commits from one branch to another. It allows you to select specific commits and apply them to the current branch, effectively incorporating changes from one branch into another. Syntax git cherry-pick <commit> <commit> : The commit hash or reference of the commit you want to cherry-pick. Options -e or --edit : Allows you to edit the commit message before committing the cherry-picked commit. -n or --no-commit : Applies the changes from the commit but does not create a new commit automatically. Useful for cherry-picking multiple commits together. -x or --signoff : Adds a \"Signed-off-by\" line to the commit message, indicating authorship. -m parent-number or --mainline parent-number : Specifies the parent number when cherry-picking a merge commit. Default is 1 (first parent). -s or --strategy <strategy> : Specifies the merge strategy to use when resolving conflicts. Options include recursive (default), resolve , ours , theirs , etc. Examples 1. Cherry-picking a Single Commit git cherry-pick abc123 This command applies the changes from the commit with the hash abc123 to the current branch. 2. Cherry-picking a Range of Commits git cherry-pick abc123..def456 This command applies the changes from all commits in the range abc123 to def456 to the current branch. 3. Cherry-picking with Edit git cherry-pick -e abc123 This command applies the changes from the commit abc123 to the current branch and allows you to edit the commit message before committing. 4. Cherry-picking without Committing git cherry-pick -n abc123 This command applies the changes from the commit abc123 to the current branch but does not create a new commit automatically. You can then manually commit the changes using git commit . 5. Cherry-picking with Merge Strategy git cherry-pick -s -X theirs abc123 This command applies the changes from the commit abc123 to the current branch and resolves conflicts by favoring the changes from the cherry-picked commit ( theirs strategy). Use Cases Porting Fixes: Cherry-pick commits containing bug fixes or feature enhancements from one branch to another, such as from a development branch to a stable release branch. Reverting Changes: Use cherry-pick to revert specific changes made in one branch from another branch without reverting the entire commit. Selectively Applying Changes: Apply only certain changes from a commit instead of the entire commit by using git cherry-pick -n followed by manual modifications. git cherry-pick is a versatile command that allows you to apply specific commits from one branch to another. By understanding its options and usage examples, you can effectively incorporate changes from one branch into another, facilitating collaboration and code management in your Git workflow.","title":"CherryPicking"},{"location":"Advanced/git_cherry/#syntax","text":"git cherry-pick <commit> <commit> : The commit hash or reference of the commit you want to cherry-pick.","title":"Syntax"},{"location":"Advanced/git_cherry/#options","text":"-e or --edit : Allows you to edit the commit message before committing the cherry-picked commit. -n or --no-commit : Applies the changes from the commit but does not create a new commit automatically. Useful for cherry-picking multiple commits together. -x or --signoff : Adds a \"Signed-off-by\" line to the commit message, indicating authorship. -m parent-number or --mainline parent-number : Specifies the parent number when cherry-picking a merge commit. Default is 1 (first parent). -s or --strategy <strategy> : Specifies the merge strategy to use when resolving conflicts. Options include recursive (default), resolve , ours , theirs , etc.","title":"Options"},{"location":"Advanced/git_cherry/#examples","text":"","title":"Examples"},{"location":"Advanced/git_cherry/#1-cherry-picking-a-single-commit","text":"git cherry-pick abc123 This command applies the changes from the commit with the hash abc123 to the current branch.","title":"1. Cherry-picking a Single Commit"},{"location":"Advanced/git_cherry/#2-cherry-picking-a-range-of-commits","text":"git cherry-pick abc123..def456 This command applies the changes from all commits in the range abc123 to def456 to the current branch.","title":"2. Cherry-picking a Range of Commits"},{"location":"Advanced/git_cherry/#3-cherry-picking-with-edit","text":"git cherry-pick -e abc123 This command applies the changes from the commit abc123 to the current branch and allows you to edit the commit message before committing.","title":"3. Cherry-picking with Edit"},{"location":"Advanced/git_cherry/#4-cherry-picking-without-committing","text":"git cherry-pick -n abc123 This command applies the changes from the commit abc123 to the current branch but does not create a new commit automatically. You can then manually commit the changes using git commit .","title":"4. Cherry-picking without Committing"},{"location":"Advanced/git_cherry/#5-cherry-picking-with-merge-strategy","text":"git cherry-pick -s -X theirs abc123 This command applies the changes from the commit abc123 to the current branch and resolves conflicts by favoring the changes from the cherry-picked commit ( theirs strategy).","title":"5. Cherry-picking with Merge Strategy"},{"location":"Advanced/git_cherry/#use-cases","text":"Porting Fixes: Cherry-pick commits containing bug fixes or feature enhancements from one branch to another, such as from a development branch to a stable release branch. Reverting Changes: Use cherry-pick to revert specific changes made in one branch from another branch without reverting the entire commit. Selectively Applying Changes: Apply only certain changes from a commit instead of the entire commit by using git cherry-pick -n followed by manual modifications. git cherry-pick is a versatile command that allows you to apply specific commits from one branch to another. By understanding its options and usage examples, you can effectively incorporate changes from one branch into another, facilitating collaboration and code management in your Git workflow.","title":"Use Cases"},{"location":"Advanced/git_ignore/","text":"In Git, you can ignore files using patterns by creating or modifying a special file called .gitignore . This file contains a list of file patterns that Git should ignore when tracking changes in your repository. Creating or Modifying .gitignore Specify files or directories that Git should ignore. The .gitignore file should be located at the root of your Git repository. Common File Patterns Wildcard ( * ): Matches zero or more characters. Directory ( / ): Denotes a directory. Negation ( ! ): Excludes files or directories that match the pattern. The rules for the patterns you can put in the .gitignore file are as follows: Blank lines or lines starting with # are ignored. Standard glob patterns work, and will be applied recursively throughout the entire working tree. You can start patterns with a forward slash (/) to avoid recursivity. You can end patterns with a forward slash (/) to specify a directory. You can negate a pattern by starting it with an exclamation point (!). Glob patterns are like simplified regular expressions that shells use. An asterisk ( ) matches zero or more characters; [abc] matches any character inside the brackets (in this case a, b, or c); a question mark (?) matches a single character; and brackets enclosing characters separated by a hyphen ([0-9]) matches any character between them (in this case 0 through 9). You can also use two asterisks to match nested directories; a/ */z would match a/z, a/b/z, a/b/c/z, and so on. a. Ignore Specific Files # Ignore log files *.log # Ignore build artifacts /build/ b. Ignore Files in a Directory # Ignore all files in the temp directory temp/* # But track one specific file in temp !temp/important.txt c. Ignore Files with a Specific Extension # Ignore all .pdf files *.pdf d. Ignore Files in Subdirectories # Ignore all .class files in any directory **/*.class e. More examples # ignore all .a files *.a # but do track lib.a, even though you're ignoring .a files above !lib.a # only ignore the TODO file in the current directory, not subdir/TODO /TODO # ignore all files in any directory named build build/ # ignore doc/notes.txt, but not doc/server/arch.txt doc/*.txt # ignore all .pdf files in the doc/ directory and any of its subdirectories doc/**/*.pdf More examples from GitHub . Applying .gitignore Changes After modifying the .gitignore file, you need to commit the changes to apply them to the repository. git add .gitignore git commit -m \"Add .gitignore to ignore specific files\" Global .gitignore You can create a global .gitignore file that applies to all repositories on your system by configuring Git to use it. The command git config --global core.excludesfile [file] is used to specify a system-wide ignore pattern file that Git will use for all local repositories on your system. git config --global core.excludesfile [ file ] Parameters: --global : This option specifies that the configuration should be applied globally, affecting all Git repositories on your system. core.excludesfile : This is the Git configuration key for specifying the location of the system-wide ignore file. [file] : This parameter specifies the path to the file containing the ignore patterns. git config --global core.excludesfile ~/.gitignore_global This command tells Git to use the specified file ( ~/.gitignore_global in this example) as the system-wide ignore pattern file. Any patterns defined in this file will be applied to all local repositories on your system, regardless of their location. Ignoring Changes in Tracked Files If you want to ignore changes in files that are already being tracked by Git, you can use the git update-index --assume-unchanged command. The git update-index --assume-unchanged command is used to tell Git to temporarily ignore changes to a tracked file. When you run this command, Git updates its index to mark the specified file ( config.ini in this example) as \"assume unchanged\". The --assume-unchanged option allows you to tell Git to treat a file as if it hasn't been changed, even if it has been modified since the last commit. git update-index --assume-unchanged <file> <file> : The path to the file you want to mark as unchanged. git update-index --assume-unchanged config.ini When you run this command, Git updates its index to mark the specified file ( config.ini in this example) as \"assume unchanged\". After marking a file as \"assume unchanged\", Git will not track changes to that file in future commits, treating it as if it hasn't been modified. This command is useful when you have local changes to a tracked file that you don't want to commit or stage for commit, such as configuration files with local settings that should not be shared with others. Use Cases Ignoring Local Changes: You can use this command to prevent accidentally committing local changes to certain files, such as configuration files with sensitive information or local overrides. Performance Optimization: By marking files as \"assume unchanged\", Git can improve performance by not having to check these files for changes when performing various operations, such as git status or git add . Caveats Manual Updates: It's important to note that this command only affects how Git treats the file in future operations. If the file is modified again in the future and you want to commit those changes, you will need to remove the \"assume unchanged\" status using git update-index --no-assume-unchanged <file> . Note This command only affects your local repository and does not affect the repository's history or other collaborators. Using git update-index --assume-unchanged can be a helpful tool for managing local changes to tracked files in your Git repository, allowing you to prevent accidental commits of sensitive or local-specific changes. Ignoring files using patterns in Git is essential for preventing certain files or directories from being tracked in your repository. By creating or modifying the .gitignore file and specifying file patterns, you can effectively manage which files Git should ignore. Understanding the common file patterns and how to apply them allows you to tailor Git's behavior to suit your project's needs while keeping the repository clean and manageable.","title":"Ignoring Files"},{"location":"Advanced/git_ignore/#creating-or-modifying-gitignore","text":"Specify files or directories that Git should ignore. The .gitignore file should be located at the root of your Git repository.","title":"Creating or Modifying .gitignore"},{"location":"Advanced/git_ignore/#common-file-patterns","text":"Wildcard ( * ): Matches zero or more characters. Directory ( / ): Denotes a directory. Negation ( ! ): Excludes files or directories that match the pattern. The rules for the patterns you can put in the .gitignore file are as follows: Blank lines or lines starting with # are ignored. Standard glob patterns work, and will be applied recursively throughout the entire working tree. You can start patterns with a forward slash (/) to avoid recursivity. You can end patterns with a forward slash (/) to specify a directory. You can negate a pattern by starting it with an exclamation point (!). Glob patterns are like simplified regular expressions that shells use. An asterisk ( ) matches zero or more characters; [abc] matches any character inside the brackets (in this case a, b, or c); a question mark (?) matches a single character; and brackets enclosing characters separated by a hyphen ([0-9]) matches any character between them (in this case 0 through 9). You can also use two asterisks to match nested directories; a/ */z would match a/z, a/b/z, a/b/c/z, and so on.","title":"Common File Patterns"},{"location":"Advanced/git_ignore/#a-ignore-specific-files","text":"# Ignore log files *.log # Ignore build artifacts /build/","title":"a. Ignore Specific Files"},{"location":"Advanced/git_ignore/#b-ignore-files-in-a-directory","text":"# Ignore all files in the temp directory temp/* # But track one specific file in temp !temp/important.txt","title":"b. Ignore Files in a Directory"},{"location":"Advanced/git_ignore/#c-ignore-files-with-a-specific-extension","text":"# Ignore all .pdf files *.pdf","title":"c. Ignore Files with a Specific Extension"},{"location":"Advanced/git_ignore/#d-ignore-files-in-subdirectories","text":"# Ignore all .class files in any directory **/*.class","title":"d. Ignore Files in Subdirectories"},{"location":"Advanced/git_ignore/#e-more-examples","text":"# ignore all .a files *.a # but do track lib.a, even though you're ignoring .a files above !lib.a # only ignore the TODO file in the current directory, not subdir/TODO /TODO # ignore all files in any directory named build build/ # ignore doc/notes.txt, but not doc/server/arch.txt doc/*.txt # ignore all .pdf files in the doc/ directory and any of its subdirectories doc/**/*.pdf More examples from GitHub .","title":"e. More examples"},{"location":"Advanced/git_ignore/#applying-gitignore-changes","text":"After modifying the .gitignore file, you need to commit the changes to apply them to the repository. git add .gitignore git commit -m \"Add .gitignore to ignore specific files\"","title":"Applying .gitignore Changes"},{"location":"Advanced/git_ignore/#global-gitignore","text":"You can create a global .gitignore file that applies to all repositories on your system by configuring Git to use it. The command git config --global core.excludesfile [file] is used to specify a system-wide ignore pattern file that Git will use for all local repositories on your system. git config --global core.excludesfile [ file ] Parameters: --global : This option specifies that the configuration should be applied globally, affecting all Git repositories on your system. core.excludesfile : This is the Git configuration key for specifying the location of the system-wide ignore file. [file] : This parameter specifies the path to the file containing the ignore patterns. git config --global core.excludesfile ~/.gitignore_global This command tells Git to use the specified file ( ~/.gitignore_global in this example) as the system-wide ignore pattern file. Any patterns defined in this file will be applied to all local repositories on your system, regardless of their location.","title":"Global .gitignore"},{"location":"Advanced/git_ignore/#ignoring-changes-in-tracked-files","text":"If you want to ignore changes in files that are already being tracked by Git, you can use the git update-index --assume-unchanged command. The git update-index --assume-unchanged command is used to tell Git to temporarily ignore changes to a tracked file. When you run this command, Git updates its index to mark the specified file ( config.ini in this example) as \"assume unchanged\". The --assume-unchanged option allows you to tell Git to treat a file as if it hasn't been changed, even if it has been modified since the last commit. git update-index --assume-unchanged <file> <file> : The path to the file you want to mark as unchanged. git update-index --assume-unchanged config.ini When you run this command, Git updates its index to mark the specified file ( config.ini in this example) as \"assume unchanged\". After marking a file as \"assume unchanged\", Git will not track changes to that file in future commits, treating it as if it hasn't been modified. This command is useful when you have local changes to a tracked file that you don't want to commit or stage for commit, such as configuration files with local settings that should not be shared with others.","title":"Ignoring Changes in Tracked Files"},{"location":"Advanced/git_interactivestaging/","text":"Interactive staging , also known as interactive mode or interactive patching, is a feature in Git that allows you to selectively stage changes from your working directory for a commit, offering more control over the staging process. It's particularly useful when you have made several changes in a single file or across multiple files and want to stage them selectively instead of committing all changes at once. Start Interactive Staging To start interactive staging, use the git add -i or git add --interactive command followed by the name of the file or directory you want to stage changes from. git add -i myfile.txt staged unstaged path 1: unchanged +0/-1 TODO 2: unchanged +1/-1 index.html 3: unchanged +5/-1 lib/simplegit.rb *** Commands *** 1: [s]tatus 2: [u]pdate 3: [r]evert 4: [a]dd untracked 5: [p]atch 6: [d]iff 7: [q]uit 8: [h]elp What now> Showing the same information you get with git status but a bit more succinct and informative. It lists the changes you\u2019ve staged on the left and unstaged changes on the right. After this comes a \u201cCommands\u201d section, which allows you to do a number of things like staging and unstaging files, staging parts of files, adding untracked files, and displaying diffs of what has been staged. Staging Modes Update Mode to Stage Changes If you type u or 2 (for update) at the What now> prompt, you\u2019re prompted for which files you want to stage: What now> u staged unstaged path 1: unchanged +0/-1 TODO 2: unchanged +1/-1 index.html 3: unchanged +5/-1 lib/simplegit.rb Update>> You can then select the files you want to stage by entering the numbers corresponding to the files. You can select multiple files by separating the numbers with spaces. Update>> 1,2 staged unstaged path * 1: unchanged +0/-1 TODO * 2: unchanged +1/-1 index.html 3: unchanged +5/-1 lib/simplegit.rb Update>> The * next to each file means the file is selected to be staged. If you press Enter after typing nothing at the Update>> prompt, Git takes anything selected and stages it for you: Update>> updated 2 paths *** Commands *** 1: [s]tatus 2: [u]pdate 3: [r]evert 4: [a]dd untracked 5: [p]atch 6: [d]iff 7: [q]uit 8: [h]elp What now> s staged unstaged path 1: +0/-1 nothing TODO 2: +1/-1 nothing index.html 3: unchanged +5/-1 lib/simplegit.rb Unstaging Changes with Revert Mode Now you can see that the TODO and index.html files are staged and the simplegit.rb file is still unstaged. If you want to unstage the TODO file at this point, you use the r or 3 (for revert) option: *** Commands *** 1: [s]tatus 2: [u]pdate 3: [r]evert 4: [a]dd untracked 5: [p]atch 6: [d]iff 7: [q]uit 8: [h]elp What now> r staged unstaged path 1: +0/-1 nothing TODO 2: +1/-1 nothing index.html 3: unchanged +5/-1 lib/simplegit.rb Revert>> 1 staged unstaged path * 1: +0/-1 nothing TODO 2: +1/-1 nothing index.html 3: unchanged +5/-1 lib/simplegit.rb Revert>> [enter] reverted one path Status Mode Looking at your Git status again, you can see that you\u2019ve unstaged the TODO file: *** Commands *** 1: [s]tatus 2: [u]pdate 3: [r]evert 4: [a]dd untracked 5: [p]atch 6: [d]iff 7: [q]uit 8: [h]elp What now> s staged unstaged path 1: unchanged +0/-1 TODO 2: +1/-1 nothing index.html 3: unchanged +5/-1 lib/simplegit.rb Diff Changes To see the diff of what you\u2019ve staged, you can use the d or 6 (for diff) command. It shows you a list of your staged files, and you can select the ones for which you would like to see the staged diff. This is much like specifying git diff --cached on the command line: *** Commands *** 1: [s]tatus 2: [u]pdate 3: [r]evert 4: [a]dd untracked 5: [p]atch 6: [d]iff 7: [q]uit 8: [h]elp What now> d staged unstaged path 1: +1/-1 nothing index.html Review diff>> 1 diff --git a/index.html b/index.html index 4d07108..4335f49 100644 --- a/index.html +++ b/index.html @@ -16,7 +16,7 @@ Date Finder <p id=\"out\">...</p> -<div id=\"footer\">contact : support@github.com</div> +<div id=\"footer\">contact : email.support@github.com</div> <script type=\"text/javascript\"> Staging Patches In this mode, Git displays changes within each file and allows you to interactively stage them. It\u2019s also possible for Git to stage certain parts of files and not the rest. For example, if you make two changes to your simplegit.rb file and want to stage one of them and not the other, doing so is very easy in Git. To do so, you can type p or 5 (for patch). Git will ask you which files you would like to partially stage; then, for each section of the selected files, it will display hunks of the file diff and ask if you would like to stage them, one by one: diff --git a/lib/simplegit.rb b/lib/simplegit.rb index dd5ecc4..57399e0 100644 --- a/lib/simplegit.rb +++ b/lib/simplegit.rb @@ -22,7 +22,7 @@ class SimpleGit end def log(treeish = 'master') - command(\"git log -n 25 #{treeish}\") + command(\"git log -n 30 #{treeish}\") end def blame(path) Stage this hunk [y,n,a,d,/,j,J,g,e,?]? You have a lot of options at this point. Typing ? shows a list of what you can do: Stage this hunk [y,n,a,d,/,j,J,g,e,?]? ? y - stage this hunk n - do not stage this hunk a - stage this and all the remaining hunks in the file d - do not stage this hunk nor any of the remaining hunks in the file g - select a hunk to go to / - search for a hunk matching the given regex j - leave this hunk undecided, see next undecided hunk J - leave this hunk undecided, see next hunk k - leave this hunk undecided, see previous undecided hunk K - leave this hunk undecided, see previous hunk s - split the current hunk into smaller hunks e - manually edit the current hunk ? - print help Generally, you\u2019ll type y or n if you want to stage each hunk, but staging all of them in certain files or skipping a hunk decision until later can be helpful too. If you stage one part of the file and leave another part unstaged, your status output will look like this: What now> 1 staged unstaged path 1: unchanged +0/-1 TODO 2: +1/-1 nothing index.html 3: +1/-1 +4/-0 lib/simplegit.rb It shows you that a couple of lines are staged and a couple are unstaged. You\u2019ve partially staged this file. At this point, you can exit the interactive adding script and run git commit to commit the partially staged files. The -p option or --patch will interactively choose hunks of patch between the index and the work tree and add them to the index. This gives the user a chance to review the difference before adding modified contents to the index. This effectively runs add --interactive, but bypasses the initial command menu and directly jumps to the patch subcommand. git add -p","title":"Interactive Staging"},{"location":"Advanced/git_interactivestaging/#start-interactive-staging","text":"To start interactive staging, use the git add -i or git add --interactive command followed by the name of the file or directory you want to stage changes from. git add -i myfile.txt staged unstaged path 1: unchanged +0/-1 TODO 2: unchanged +1/-1 index.html 3: unchanged +5/-1 lib/simplegit.rb *** Commands *** 1: [s]tatus 2: [u]pdate 3: [r]evert 4: [a]dd untracked 5: [p]atch 6: [d]iff 7: [q]uit 8: [h]elp What now> Showing the same information you get with git status but a bit more succinct and informative. It lists the changes you\u2019ve staged on the left and unstaged changes on the right. After this comes a \u201cCommands\u201d section, which allows you to do a number of things like staging and unstaging files, staging parts of files, adding untracked files, and displaying diffs of what has been staged.","title":"Start Interactive Staging"},{"location":"Advanced/git_interactivestaging/#staging-modes","text":"","title":"Staging Modes"},{"location":"Advanced/git_interactivestaging/#update-mode-to-stage-changes","text":"If you type u or 2 (for update) at the What now> prompt, you\u2019re prompted for which files you want to stage: What now> u staged unstaged path 1: unchanged +0/-1 TODO 2: unchanged +1/-1 index.html 3: unchanged +5/-1 lib/simplegit.rb Update>> You can then select the files you want to stage by entering the numbers corresponding to the files. You can select multiple files by separating the numbers with spaces. Update>> 1,2 staged unstaged path * 1: unchanged +0/-1 TODO * 2: unchanged +1/-1 index.html 3: unchanged +5/-1 lib/simplegit.rb Update>> The * next to each file means the file is selected to be staged. If you press Enter after typing nothing at the Update>> prompt, Git takes anything selected and stages it for you: Update>> updated 2 paths *** Commands *** 1: [s]tatus 2: [u]pdate 3: [r]evert 4: [a]dd untracked 5: [p]atch 6: [d]iff 7: [q]uit 8: [h]elp What now> s staged unstaged path 1: +0/-1 nothing TODO 2: +1/-1 nothing index.html 3: unchanged +5/-1 lib/simplegit.rb","title":"Update Mode to Stage Changes"},{"location":"Advanced/git_interactivestaging/#unstaging-changes-with-revert-mode","text":"Now you can see that the TODO and index.html files are staged and the simplegit.rb file is still unstaged. If you want to unstage the TODO file at this point, you use the r or 3 (for revert) option: *** Commands *** 1: [s]tatus 2: [u]pdate 3: [r]evert 4: [a]dd untracked 5: [p]atch 6: [d]iff 7: [q]uit 8: [h]elp What now> r staged unstaged path 1: +0/-1 nothing TODO 2: +1/-1 nothing index.html 3: unchanged +5/-1 lib/simplegit.rb Revert>> 1 staged unstaged path * 1: +0/-1 nothing TODO 2: +1/-1 nothing index.html 3: unchanged +5/-1 lib/simplegit.rb Revert>> [enter] reverted one path","title":"Unstaging Changes with Revert Mode"},{"location":"Advanced/git_interactivestaging/#status-mode","text":"Looking at your Git status again, you can see that you\u2019ve unstaged the TODO file: *** Commands *** 1: [s]tatus 2: [u]pdate 3: [r]evert 4: [a]dd untracked 5: [p]atch 6: [d]iff 7: [q]uit 8: [h]elp What now> s staged unstaged path 1: unchanged +0/-1 TODO 2: +1/-1 nothing index.html 3: unchanged +5/-1 lib/simplegit.rb","title":"Status Mode"},{"location":"Advanced/git_interactivestaging/#diff-changes","text":"To see the diff of what you\u2019ve staged, you can use the d or 6 (for diff) command. It shows you a list of your staged files, and you can select the ones for which you would like to see the staged diff. This is much like specifying git diff --cached on the command line: *** Commands *** 1: [s]tatus 2: [u]pdate 3: [r]evert 4: [a]dd untracked 5: [p]atch 6: [d]iff 7: [q]uit 8: [h]elp What now> d staged unstaged path 1: +1/-1 nothing index.html Review diff>> 1 diff --git a/index.html b/index.html index 4d07108..4335f49 100644 --- a/index.html +++ b/index.html @@ -16,7 +16,7 @@ Date Finder <p id=\"out\">...</p> -<div id=\"footer\">contact : support@github.com</div> +<div id=\"footer\">contact : email.support@github.com</div> <script type=\"text/javascript\">","title":"Diff Changes"},{"location":"Advanced/git_interactivestaging/#staging-patches","text":"In this mode, Git displays changes within each file and allows you to interactively stage them. It\u2019s also possible for Git to stage certain parts of files and not the rest. For example, if you make two changes to your simplegit.rb file and want to stage one of them and not the other, doing so is very easy in Git. To do so, you can type p or 5 (for patch). Git will ask you which files you would like to partially stage; then, for each section of the selected files, it will display hunks of the file diff and ask if you would like to stage them, one by one: diff --git a/lib/simplegit.rb b/lib/simplegit.rb index dd5ecc4..57399e0 100644 --- a/lib/simplegit.rb +++ b/lib/simplegit.rb @@ -22,7 +22,7 @@ class SimpleGit end def log(treeish = 'master') - command(\"git log -n 25 #{treeish}\") + command(\"git log -n 30 #{treeish}\") end def blame(path) Stage this hunk [y,n,a,d,/,j,J,g,e,?]? You have a lot of options at this point. Typing ? shows a list of what you can do: Stage this hunk [y,n,a,d,/,j,J,g,e,?]? ? y - stage this hunk n - do not stage this hunk a - stage this and all the remaining hunks in the file d - do not stage this hunk nor any of the remaining hunks in the file g - select a hunk to go to / - search for a hunk matching the given regex j - leave this hunk undecided, see next undecided hunk J - leave this hunk undecided, see next hunk k - leave this hunk undecided, see previous undecided hunk K - leave this hunk undecided, see previous hunk s - split the current hunk into smaller hunks e - manually edit the current hunk ? - print help Generally, you\u2019ll type y or n if you want to stage each hunk, but staging all of them in certain files or skipping a hunk decision until later can be helpful too. If you stage one part of the file and leave another part unstaged, your status output will look like this: What now> 1 staged unstaged path 1: unchanged +0/-1 TODO 2: +1/-1 nothing index.html 3: +1/-1 +4/-0 lib/simplegit.rb It shows you that a couple of lines are staged and a couple are unstaged. You\u2019ve partially staged this file. At this point, you can exit the interactive adding script and run git commit to commit the partially staged files. The -p option or --patch will interactively choose hunks of patch between the index and the work tree and add them to the index. This gives the user a chance to review the difference before adding modified contents to the index. This effectively runs add --interactive, but bypasses the initial command menu and directly jumps to the patch subcommand. git add -p","title":"Staging Patches"},{"location":"Advanced/git_patches/","text":"Creating patches in Git involves generating files that represent the changes introduced by one or more commits. These patches can then be shared with others or applied to different repositories. Using git format-patch The git format-patch command generates patch files for one or more commits, formatting them in the \"mbox\" format by default. git format-patch <start-commit>..<end-commit> git format-patch HEAD~3..HEAD - This command generates patch files for the last three commits from the current HEAD commit. Creating Patches for Specific Commits You can specify individual commits to create patches for by providing their commit hashes. git format-patch <commit-hash> git format-patch abc123 - This command generates a patch file for the commit with the hash abc123 . Specifying Output Directory You can specify the output directory for the generated patch files using the -o or --output-directory option. git format-patch -o <output-directory> <start-commit>..<end-commit> git format-patch -o patches/ HEAD~3..HEAD This command generates patch files for the last three commits and saves them in the patches/ directory. Including Commit Message in Patch You can include the commit message as part of the patch file by using the --stdout option. git format-patch --stdout <commit-hash> git format-patch --stdout abc123 > patch_file.patch This command generates a patch file for the commit with the hash abc123 and includes the commit message in the output. Generating Patch for Unpushed Commits To create patches for unpushed commits, you can specify the branch name along with the git format-patch command. git format-patch origin/<branch-name> git format-patch origin/main This command generates patch files for the commits that are present in the local branch but not in the remote main branch. Inspecting and Applying Patch Files Once the patch files are generated, you can inspect them using any text editor or view the changes using the git apply --stat command. git apply --stat <patch-file> This command displays statistics about the changes introduced by the patch file. The command git apply patchtext.patch is used to apply a patch file to the current working directory. git apply <patch-file> git apply : This Git command is used to apply a patch file to the current working directory. patchtext.patch : This is the name of the patch file you want to apply. The patch file contains the changes that you want to apply to your repository. How It Works Ensure Correct Context: The patch file must be generated in a compatible format with the changes relative to the repository's current state. Navigate to Repository: First, navigate to the directory of the Git repository where you want to apply the changes. Checkout Target Branch/Commit: Ensure that you are on the correct branch or commit where you want the changes to be applied. This step ensures that the changes are applied to the correct codebase. Run git apply : Execute the git apply command followed by the name of the patch file you want to apply. Review Changes: After applying the patch, review the changes to ensure they were applied correctly. You can use git diff to inspect the differences before and after applying the patch. Stage and Commit (if necessary): If the changes are satisfactory, stage and commit them to finalize the application of the patch. Considerations Patch Compatibility: Ensure that the patch file is compatible with the version of the codebase you are applying it to. Mismatches in context or format can lead to errors or unintended consequences. Review Changes: Always review the changes introduced by the patch to verify correctness and avoid introducing bugs or conflicts. Backup: Consider creating a backup or working on a separate branch before applying patches, especially if the changes are significant or experimental. Using git apply provides a straightforward way to apply patches to a Git repository, allowing you to integrate changes from external sources or collaborators efficiently. Sharing Patch Files You can share the generated patch files with others through email, file sharing services, or version control systems. Generating patches in Git using git format-patch provides a convenient way to share changes between repositories or with collaborators. By following these steps and examples, you can create patch files for specific commits or ranges of commits and distribute them efficiently. git diff vs git format-patch for creating patches Both git diff and git format-patch can be used to create patches, but they are designed for different use cases. Here's a comparison: git diff git diff is used to show the differences between two commits, branches, or the working directory and a commit. It generates a raw diff output that can be used to apply changes with git apply . Pros: Simplicity: Easy to use for quick comparisons or creating simple patch files. Flexible: Can be used to compare uncommitted changes or staged changes. Compatible with non-Git workflows: The output can be applied as a patch outside of Git using standard tools like patch . Cons: No commit metadata: Does not include author information, commit messages, or timestamps. Limited scope: Cannot represent multiple commits or complex histories in one patch file. Manual tracking: You need to manually ensure the context of the patch (e.g., base commit). Example Usage: Create a patch between two branches: git diff branch1 branch2 > my_changes.patch Apply the patch: git apply my_changes.patch Check the patch before applying: git apply --check my_changes.patch Reverse a patch: git apply -R my_changes.patch git format-patch git format-patch is designed to generate patches for one or more commits. It creates a file (or files) with commit metadata, making it ideal for sharing changes with collaborators or upstream projects. Pros: Includes commit metadata: Author, date, and commit message are preserved. Supports multiple commits: Can generate patches for a range of commits, each in its own file. Integrates with email workflows: Works seamlessly with git send-email for sending patches via email. Clear history: Retains the context of commits when applied with git am . Cons: More complex: Not as straightforward as git diff for quick patch creation. Git-specific: The output is more tailored for Git workflows and may not be as portable for non-Git systems. Separate files: Creates one file per commit unless explicitly concatenated. Example Usage: Create a patch for the last commit: git format-patch -1 Create patches for all commits between two branches: git format-patch branch1..branch2 Apply patches: git am *.patch Send patches via email: git send-email *.patch Generate a single patch file for multiple commits: git format-patch branch1..branch2 --stdout > changes.patch Comparison of Use Cases Feature git diff git format-patch Metadata Not included Includes author, date, and commit message Multi-commit patches Not supported Supported Email integration No Yes Portability Works with or without Git Primarily designed for Git workflows Complex histories Not well-suited Handles complex histories with multiple commits Detailed Workflow Example Scenario: Applying changes from feature to main Using git diff : # Create the patch git diff main..feature > feature_to_main.patch # Transfer the patch (optional) scp feature_to_main.patch user@remote:/path/to/project # Apply the patch git apply feature_to_main.patch # Stage the applied changes git add . # Commit the changes git commit -m \"Applied patch from feature branch\" Using git format-patch : # Create patches for all commits in feature branch git format-patch main..feature # Transfer the patches (optional) scp *.patch user@remote:/path/to/project # Apply the patches with commit metadata git am *.patch Conclusion Use git diff for simpler use cases, especially when you don\u2019t need commit metadata or are working outside of Git. Use git format-patch when sharing changes with collaborators, contributing to upstream projects, or preserving commit history and metadata. But if two branches have different code but no distinct commits (e.g., the code changes were made directly to the working tree without committing), you can still use git format-patch in a specific way to capture those changes. This approach mimics the functionality of git diff , while packaging the changes into a patch file that includes metadata. Using git format-patch Without Different Commits When there are no distinct commits but you want to create a patch using git format-patch , the steps involve: Staging the changes (if they aren\u2019t staged yet). Committing the changes to create a temporary commit. Generating the patch using git format-patch . (Optional) Cleaning up the temporary commit after generating the patch. Example Workflow Scenario: Two branches ( main and feature ) have diverged in code but not in commits. Switch to the branch with the changes: git checkout feature Stage all changes: If the differences are uncommitted, first stage them: git add . Create a temporary commit: Commit the staged changes with a temporary message: git commit -m \"Temporary commit for patch generation\" Generate a patch with git format-patch : Create a patch that captures the differences between the branches: git format-patch main --stdout > feature_to_main.patch The --stdout flag outputs the patch as a single file. The patch includes metadata like the commit author, timestamp, and message. Apply the patch on the target branch: Switch to the target branch ( main ) and apply the patch: git checkout main git am feature_to_main.patch Using git am ensures the patch is applied with all the original metadata. (Optional) Clean up the temporary commit: Return to the branch where you created the temporary commit ( feature ) and reset it to discard the temporary commit: git reset HEAD~1 This removes the temporary commit but leaves the changes intact in the working directory. Advantages of This Workflow Metadata preservation: Unlike git diff , this approach includes author information, timestamps, and a commit message. Direct integration with Git workflows: The patch can be applied using git am , maintaining Git history. Flexibility: You can revert or reapply the patch later if needed. Comparison with git diff If you were using git diff for this scenario, you would directly generate the patch without creating a temporary commit: git diff main..feature > feature_to_main.patch git apply feature_to_main.patch This approach skips commit metadata but works well for quick or simple workflows. When to Use Each Use git diff when you need a quick and straightforward patch for differences in code but don\u2019t care about commit metadata. Use git format-patch when you need a patch with commit metadata or intend to integrate the patch into a Git-based workflow (e.g., applying with git am ).","title":"Patching"},{"location":"Advanced/git_patches/#using-git-format-patch","text":"The git format-patch command generates patch files for one or more commits, formatting them in the \"mbox\" format by default. git format-patch <start-commit>..<end-commit> git format-patch HEAD~3..HEAD - This command generates patch files for the last three commits from the current HEAD commit.","title":"Using git format-patch"},{"location":"Advanced/git_patches/#creating-patches-for-specific-commits","text":"You can specify individual commits to create patches for by providing their commit hashes. git format-patch <commit-hash> git format-patch abc123 - This command generates a patch file for the commit with the hash abc123 .","title":"Creating Patches for Specific Commits"},{"location":"Advanced/git_patches/#specifying-output-directory","text":"You can specify the output directory for the generated patch files using the -o or --output-directory option. git format-patch -o <output-directory> <start-commit>..<end-commit> git format-patch -o patches/ HEAD~3..HEAD This command generates patch files for the last three commits and saves them in the patches/ directory.","title":"Specifying Output Directory"},{"location":"Advanced/git_patches/#including-commit-message-in-patch","text":"You can include the commit message as part of the patch file by using the --stdout option. git format-patch --stdout <commit-hash> git format-patch --stdout abc123 > patch_file.patch This command generates a patch file for the commit with the hash abc123 and includes the commit message in the output.","title":"Including Commit Message in Patch"},{"location":"Advanced/git_patches/#generating-patch-for-unpushed-commits","text":"To create patches for unpushed commits, you can specify the branch name along with the git format-patch command. git format-patch origin/<branch-name> git format-patch origin/main This command generates patch files for the commits that are present in the local branch but not in the remote main branch.","title":"Generating Patch for Unpushed Commits"},{"location":"Advanced/git_patches/#inspecting-and-applying-patch-files","text":"Once the patch files are generated, you can inspect them using any text editor or view the changes using the git apply --stat command. git apply --stat <patch-file> This command displays statistics about the changes introduced by the patch file. The command git apply patchtext.patch is used to apply a patch file to the current working directory. git apply <patch-file> git apply : This Git command is used to apply a patch file to the current working directory. patchtext.patch : This is the name of the patch file you want to apply. The patch file contains the changes that you want to apply to your repository.","title":"Inspecting and Applying Patch Files"},{"location":"Advanced/git_patches/#how-it-works","text":"Ensure Correct Context: The patch file must be generated in a compatible format with the changes relative to the repository's current state. Navigate to Repository: First, navigate to the directory of the Git repository where you want to apply the changes. Checkout Target Branch/Commit: Ensure that you are on the correct branch or commit where you want the changes to be applied. This step ensures that the changes are applied to the correct codebase. Run git apply : Execute the git apply command followed by the name of the patch file you want to apply. Review Changes: After applying the patch, review the changes to ensure they were applied correctly. You can use git diff to inspect the differences before and after applying the patch. Stage and Commit (if necessary): If the changes are satisfactory, stage and commit them to finalize the application of the patch.","title":"How It Works"},{"location":"Advanced/git_patches/#considerations","text":"Patch Compatibility: Ensure that the patch file is compatible with the version of the codebase you are applying it to. Mismatches in context or format can lead to errors or unintended consequences. Review Changes: Always review the changes introduced by the patch to verify correctness and avoid introducing bugs or conflicts. Backup: Consider creating a backup or working on a separate branch before applying patches, especially if the changes are significant or experimental. Using git apply provides a straightforward way to apply patches to a Git repository, allowing you to integrate changes from external sources or collaborators efficiently.","title":"Considerations"},{"location":"Advanced/git_patches/#sharing-patch-files","text":"You can share the generated patch files with others through email, file sharing services, or version control systems. Generating patches in Git using git format-patch provides a convenient way to share changes between repositories or with collaborators. By following these steps and examples, you can create patch files for specific commits or ranges of commits and distribute them efficiently.","title":"Sharing Patch Files"},{"location":"Advanced/git_patches/#git-diff-vs-git-format-patch-for-creating-patches","text":"Both git diff and git format-patch can be used to create patches, but they are designed for different use cases. Here's a comparison:","title":"git diff vs git format-patch for creating patches"},{"location":"Advanced/git_patches/#git-format-patch","text":"git format-patch is designed to generate patches for one or more commits. It creates a file (or files) with commit metadata, making it ideal for sharing changes with collaborators or upstream projects.","title":"git format-patch"},{"location":"Advanced/git_patches/#comparison-of-use-cases","text":"Feature git diff git format-patch Metadata Not included Includes author, date, and commit message Multi-commit patches Not supported Supported Email integration No Yes Portability Works with or without Git Primarily designed for Git workflows Complex histories Not well-suited Handles complex histories with multiple commits","title":"Comparison of Use Cases"},{"location":"Advanced/git_patches/#conclusion","text":"Use git diff for simpler use cases, especially when you don\u2019t need commit metadata or are working outside of Git. Use git format-patch when sharing changes with collaborators, contributing to upstream projects, or preserving commit history and metadata. But if two branches have different code but no distinct commits (e.g., the code changes were made directly to the working tree without committing), you can still use git format-patch in a specific way to capture those changes. This approach mimics the functionality of git diff , while packaging the changes into a patch file that includes metadata.","title":"Conclusion"},{"location":"Advanced/git_patches/#using-git-format-patch-without-different-commits","text":"When there are no distinct commits but you want to create a patch using git format-patch , the steps involve: Staging the changes (if they aren\u2019t staged yet). Committing the changes to create a temporary commit. Generating the patch using git format-patch . (Optional) Cleaning up the temporary commit after generating the patch.","title":"Using git format-patch Without Different Commits"},{"location":"Advanced/git_stash/","text":"In Git, temporary commits, also known as \"stashing,\" allow you to save your work temporarily without committing it to the repository. Stashing is useful when you need to switch to another task or branch but want to keep your current changes for later use. Stashing Changes git stash This command saves your current changes in a \"stash\" without committing them to the repository. Git removes the changes from the working directory and staging area, allowing you to switch branches or perform other operations. The git stash command can be used to save the changes you have made to the working directory. It can also be used to save the changes you have made to the staging area. Stashing is useful when you need to switch to another task or branch but want to keep your current changes for later use. --keep-index To save the changes in the staging area, use the --keep-index option to the git stash command. This tells Git to not only include all staged content in the stash being created, but simultaneously leave it in the index. --include-untracked If you specify --include-untracked or -u, Git will include the untracked files as well as the tracked ones. By default, git stash will stash only modified and staged tracked files. If you specify --include-untracked or -u, Git will include untracked files in the stash being created. However, including untracked files in the stash will still not include explicitly ignored files; to additionally include ignored files, use --all (or just -a). --patch If you specify the --patch flag, Git will not stash everything that is modified but will instead prompt you interactively which of the changes you would like to stash and which you would like to keep in your working directory. --all Use git stash --all to remove everything but save it in a stash. Listing Stashes git stash list This command lists all stashes you have saved. Each stash is identified by a unique identifier, typically a number. Applying Stashed Changes git stash apply [ <stash> ] git stash apply stash@ { 0 } This command applies the changes from the specified stash to the current working directory. If no stash is specified, Git applies the most recent stash by default. You can save a stash on one branch, switch to another branch later, and try to reapply the changes. You can also have modified and uncommitted files in your working directory when you apply a stash\u2009\u2014\u2009Git gives you merge conflicts if anything no longer applies cleanly. The --index option with git stash apply applies both the changes from the stash and the staged changes (changes that were added to the index) that were present when the changes were stashed. This option is particularly useful when you have staged changes that you also want to apply along with the unstaged changes from the stash. Popping Stashed Changes git stash pop [ <stash> ] git stash pop stash@ { 0 } This command applies the changes from the specified stash and removes it from the stash list. If no stash is specified, Git pops the most recent stash by default. Droping Stashed Changes The git stash drop command is used to remove stashed changes from the stash list. git stash drop [ <stash> ] git stash drop stash@ { 0 } This command removes the specified stash from the stash list. If no stash is specified, Git drops the most recent stash by default. Once dropped, the changes stored in the stash are permanently deleted and cannot be recovered. Clearing Stashes git stash clear This command removes all stashes from the stash list. Use with caution, as it permanently deletes all stashed changes. Creating a Branch from a Stash If you stash some work, leave it there for a while, and continue on the branch from which you stashed the work, you may have a problem reapplying the work. If the apply tries to modify a file that you\u2019ve since modified, you\u2019ll get a merge conflict and will have to try to resolve it. If you want an easier way to test the stashed changes again, you can run git stash branch , which creates a new branch for you with your selected branch name, checks out the commit you were on when you stashed your work, reapplies your work there, and then drops the stash if it applies successfully. $ git stash branch testchanges M index.html M lib/simplegit.rb Switched to a new branch 'testchanges' On branch testchanges Changes to be committed: ( use \"git reset HEAD <file>...\" to unstage ) modified: index.html Changes not staged for commit: ( use \"git add <file>...\" to update what will be committed ) ( use \"git checkout -- <file>...\" to discard changes in working directory ) modified: lib/simplegit.rb Dropped refs/stash@ { 0 } ( 29d385a81d163dfd45a452a2ce816487a6b8b014 ) This is a nice shortcut to recover stashed work easily and work on it in a new branch.","title":"Temporary Commits"},{"location":"Advanced/git_stash/#stashing-changes","text":"git stash This command saves your current changes in a \"stash\" without committing them to the repository. Git removes the changes from the working directory and staging area, allowing you to switch branches or perform other operations. The git stash command can be used to save the changes you have made to the working directory. It can also be used to save the changes you have made to the staging area. Stashing is useful when you need to switch to another task or branch but want to keep your current changes for later use.","title":"Stashing Changes"},{"location":"Advanced/git_stash/#-keep-index","text":"To save the changes in the staging area, use the --keep-index option to the git stash command. This tells Git to not only include all staged content in the stash being created, but simultaneously leave it in the index.","title":"--keep-index"},{"location":"Advanced/git_stash/#-include-untracked","text":"If you specify --include-untracked or -u, Git will include the untracked files as well as the tracked ones. By default, git stash will stash only modified and staged tracked files. If you specify --include-untracked or -u, Git will include untracked files in the stash being created. However, including untracked files in the stash will still not include explicitly ignored files; to additionally include ignored files, use --all (or just -a).","title":"--include-untracked"},{"location":"Advanced/git_stash/#-patch","text":"If you specify the --patch flag, Git will not stash everything that is modified but will instead prompt you interactively which of the changes you would like to stash and which you would like to keep in your working directory.","title":"--patch"},{"location":"Advanced/git_stash/#-all","text":"Use git stash --all to remove everything but save it in a stash.","title":"--all"},{"location":"Advanced/git_stash/#listing-stashes","text":"git stash list This command lists all stashes you have saved. Each stash is identified by a unique identifier, typically a number.","title":"Listing Stashes"},{"location":"Advanced/git_stash/#applying-stashed-changes","text":"git stash apply [ <stash> ] git stash apply stash@ { 0 } This command applies the changes from the specified stash to the current working directory. If no stash is specified, Git applies the most recent stash by default. You can save a stash on one branch, switch to another branch later, and try to reapply the changes. You can also have modified and uncommitted files in your working directory when you apply a stash\u2009\u2014\u2009Git gives you merge conflicts if anything no longer applies cleanly. The --index option with git stash apply applies both the changes from the stash and the staged changes (changes that were added to the index) that were present when the changes were stashed. This option is particularly useful when you have staged changes that you also want to apply along with the unstaged changes from the stash.","title":"Applying Stashed Changes"},{"location":"Advanced/git_stash/#popping-stashed-changes","text":"git stash pop [ <stash> ] git stash pop stash@ { 0 } This command applies the changes from the specified stash and removes it from the stash list. If no stash is specified, Git pops the most recent stash by default.","title":"Popping Stashed Changes"},{"location":"Advanced/git_stash/#droping-stashed-changes","text":"The git stash drop command is used to remove stashed changes from the stash list. git stash drop [ <stash> ] git stash drop stash@ { 0 } This command removes the specified stash from the stash list. If no stash is specified, Git drops the most recent stash by default. Once dropped, the changes stored in the stash are permanently deleted and cannot be recovered.","title":"Droping Stashed Changes"},{"location":"Advanced/git_stash/#clearing-stashes","text":"git stash clear This command removes all stashes from the stash list. Use with caution, as it permanently deletes all stashed changes.","title":"Clearing Stashes"},{"location":"Advanced/git_stash/#creating-a-branch-from-a-stash","text":"If you stash some work, leave it there for a while, and continue on the branch from which you stashed the work, you may have a problem reapplying the work. If the apply tries to modify a file that you\u2019ve since modified, you\u2019ll get a merge conflict and will have to try to resolve it. If you want an easier way to test the stashed changes again, you can run git stash branch , which creates a new branch for you with your selected branch name, checks out the commit you were on when you stashed your work, reapplies your work there, and then drops the stash if it applies successfully. $ git stash branch testchanges M index.html M lib/simplegit.rb Switched to a new branch 'testchanges' On branch testchanges Changes to be committed: ( use \"git reset HEAD <file>...\" to unstage ) modified: index.html Changes not staged for commit: ( use \"git add <file>...\" to update what will be committed ) ( use \"git checkout -- <file>...\" to discard changes in working directory ) modified: lib/simplegit.rb Dropped refs/stash@ { 0 } ( 29d385a81d163dfd45a452a2ce816487a6b8b014 ) This is a nice shortcut to recover stashed work easily and work on it in a new branch.","title":"Creating a Branch from a Stash"},{"location":"Advanced/git_submodules/","text":"Git submodules allow you to include and manage external repositories within your own repository. This is particularly useful when you want to incorporate third-party libraries or other dependencies while maintaining control over their specific versions. Adding a Submodule To add a submodule to your repository, use the git submodule add command. # Syntax git submodule add <repository-url> [ <path> ] # Example git submodule add https://github.com/example/library.git lib/library This command clones the submodule repository into the specified path and adds a reference to it in your .gitmodules file. By default, submodules will add the subproject into a directory named the same as the repository. You can add a different path at the end of the command if you want it to go elsewhere. You can also specify a branch to checkout with the -b flag. git submodule add -b master git@github.com:emeneo/moodle-enrol_apply.git enrol/apply The new .gitmodules file is a configuration file that stores the mapping between the project\u2019s URL and the local subdirectory you\u2019ve pulled it into. [ submodule \"enrol/apply\" ] path = enrol/apply url = git@github.com:emeneo/moodle-enrol_apply.git branch = master If you have multiple submodules, you\u2019ll have multiple entries in this file. It\u2019s important to note that this file is version-controlled with your other files, like your .gitignore file. It\u2019s pushed and pulled with the rest of your project. This is how other people who clone this project know where to get the submodule projects from. Initializing and Updating Submodules After cloning a repository that contains submodules, you need to initialize and update them. # Initialize submodules git submodule init # Update submodules git submodule update git submodule sync ; git submodule update --init --recursive The init command initializes the submodules recorded in the .gitmodules file, while the update command fetches and checks out the correct commit specified by the superproject. Cloning a Repository with Submodules When cloning a repository that includes submodules, use the --recurse-submodules flag to automatically initialize and update submodules. When you clone such a project, by default you get the directories that contain submodules, but none of the files within them yet. You must run two commands: git submodule init to initialize your local configuration file, and git submodule update to fetch all the data from that project and check out the appropriate commit listed in your superproject. If you pass --recurse-submodules to the git clone command, it will automatically initialize and update each submodule in the repository, including nested submodules if any of the submodules in the repository have submodules themselves. # Clone repository and initialize submodules git clone --recurse-submodules <repository-url> # Example git clone --recurse-submodules https://github.com/example/main-project.git If you already cloned the project and forgot --recurse-submodules, you can combine the git submodule init and git submodule update steps by running git submodule update --init. To also initialize, fetch and checkout any nested submodules, you can use the foolproof git submodule update --init --recursive. git submodule update --init --recursive There is a special situation that can happen when pulling superproject updates: it could be that the upstream repository has changed the URL of the submodule in the .gitmodules file in one of the commits you pull. This can happen for example if the submodule project changes its hosting platform. In that case, it is possible for git pull --recurse-submodules, or git submodule update, to fail if the superproject references a submodule commit that is not found in the submodule remote locally configured in your repository. In order to remedy this situation, the git submodule sync command is required: # copy the new URL to your local config $ git submodule sync --recursive # update the submodule from the new URL $ git submodule update --init --recursive Updating Submodules to the Latest Commit If you want to update your submodules to their latest commit, use: # Update all submodules to the latest commit git submodule update --remote # Example git submodule update --remote lib/library This command updates the submodule to the latest commit on the default branch. Removing a Submodule To remove a submodule, you need to follow several steps: git rm <path-to-submodule> git commit This removes the filetree at 'path-to-submodule', and the submodule's entry in the .gitmodules file. i.e. all traces of the submodule in your repository proper are removed. Remove the submodule directory from the index The .git/config file keeps track of all submodules, their paths, and URLs. Here\u2019s an example entry. As the docs note however, the .git dir of the submodule is kept around (in the modules/ directory of the main project's .git dir), \"to make it possible to checkout past commits without requiring fetching from another repository\". If you nonetheless want to remove this info, manually delete the submodule's directory in .git/modules/, and remove the submodule's entry in the file .git/config. These steps can be automated using the commands rm -rf .git/modules/<path-to-submodule> git config --remove-section submodule.<path-to-submodule>. After performing these steps, commit the changes to complete the removal of the submodule. Managing Nested Submodules Submodules can themselves contain submodules. To initialize and update nested submodules, you need to pass the --recursive flag: # Initialize nested submodules git submodule update --init --recursive # Update nested submodules to the latest commit git submodule update --remote --recursive Submodule Configuration in .gitmodules The .gitmodules file keeps track of all submodules, their paths, and URLs. Here\u2019s an example entry: [submodule \"lib/library\"] path = lib/library url = https://github.com/example/library.git Submodule Foreach The git submodule foreach command allows you to run a command on each submodule in your project. It can be used to execute arbitrary commands on each submodule. For example, let\u2019s say we want to start a new feature or do a bugfix and we have work going on in several submodules. We can easily stash all the work in all our submodules. git submodule foreach 'git stash' Then we can create a new branch and switch to it in all our submodules. git submodule foreach 'git checkout -b new-branch' One really useful thing you can do is produce a nice unified diff of what is changed in your main project and all your subprojects as well. git diff ; git submodule foreach 'git diff' Managing Dirty Submodules Reset and Clean All Submodules git submodule foreach --recursive 'git reset --hard && git clean -fd' Discards all changes (both staged and unstaged). Removes all untracked files and directories. When you want to completely reset submodules to the state defined in the main repository, with no need to save changes. Caution: This permanently deletes untracked changes. Use git clean -fdn first to preview. Stash Changes in All Submodules git submodule foreach --recursive 'git stash' Temporarily saves changes in submodules' working directories (for tracked files only). Changes can be restored later using git stash pop . When you want to save current progress in submodules without committing. Useful if you're unsure whether changes are needed later. Stash Changes, Including Untracked Files git submodule foreach --recursive 'git stash -u' Temporarily saves changes and untracked files in submodules. When there are untracked files that also need to be saved along with tracked changes. Update Submodules to Match the Main Repository git submodule update --init --recursive --force Syncs submodules to the exact commit specified in the main repository. Reinitializes submodules if they aren't set up yet. If submodules are out of sync or have uncommitted changes you don't care about. Good for getting a clean state without worrying about intermediate changes. Combine Stash and Clean git submodule foreach --recursive 'git stash && git clean -fd' Stashes tracked changes and removes untracked files in submodules. If you want to save changes (tracked files) while cleaning untracked files. Manually Commit or Discard Changes git submodule foreach --recursive 'git add . && git commit -m \"Save changes in submodule\"' git submodule foreach --recursive 'git checkout -- .' Either commits changes for long-term preservation or discards them selectively. Commit: When changes in submodules are worth preserving. Discard: When you only want to reset staged and unstaged changes without affecting untracked files. When to Use Each Approach Scenario Best Approach Completely reset submodules git reset --hard && git clean -fd Temporarily save changes git stash Temporarily save changes, including untracked files git stash -u Sync submodules to main repository state git submodule update --init --recursive --force Save progress in submodules (commit changes) git add . && git commit -m \"Save changes in submodule\" Save changes but clean untracked files git stash && git clean -fd The --recurse-submodules flag Command Example Usage git clone git clone --recurse-submodules <repository-url> git pull git pull --recurse-submodules git fetch git fetch --recurse-submodules git checkout git checkout --recurse-submodules <branch-name> git submodule update git submodule update --recurse-submodules git push git push --recurse-submodules=check git reset git reset --recurse-submodules <commit> Using the --recurse-submodules flag ensures that operations affecting the main repository also appropriately handle submodules, keeping everything in sync and properly updated. You can tell Git (>=2.14) to always use the --recurse-submodules flag by setting the configuration option submodule.recurse: git config submodule.recurse true . This will also make Git recurse into submodules for every command that has a --recurse-submodules option (except git clone). git clone When cloning a repository, this flag ensures that all submodules are also cloned and initialized. git clone --recurse-submodules <repository-url> git clone --recurse-submodules https://github.com/example/repo.git git pull or git fetch Pulls or Fetches changes from the remote repository and updates submodules as well. git pull --recurse-submodules git fetch --recurse-submodules git checkout Checks out a branch or commit and updates the submodules to the correct commit. git checkout --recurse-submodules <branch-name> git checkout --recurse-submodules main git submodule update Updates the submodules to the commit specified in the superproject. This flag is used to ensure that nested submodules are also updated. git submodule update --recurse-submodules git push When pushing to a remote repository, this flag ensures that submodule commits are also pushed. git push --recurse-submodules = check Here, the check option checks that all submodule commits that the superproject references are present on the remote repository before pushing. The check option will make push simply fail if any of the committed submodule changes haven\u2019t been pushed. If you want the \u201ccheck\u201d behavior to happen for all pushes, you can make this behavior the default by doing git config push.recurseSubmodules check . The on-demand option ensures that the submodule commits are pushed even if the superproject commit is not present on the remote repository. Git will go into each submodule and push to the remotes to make sure they\u2019re externally available. You can make this behavior the default by doing git config push.recurseSubmodules on-demand . git reset Resets the current HEAD to a specified state and updates submodules accordingly. git reset --recurse-submodules <commit> git reset --recurse-submodules HEAD~1 git config and submodules git diff --submodule git diff --submodule shows the changes in the submodules. You can see that the submodule was updated and get a list of commits that were added to it. If you don\u2019t want to type --submodule every time you run git diff , you can set it as the default format by setting the diff.submodule config value to \u201clog\u201d. git config --global diff.submodule log Modify .gitmodules If you want to have a submodule track that repository\u2019s \u201cstable\u201d branch, you can set it in either your .gitmodules file (so everyone else also tracks it), or just in your local .git/config file. Let\u2019s set it in the .gitmodules file: git config -f .gitmodules submodule.<name-submodule>.branch stable If you leave off the -f .gitmodules it will only make the change for you, but it probably makes more sense to track that information with the repository so everyone else does as well. Status of submodules git submodule status If you set the configuration setting status.submodulesummary, Git will also show you a short summary of changes to your submodules. git config status.submodulesummary 1 git log We can actually see the log of commits that we\u2019re about to commit to in our submodule. Once committed, you can see this information after the fact as well when you run git log -p. git log -p --submodule Useful aliases git config alias.sdiff '!' \"git diff && git submodule foreach 'git diff'\" git config alias.spush 'push --recurse-submodules=on-demand' git config alias.supdate 'submodule update --remote --merge'","title":"Submodules"},{"location":"Advanced/git_submodules/#adding-a-submodule","text":"To add a submodule to your repository, use the git submodule add command. # Syntax git submodule add <repository-url> [ <path> ] # Example git submodule add https://github.com/example/library.git lib/library This command clones the submodule repository into the specified path and adds a reference to it in your .gitmodules file. By default, submodules will add the subproject into a directory named the same as the repository. You can add a different path at the end of the command if you want it to go elsewhere. You can also specify a branch to checkout with the -b flag. git submodule add -b master git@github.com:emeneo/moodle-enrol_apply.git enrol/apply The new .gitmodules file is a configuration file that stores the mapping between the project\u2019s URL and the local subdirectory you\u2019ve pulled it into. [ submodule \"enrol/apply\" ] path = enrol/apply url = git@github.com:emeneo/moodle-enrol_apply.git branch = master If you have multiple submodules, you\u2019ll have multiple entries in this file. It\u2019s important to note that this file is version-controlled with your other files, like your .gitignore file. It\u2019s pushed and pulled with the rest of your project. This is how other people who clone this project know where to get the submodule projects from.","title":"Adding a Submodule"},{"location":"Advanced/git_submodules/#initializing-and-updating-submodules","text":"After cloning a repository that contains submodules, you need to initialize and update them. # Initialize submodules git submodule init # Update submodules git submodule update git submodule sync ; git submodule update --init --recursive The init command initializes the submodules recorded in the .gitmodules file, while the update command fetches and checks out the correct commit specified by the superproject.","title":"Initializing and Updating Submodules"},{"location":"Advanced/git_submodules/#cloning-a-repository-with-submodules","text":"When cloning a repository that includes submodules, use the --recurse-submodules flag to automatically initialize and update submodules. When you clone such a project, by default you get the directories that contain submodules, but none of the files within them yet. You must run two commands: git submodule init to initialize your local configuration file, and git submodule update to fetch all the data from that project and check out the appropriate commit listed in your superproject. If you pass --recurse-submodules to the git clone command, it will automatically initialize and update each submodule in the repository, including nested submodules if any of the submodules in the repository have submodules themselves. # Clone repository and initialize submodules git clone --recurse-submodules <repository-url> # Example git clone --recurse-submodules https://github.com/example/main-project.git If you already cloned the project and forgot --recurse-submodules, you can combine the git submodule init and git submodule update steps by running git submodule update --init. To also initialize, fetch and checkout any nested submodules, you can use the foolproof git submodule update --init --recursive. git submodule update --init --recursive There is a special situation that can happen when pulling superproject updates: it could be that the upstream repository has changed the URL of the submodule in the .gitmodules file in one of the commits you pull. This can happen for example if the submodule project changes its hosting platform. In that case, it is possible for git pull --recurse-submodules, or git submodule update, to fail if the superproject references a submodule commit that is not found in the submodule remote locally configured in your repository. In order to remedy this situation, the git submodule sync command is required: # copy the new URL to your local config $ git submodule sync --recursive # update the submodule from the new URL $ git submodule update --init --recursive","title":"Cloning a Repository with Submodules"},{"location":"Advanced/git_submodules/#updating-submodules-to-the-latest-commit","text":"If you want to update your submodules to their latest commit, use: # Update all submodules to the latest commit git submodule update --remote # Example git submodule update --remote lib/library This command updates the submodule to the latest commit on the default branch.","title":"Updating Submodules to the Latest Commit"},{"location":"Advanced/git_submodules/#removing-a-submodule","text":"To remove a submodule, you need to follow several steps: git rm <path-to-submodule> git commit This removes the filetree at 'path-to-submodule', and the submodule's entry in the .gitmodules file. i.e. all traces of the submodule in your repository proper are removed.","title":"Removing a Submodule"},{"location":"Advanced/git_submodules/#remove-the-submodule-directory-from-the-index","text":"The .git/config file keeps track of all submodules, their paths, and URLs. Here\u2019s an example entry. As the docs note however, the .git dir of the submodule is kept around (in the modules/ directory of the main project's .git dir), \"to make it possible to checkout past commits without requiring fetching from another repository\". If you nonetheless want to remove this info, manually delete the submodule's directory in .git/modules/, and remove the submodule's entry in the file .git/config. These steps can be automated using the commands rm -rf .git/modules/<path-to-submodule> git config --remove-section submodule.<path-to-submodule>. After performing these steps, commit the changes to complete the removal of the submodule.","title":"Remove the submodule directory from the index"},{"location":"Advanced/git_submodules/#managing-nested-submodules","text":"Submodules can themselves contain submodules. To initialize and update nested submodules, you need to pass the --recursive flag: # Initialize nested submodules git submodule update --init --recursive # Update nested submodules to the latest commit git submodule update --remote --recursive","title":"Managing Nested Submodules"},{"location":"Advanced/git_submodules/#submodule-configuration-in-gitmodules","text":"The .gitmodules file keeps track of all submodules, their paths, and URLs. Here\u2019s an example entry: [submodule \"lib/library\"] path = lib/library url = https://github.com/example/library.git","title":"Submodule Configuration in .gitmodules"},{"location":"Advanced/git_submodules/#submodule-foreach","text":"The git submodule foreach command allows you to run a command on each submodule in your project. It can be used to execute arbitrary commands on each submodule. For example, let\u2019s say we want to start a new feature or do a bugfix and we have work going on in several submodules. We can easily stash all the work in all our submodules. git submodule foreach 'git stash' Then we can create a new branch and switch to it in all our submodules. git submodule foreach 'git checkout -b new-branch' One really useful thing you can do is produce a nice unified diff of what is changed in your main project and all your subprojects as well. git diff ; git submodule foreach 'git diff'","title":"Submodule Foreach"},{"location":"Advanced/git_submodules/#managing-dirty-submodules","text":"","title":"Managing Dirty Submodules"},{"location":"Advanced/git_submodules/#reset-and-clean-all-submodules","text":"git submodule foreach --recursive 'git reset --hard && git clean -fd' Discards all changes (both staged and unstaged). Removes all untracked files and directories. When you want to completely reset submodules to the state defined in the main repository, with no need to save changes. Caution: This permanently deletes untracked changes. Use git clean -fdn first to preview.","title":"Reset and Clean All Submodules"},{"location":"Advanced/git_submodules/#stash-changes-in-all-submodules","text":"git submodule foreach --recursive 'git stash' Temporarily saves changes in submodules' working directories (for tracked files only). Changes can be restored later using git stash pop . When you want to save current progress in submodules without committing. Useful if you're unsure whether changes are needed later.","title":"Stash Changes in All Submodules"},{"location":"Advanced/git_submodules/#stash-changes-including-untracked-files","text":"git submodule foreach --recursive 'git stash -u' Temporarily saves changes and untracked files in submodules. When there are untracked files that also need to be saved along with tracked changes.","title":"Stash Changes, Including Untracked Files"},{"location":"Advanced/git_submodules/#update-submodules-to-match-the-main-repository","text":"git submodule update --init --recursive --force Syncs submodules to the exact commit specified in the main repository. Reinitializes submodules if they aren't set up yet. If submodules are out of sync or have uncommitted changes you don't care about. Good for getting a clean state without worrying about intermediate changes.","title":"Update Submodules to Match the Main Repository"},{"location":"Advanced/git_submodules/#combine-stash-and-clean","text":"git submodule foreach --recursive 'git stash && git clean -fd' Stashes tracked changes and removes untracked files in submodules. If you want to save changes (tracked files) while cleaning untracked files.","title":"Combine Stash and Clean"},{"location":"Advanced/git_submodules/#manually-commit-or-discard-changes","text":"git submodule foreach --recursive 'git add . && git commit -m \"Save changes in submodule\"' git submodule foreach --recursive 'git checkout -- .' Either commits changes for long-term preservation or discards them selectively. Commit: When changes in submodules are worth preserving. Discard: When you only want to reset staged and unstaged changes without affecting untracked files.","title":"Manually Commit or Discard Changes"},{"location":"Advanced/git_submodules/#the-recurse-submodules-flag","text":"Command Example Usage git clone git clone --recurse-submodules <repository-url> git pull git pull --recurse-submodules git fetch git fetch --recurse-submodules git checkout git checkout --recurse-submodules <branch-name> git submodule update git submodule update --recurse-submodules git push git push --recurse-submodules=check git reset git reset --recurse-submodules <commit> Using the --recurse-submodules flag ensures that operations affecting the main repository also appropriately handle submodules, keeping everything in sync and properly updated. You can tell Git (>=2.14) to always use the --recurse-submodules flag by setting the configuration option submodule.recurse: git config submodule.recurse true . This will also make Git recurse into submodules for every command that has a --recurse-submodules option (except git clone).","title":"The --recurse-submodules flag"},{"location":"Advanced/git_submodules/#git-config-and-submodules","text":"","title":"git config and submodules"},{"location":"Advanced/git_submodules/#git-diff-submodule","text":"git diff --submodule shows the changes in the submodules. You can see that the submodule was updated and get a list of commits that were added to it. If you don\u2019t want to type --submodule every time you run git diff , you can set it as the default format by setting the diff.submodule config value to \u201clog\u201d. git config --global diff.submodule log","title":"git diff --submodule"},{"location":"Advanced/git_submodules/#modify-gitmodules","text":"If you want to have a submodule track that repository\u2019s \u201cstable\u201d branch, you can set it in either your .gitmodules file (so everyone else also tracks it), or just in your local .git/config file. Let\u2019s set it in the .gitmodules file: git config -f .gitmodules submodule.<name-submodule>.branch stable If you leave off the -f .gitmodules it will only make the change for you, but it probably makes more sense to track that information with the repository so everyone else does as well.","title":"Modify .gitmodules"},{"location":"Advanced/git_submodules/#status-of-submodules","text":"git submodule status If you set the configuration setting status.submodulesummary, Git will also show you a short summary of changes to your submodules. git config status.submodulesummary 1","title":"Status of submodules"},{"location":"Advanced/git_submodules/#git-log","text":"We can actually see the log of commits that we\u2019re about to commit to in our submodule. Once committed, you can see this information after the fact as well when you run git log -p. git log -p --submodule","title":"git log"},{"location":"Advanced/git_submodules/#useful-aliases","text":"git config alias.sdiff '!' \"git diff && git submodule foreach 'git diff'\" git config alias.spush 'push --recurse-submodules=on-demand' git config alias.supdate 'submodule update --remote --merge'","title":"Useful aliases"},{"location":"Advanced/git_tagging/","text":"In Git, tagging is the process of assigning a meaningful label or marker to a specific commit in the repository's history. Tags are often used to mark significant points in the project's development, such as releases, versions, or milestones. Types of Tags There are two types of tags in Git: Lightweight Tags These are simple pointers to specific commits, similar to branches but immutable. They are created with the -l option. Annotated Tags These are stored as full objects in the Git database, containing details like the tagger's name, email, date, and a tagging message. They are created with the -a option. Creating Tags Lightweight Tags git tag <tag-name> <commit-hash> git tag v1.0.0 7c52d53 Annotated Tags git tag -a <tag-name> <commit-hash> -m \"Tagging message\" git tag -a v1.0.0 7c52d53 -m \"Version 1.0.0 release\" The -m specifies a tagging message, which is stored with the tag. If you don\u2019t specify a message for an annotated tag, Git launches your editor so you can type it in. Tagging Later : You can also tag commits after you\u2019ve moved past them. Viewing Tags To view all tags in the repository: git tag In Git, listing tags allows you to view all tags present in the repository. You can use wildcards to filter tags based on specific patterns. Here's how you can list tags in Git with examples and wildcards: Listing Tags Matching a Pattern You can use wildcards to list tags matching a specific pattern. Listing tag wildcards requires -l or --list option. The two common wildcards used are: * : Matches any sequence of characters. ? : Matches any single character. Listing Tags Starting with a Prefix To list tags starting with a specific prefix (e.g., v1 ): git tag -l 'v1*' Listing Tags with Annotated Tags Only To list only annotated tags (excluding lightweight tags): git tag -l -n Using wildcards with git tag -l allows you to filter and list tags based on specific patterns, making it easier to manage and navigate through tags in your Git repository. Listing tag wildcards requires -l or --list option. Pushing Tags to Remote By default, the git push command doesn\u2019t transfer tags to remote servers. To push a specific tag to the remote repository: git push origin <tag-name> To push all tags to the remote repository: git push origin --tags git push origin v1.0.0 git push pushes both types of tags. git push --tags will push both lightweight and annotated tags. There is currently no option to push only lightweight tags, but if you use git push --follow-tags only annotated tags will be pushed to the remote. Deleting Tags To delete a specific tag: git tag -d <tag-name> git tag -d v1.0.0 To delete a tag on the remote repository: git push origin --delete <tag-name> git push origin --delete v1.0.0 Checking out Tags To checkout a specific tag and create a detached HEAD state: git checkout <tag-name> git checkout v1.0.0 In \u201cdetached HEAD\u201d state, if you make changes and then create a commit, the tag will stay the same, but your new commit won\u2019t belong to any branch and will be unreachable, except by the exact commit hash. Thus, if you need to make changes\u2009\u2014\u2009say you\u2019re fixing a bug on an older version, for instance\u2009\u2014\u2009you will generally want to create a branch: $ git checkout -b version2 v2.0.0 #Switched to a new branch 'version2' If you do this and make a commit, your version2 branch will be slightly different than your v2.0.0 tag since it will move forward with your new changes, so do be careful. Tagging Best Practices Use semantic versioning (e.g., v1.0.0, v1.1.0) for version tags to maintain consistency. Annotate tags with meaningful messages describing the purpose or significance of the tagged commit. Push tags to the remote repository to share them with collaborators and facilitate release management. Git tagging is a powerful feature for marking important points in your project's history, making it easier to navigate and manage releases.","title":"Tagging"},{"location":"Advanced/git_tagging/#types-of-tags","text":"There are two types of tags in Git: Lightweight Tags These are simple pointers to specific commits, similar to branches but immutable. They are created with the -l option. Annotated Tags These are stored as full objects in the Git database, containing details like the tagger's name, email, date, and a tagging message. They are created with the -a option.","title":"Types of Tags"},{"location":"Advanced/git_tagging/#creating-tags","text":"","title":"Creating Tags"},{"location":"Advanced/git_tagging/#lightweight-tags","text":"git tag <tag-name> <commit-hash> git tag v1.0.0 7c52d53","title":"Lightweight Tags"},{"location":"Advanced/git_tagging/#annotated-tags","text":"git tag -a <tag-name> <commit-hash> -m \"Tagging message\" git tag -a v1.0.0 7c52d53 -m \"Version 1.0.0 release\" The -m specifies a tagging message, which is stored with the tag. If you don\u2019t specify a message for an annotated tag, Git launches your editor so you can type it in. Tagging Later : You can also tag commits after you\u2019ve moved past them.","title":"Annotated Tags"},{"location":"Advanced/git_tagging/#viewing-tags","text":"To view all tags in the repository: git tag In Git, listing tags allows you to view all tags present in the repository. You can use wildcards to filter tags based on specific patterns. Here's how you can list tags in Git with examples and wildcards:","title":"Viewing Tags"},{"location":"Advanced/git_tagging/#listing-tags-matching-a-pattern","text":"You can use wildcards to list tags matching a specific pattern. Listing tag wildcards requires -l or --list option. The two common wildcards used are: * : Matches any sequence of characters. ? : Matches any single character.","title":"Listing Tags Matching a Pattern"},{"location":"Advanced/git_tagging/#listing-tags-starting-with-a-prefix","text":"To list tags starting with a specific prefix (e.g., v1 ): git tag -l 'v1*'","title":"Listing Tags Starting with a Prefix"},{"location":"Advanced/git_tagging/#listing-tags-with-annotated-tags-only","text":"To list only annotated tags (excluding lightweight tags): git tag -l -n Using wildcards with git tag -l allows you to filter and list tags based on specific patterns, making it easier to manage and navigate through tags in your Git repository. Listing tag wildcards requires -l or --list option.","title":"Listing Tags with Annotated Tags Only"},{"location":"Advanced/git_tagging/#pushing-tags-to-remote","text":"By default, the git push command doesn\u2019t transfer tags to remote servers. To push a specific tag to the remote repository: git push origin <tag-name> To push all tags to the remote repository: git push origin --tags git push origin v1.0.0 git push pushes both types of tags. git push --tags will push both lightweight and annotated tags. There is currently no option to push only lightweight tags, but if you use git push --follow-tags only annotated tags will be pushed to the remote.","title":"Pushing Tags to Remote"},{"location":"Advanced/git_tagging/#deleting-tags","text":"To delete a specific tag: git tag -d <tag-name> git tag -d v1.0.0 To delete a tag on the remote repository: git push origin --delete <tag-name> git push origin --delete v1.0.0","title":"Deleting Tags"},{"location":"Advanced/git_tagging/#checking-out-tags","text":"To checkout a specific tag and create a detached HEAD state: git checkout <tag-name> git checkout v1.0.0 In \u201cdetached HEAD\u201d state, if you make changes and then create a commit, the tag will stay the same, but your new commit won\u2019t belong to any branch and will be unreachable, except by the exact commit hash. Thus, if you need to make changes\u2009\u2014\u2009say you\u2019re fixing a bug on an older version, for instance\u2009\u2014\u2009you will generally want to create a branch: $ git checkout -b version2 v2.0.0 #Switched to a new branch 'version2' If you do this and make a commit, your version2 branch will be slightly different than your v2.0.0 tag since it will move forward with your new changes, so do be careful.","title":"Checking out Tags"},{"location":"Advanced/git_tagging/#tagging-best-practices","text":"Use semantic versioning (e.g., v1.0.0, v1.1.0) for version tags to maintain consistency. Annotate tags with meaningful messages describing the purpose or significance of the tagged commit. Push tags to the remote repository to share them with collaborators and facilitate release management. Git tagging is a powerful feature for marking important points in your project's history, making it easier to navigate and manage releases.","title":"Tagging Best Practices"},{"location":"Basics/git_configuration/","text":"After installing Git, the next step is to configure it with your user information. This ensures that your commits are associated with the correct identity. Git uses a series of configuration files to determine non-default behavior that you may want. The first place Git looks for these values is in the system-wide [path]/etc/gitconfig file, which contains settings that are applied to every user on the system and all of their repositories. If you pass the option --system to git config , it reads and writes from this file specifically. The next place Git looks is the ~/.gitconfig (or ~/.config/git/config ) file, which is specific to each user. You can make Git read and write to this file by passing the --global option. Finally, Git looks for configuration values in the configuration file in the Git directory ( .git/config ) of whatever repository you\u2019re currently using. These values are specific to that single repository, and represent passing the --local option to git config . If you don\u2019t specify which level you want to work with, this is the default. Each of these \u201clevels\u201d (system, global, local) overwrites values in the previous level, so values in .git/config trump those in [path]/etc/gitconfig . Git\u2019s configuration files are plain-text, so you can also set these values by manually editing the file and inserting the correct syntax. It\u2019s generally easier to run the git config command, though. Follow these steps to configure Git with your user information used across all local repositories: 1. Open a Terminal/Command Prompt Windows: Git Bash, Command Prompt, or PowerShell. macOS/Linux: Terminal. 2. Set Your Username Run the following command, replacing \"Your Name\" with your actual name: git config --global user.name \"firstname Lastname\" 3. Set Your Email Address Run the following command, replacing \"your.email@example.com\" with your actual email address: git config --global user.email \"your.email@example.com\" 4. Configure Line Endings To prevent line ending issues when collaborating across different platforms, set your preferred line ending configuration. For Unix-style line endings (LF), run: git config --global core.autocrlf input For Windows-style line endings (CRLF), run: git config --global core.autocrlf true 5. Configure Text Editor (Optional) When you launch VS Code from the command line, you can pass the --wait argument to make the launch command wait until you have closed the new VS Code instance. This can be useful when you configure VS Code as your Git external editor so Git will wait until you close the launched VS Code instance. Set your preferred text editor for Git. For example, to use VSCode: git config --global core.editor \"code --wait\" use VS Code's diff and merge capabilities even when using Git from command-line. Add the following to your Git configurations to use VS Code as the diff and merge tool: git config --global -e and change the following: [ diff ] tool = default-difftool [ difftool \"default-difftool\" ] cmd = code --wait --diff $LOCAL $REMOTE [ merge ] tool = code [ mergetool \"code\" ] cmd = code --wait --merge $REMOTE $LOCAL $BASE $MERGED This uses the --diff option that can be passed to VS Code to compare two files side by side. The merge tool will be used the next time Git discovers a merge conflict. To summarize, here are some examples of where you can use VS Code as the editor: git rebase HEAD~3 -i do interactive rebase using VS Code git commit use VS Code for the commit message git add -p followed by e for interactive add git difftool <commit>^ <commit> use VS Code as the diff editor for changes If you only want to use Visual Studio Code without any advanced configurations, use: git config --global core.editor \"code --wait\" git config --global merge.tool code git config --global mergetool.code.cmd \"code --wait --merge $REMOTE $LOCAL $BASE $MERGED \" Git output window You can always peek under the hood to see the Git commands that are being run. This is helpful if something strange is happening or if you are just curious. To open the Git output window, run View > Output and select Log (Git) from the dropdown list. 6. Enable Color Output Improve readability by enabling color output in the Git command line: git config --global color.ui auto This setting adds color to various Git outputs, making it easier to distinguish between different types of information.To view your Git configuration, run: 7. Check Configuration To view your Git configuration, run: git config --list Ensure that your name, email, and other settings are correctly displayed. 8. Verify Configuration Run the following commands to verify your configuration: git config user.name git config user.email These commands should display the values you've just set. Additional Tips Credential Caching To avoid entering your credentials repeatedly, you can set up credential caching. On Windows, Git Credential Manager is often used. On macOS/Linux, you can use the credential helper provided by Git: git config --global credential.helper cache SSH Key If you prefer using SSH for authentication, generate an SSH key and associate it with your GitHub account . Commit templates Consider a template file at ~/.gitmessage.txt to use as a commit message template. [ Ticket: X ] Subject line ( try to keep under 50 characters ) Multi-line description of commit, feel free to be detailed. then set the commit.template configuration option to the path to this file. git config --global commit.template ~/.gitmessage.txt core.pager This setting determines which pager is used when Git pages output such as log and diff. You can set it to more or to your favorite pager (by default, it\u2019s less), or you can turn it off by setting it to a blank string: git config --global core.pager '' If you run that, Git will print the entire output of all commands, no matter how long they are. user.signingkey If you\u2019re making signed annotated tags (as discussed in Signing Your Work), setting your GPG signing key as a configuration setting makes things easier. Set your key ID like so: git config --global user.signingkey <gpg-key-id> Now, you can sign tags without having to specify your key every time with the git tag command: git tag -s <tag-name> core.excludesfile You can put patterns in your project\u2019s .gitignore file to have Git not see them as untracked files or try to stage them when you run git add on them. But sometimes you want to ignore certain files for all repositories that you work with. In that case, you can set your global .gitignore_global file as follows: This setting lets you write a kind of global .gitignore file. If you create a ~/.gitignore_global file with these contents: *~ .*.swp .DS_Store Then you run git config --global core.excludesfile ~/.gitignore_global Git will never again bother you about those files.","title":"Configuring Git"},{"location":"Basics/git_configuration/#1-open-a-terminalcommand-prompt","text":"Windows: Git Bash, Command Prompt, or PowerShell. macOS/Linux: Terminal.","title":"1. Open a Terminal/Command Prompt"},{"location":"Basics/git_configuration/#2-set-your-username","text":"Run the following command, replacing \"Your Name\" with your actual name: git config --global user.name \"firstname Lastname\"","title":"2. Set Your Username"},{"location":"Basics/git_configuration/#3-set-your-email-address","text":"Run the following command, replacing \"your.email@example.com\" with your actual email address: git config --global user.email \"your.email@example.com\"","title":"3. Set Your Email Address"},{"location":"Basics/git_configuration/#4-configure-line-endings","text":"To prevent line ending issues when collaborating across different platforms, set your preferred line ending configuration. For Unix-style line endings (LF), run: git config --global core.autocrlf input For Windows-style line endings (CRLF), run: git config --global core.autocrlf true","title":"4. Configure Line Endings"},{"location":"Basics/git_configuration/#5-configure-text-editor-optional","text":"When you launch VS Code from the command line, you can pass the --wait argument to make the launch command wait until you have closed the new VS Code instance. This can be useful when you configure VS Code as your Git external editor so Git will wait until you close the launched VS Code instance. Set your preferred text editor for Git. For example, to use VSCode: git config --global core.editor \"code --wait\" use VS Code's diff and merge capabilities even when using Git from command-line. Add the following to your Git configurations to use VS Code as the diff and merge tool: git config --global -e and change the following: [ diff ] tool = default-difftool [ difftool \"default-difftool\" ] cmd = code --wait --diff $LOCAL $REMOTE [ merge ] tool = code [ mergetool \"code\" ] cmd = code --wait --merge $REMOTE $LOCAL $BASE $MERGED This uses the --diff option that can be passed to VS Code to compare two files side by side. The merge tool will be used the next time Git discovers a merge conflict. To summarize, here are some examples of where you can use VS Code as the editor: git rebase HEAD~3 -i do interactive rebase using VS Code git commit use VS Code for the commit message git add -p followed by e for interactive add git difftool <commit>^ <commit> use VS Code as the diff editor for changes If you only want to use Visual Studio Code without any advanced configurations, use: git config --global core.editor \"code --wait\" git config --global merge.tool code git config --global mergetool.code.cmd \"code --wait --merge $REMOTE $LOCAL $BASE $MERGED \"","title":"5. Configure Text Editor (Optional)"},{"location":"Basics/git_configuration/#git-output-window","text":"You can always peek under the hood to see the Git commands that are being run. This is helpful if something strange is happening or if you are just curious. To open the Git output window, run View > Output and select Log (Git) from the dropdown list.","title":"Git output window"},{"location":"Basics/git_configuration/#6-enable-color-output","text":"Improve readability by enabling color output in the Git command line: git config --global color.ui auto This setting adds color to various Git outputs, making it easier to distinguish between different types of information.To view your Git configuration, run:","title":"6. Enable Color Output"},{"location":"Basics/git_configuration/#7-check-configuration","text":"To view your Git configuration, run: git config --list Ensure that your name, email, and other settings are correctly displayed.","title":"7. Check Configuration"},{"location":"Basics/git_configuration/#8-verify-configuration","text":"Run the following commands to verify your configuration: git config user.name git config user.email These commands should display the values you've just set.","title":"8. Verify Configuration"},{"location":"Basics/git_configuration/#additional-tips","text":"Credential Caching To avoid entering your credentials repeatedly, you can set up credential caching. On Windows, Git Credential Manager is often used. On macOS/Linux, you can use the credential helper provided by Git: git config --global credential.helper cache SSH Key If you prefer using SSH for authentication, generate an SSH key and associate it with your GitHub account . Commit templates Consider a template file at ~/.gitmessage.txt to use as a commit message template. [ Ticket: X ] Subject line ( try to keep under 50 characters ) Multi-line description of commit, feel free to be detailed. then set the commit.template configuration option to the path to this file. git config --global commit.template ~/.gitmessage.txt core.pager This setting determines which pager is used when Git pages output such as log and diff. You can set it to more or to your favorite pager (by default, it\u2019s less), or you can turn it off by setting it to a blank string: git config --global core.pager '' If you run that, Git will print the entire output of all commands, no matter how long they are. user.signingkey If you\u2019re making signed annotated tags (as discussed in Signing Your Work), setting your GPG signing key as a configuration setting makes things easier. Set your key ID like so: git config --global user.signingkey <gpg-key-id> Now, you can sign tags without having to specify your key every time with the git tag command: git tag -s <tag-name> core.excludesfile You can put patterns in your project\u2019s .gitignore file to have Git not see them as untracked files or try to stage them when you run git add on them. But sometimes you want to ignore certain files for all repositories that you work with. In that case, you can set your global .gitignore_global file as follows: This setting lets you write a kind of global .gitignore file. If you create a ~/.gitignore_global file with these contents: *~ .*.swp .DS_Store Then you run git config --global core.excludesfile ~/.gitignore_global Git will never again bother you about those files.","title":"Additional Tips"},{"location":"Basics/git_inspect/","text":"In Git, several commands allow inspection and comparison of changes, commits, branches, and repository states. git status Shows the status of the working directory and staging area. git status Quickly check which files are modified, staged, or untracked. In VS Code, selecting a file in the Source Control panel will open a diff view of the changes introduced by that file. There is a Synchronize Changes action in the Status Bar, next to the branch indicator, when the current checked out branch has an upstream branch configured. Synchronize Changes will pull remote changes down to your local repository and then push local commits to the upstream branch. If there is no upstream branch configured and the Git repository has remotes set up, the Publish action is enabled. This will let you publish the current branch to a remote. Gutter indicators If you open a folder that is a Git repository and begin making changes, VS Code will add useful annotations to the gutter and to the overview ruler. A red triangle indicates where lines have been deleted A green bar indicates new added lines A blue bar indicates modified lines git diff Displays the differences between changes in the working directory and the staging area. git diff Review modifications before staging them or to see changes that haven't been staged yet. git diff {commit} {commit} Shows the differences between two commits. git diff abc123 def456 Compare the changes between specific commits. git diff {branch1} {branch2} Shows the differences between two branches. git diff main feature-branch Compare changes between different branches. Timeline view The Timeline view, accessible at the bottom of the File Explorer by default, is a unified view for visualizing time-series events (for example, Git commits) for a file. VS Code's built-in Git support provides the Git commit history of the specified file. Selecting a commit will open a diff view of the changes introduced by that commit. When you right-click on a commit, you'll get options to Copy Commit ID and Copy Commit Message. git diff --no-index The --no-index flag is used to compare two files or directories outside of a Git repository. This allows git diff to function as a general-purpose diff tool, even for files not tracked by Git. When using --no-index , Git does not check whether the files or directories are part of a Git repository. Instead, it directly compares their contents. Compare Two Files: git diff --no-index file1.txt file2.txt - This command shows the differences between file1.txt and file2.txt , similar to the output of the diff tool. - Example Output: --- file1.txt +++ file2.txt @@ -1,2 +1,2 @@ Hello World -Goodbye +Hello Again Compare Two Folders: git diff --no-index folder1/ folder2/ - Compares all files in folder1 with corresponding files in folder2 . - Example Output: diff --git a/folder1/example.txt b/folder2/example.txt --- a/folder1/example.txt +++ b/folder2/example.txt @@ -1 +1 @@ -This is file 1 +This is file 2 Use Cases : Compare files before adding them to a Git repository. Quickly compare files in unrelated directories. git diff --stat HEAD other_branch This command shows a summary of changes between your current branch ( HEAD ) and another branch ( other_branch ) in terms of the number of files changed, insertions, and deletions. git diff --stat HEAD feature_branch - Compares the current branch ( HEAD ) with feature_branch and shows a summary of differences. - Example Output: file1.txt | 10 +++++----- file2.py | 2 +- folder/file | 15 +++++++++------ 3 files changed, 12 insertions(+), 15 deletions(-) Use Cases : Quickly assess the magnitude of changes between branches. Identify which files have been impacted by commits on another branch. git diff branch1 branch2 -- path/to/file.txt This command compares a specific file ( path/to/file.txt ) between two branches ( branch1 and branch2 ). The -- separator ensures Git interprets path/to/file.txt as a file path, not a branch or commit. git diff main feature -- src/file.txt - Compares src/file.txt between the main branch and the feature branch. - Example Output: --- a/src/file.txt +++ b/src/file.txt @@ -1,3 +1,3 @@ Line 1 -Line 2 +Updated Line 2 Line 3 Use Cases : Isolate and review changes to a specific file across branches. Ensure specific files haven't diverged between branches before merging. git log Displays the commit history. git log Review the commit history, including commit messages, authors, dates, and commit hashes. By default, with no arguments, git log lists the commits made in that repository in reverse chronological order; that is, the most recent commits show up first git log --graph --oneline Shows a compact view of the commit history with a graph. git log --graph --oneline Visualize the branching and merging history of the repository. git log {file} Displays the commit history for a specific file. git log file.txt Review the commit history for a particular file, including changes made to it over time. git log branchB..branchA Shows the commits on branchA that are not on branchB. git log branchB..branchA Identify the commits unique to one branch compared to another, useful for understanding divergent development paths. ```bash git log branchB..branchA --oneline --no-merges ``` List the commits unique to one branch compared to another, excluding merge commits. git log --follow [file] Shows the commits that changed the specified file, even across renames. git log --follow file.txt Track the history of changes for a specific file, even if it was renamed in subsequent commits. git log --patch Shows the commit history in a unified diff format. One of the more helpful options is -p or --patch, which shows the difference (the patch output) introduced in each commit. You can also limit the number of log entries displayed, such as using -2 to show only the last two entries. git log -p -2 git log --stat Shows the commit history in a more readable format. git log --stat -M The --stat option prints below each commit entry a list of modified files, how many files were changed, and how many lines in those files were added and removed. It also puts a summary of the information at the end. This command is used to display the commit history along with statistics about the changes introduced in each commit, including information about file modifications, additions, and deletions. The -M option is particularly used to detect file renames. git log : Displays the commit logs. --stat : Includes additional statistics at the end of each commit entry, providing a summary of changes. -M : Enables Git's rename detection, which identifies file renames between commits. git log --stat -M This command will output a detailed log that includes commit information and statistics. The statistics section shows the number of lines added and removed for each file affected by the commit. Additionally, if a file has been renamed, Git will provide information about the rename. Here is a simplified example of what the output might look like: commit abcd1234 (HEAD) Author: John Doe <john.doe@example.com> Date: Tue Jan 18 12:00:00 2024 +0000 Updated README.md README.md | 10 +++++----- 1 file changed, 5 insertions(+), 5 deletions(-) In this example: commit abcd1234 : The unique identifier of the commit. Author : The author of the commit. Date : The date and time of the commit. Updated README.md : The commit message. The statistics section ( README.md | 10 +++++----- ) indicates that in the file README.md , 10 lines were added, and 5 lines were removed. This section provides a quick overview of the changes made in each commit. The -M option enhances this by detecting file renames. If a file has been renamed, Git will track the rename and display the old and new filenames. The -M option can take an optional value to set a similarity index for rename detection. For example, -M90% would consider files as renamed if 90% of their content is similar. Using -M can be especially useful when you want to track the history of a file that has been renamed over time. Limit the output of git log Option Description -<n> Show only the last n commits. --since, --after Limit the commits to those made after the specified date. --until, --before Limit the commits to those made before the specified date. --author Only show commits in which the author entry matches the specified string. --committer Only show commits in which the committer entry matches the specified string. --grep Only show commits with a commit message containing the string. -S Only show commits adding or removing code matching the string. git log --pretty = \"%h - %s\" --author = 'Junio C Hamano' --since = \"2008-10-01\" --before = \"2008-11-01\" --no-merges -- t/ This git log command is used to display a filtered and formatted list of commits from the Git repository. git log : This is the main Git command for viewing commit history. --pretty=\"%h - %s\" : The --pretty option specifies the output format for each commit. In this case, %h represents the abbreviated commit hash and %s represents the commit subject. The format string %h - %s prints the abbreviated commit hash followed by the commit subject. --author='Junio C Hamano' : The --author option filters the commits based on the author's name. Only commits authored by \"Junio C Hamano\" will be included in the output. --since=\"2008-10-01\" : The --since option specifies the start date for filtering commits. Only commits made after October 1st, 2008, will be included in the output. --before=\"2008-11-01\" : The --before option specifies the end date for filtering commits. Only commits made before November 1st, 2008, will be included in the output. --no-merges : The --no-merges option excludes merge commits from the output. Only non-merge commits will be displayed. -- t/ : This specifies the pathspec, which limits the commits to those that affect files or directories under the t/ directory. git show {commit} Displays the details of a specific commit. git show abc123 View the changes introduced by a commit and its metadata. git branch Lists all local branches. git branch Check the available branches and see the current branch. git branch -a Lists all local and remote branches. git branch -a View all branches, including those from remote repositories. These Git commands for inspection and comparison are invaluable for understanding the state of the repository, tracking changes, reviewing history, and identifying differences between branches or commits. Incorporating these commands into your Git workflow can enhance your ability to manage and collaborate on projects effectively.","title":"Inspect & Compare"},{"location":"Basics/git_inspect/#git-status","text":"Shows the status of the working directory and staging area. git status Quickly check which files are modified, staged, or untracked. In VS Code, selecting a file in the Source Control panel will open a diff view of the changes introduced by that file. There is a Synchronize Changes action in the Status Bar, next to the branch indicator, when the current checked out branch has an upstream branch configured. Synchronize Changes will pull remote changes down to your local repository and then push local commits to the upstream branch. If there is no upstream branch configured and the Git repository has remotes set up, the Publish action is enabled. This will let you publish the current branch to a remote.","title":"git status"},{"location":"Basics/git_inspect/#gutter-indicators","text":"If you open a folder that is a Git repository and begin making changes, VS Code will add useful annotations to the gutter and to the overview ruler. A red triangle indicates where lines have been deleted A green bar indicates new added lines A blue bar indicates modified lines","title":"Gutter indicators"},{"location":"Basics/git_inspect/#git-diff","text":"Displays the differences between changes in the working directory and the staging area. git diff Review modifications before staging them or to see changes that haven't been staged yet.","title":"git diff"},{"location":"Basics/git_inspect/#git-diff-commit-commit","text":"Shows the differences between two commits. git diff abc123 def456 Compare the changes between specific commits.","title":"git diff {commit} {commit}"},{"location":"Basics/git_inspect/#git-diff-branch1-branch2","text":"Shows the differences between two branches. git diff main feature-branch Compare changes between different branches.","title":"git diff {branch1} {branch2}"},{"location":"Basics/git_inspect/#timeline-view","text":"The Timeline view, accessible at the bottom of the File Explorer by default, is a unified view for visualizing time-series events (for example, Git commits) for a file. VS Code's built-in Git support provides the Git commit history of the specified file. Selecting a commit will open a diff view of the changes introduced by that commit. When you right-click on a commit, you'll get options to Copy Commit ID and Copy Commit Message.","title":"Timeline view"},{"location":"Basics/git_inspect/#git-diff-no-index","text":"The --no-index flag is used to compare two files or directories outside of a Git repository. This allows git diff to function as a general-purpose diff tool, even for files not tracked by Git. When using --no-index , Git does not check whether the files or directories are part of a Git repository. Instead, it directly compares their contents.","title":"git diff --no-index"},{"location":"Basics/git_inspect/#git-diff-stat-head-other_branch","text":"This command shows a summary of changes between your current branch ( HEAD ) and another branch ( other_branch ) in terms of the number of files changed, insertions, and deletions. git diff --stat HEAD feature_branch - Compares the current branch ( HEAD ) with feature_branch and shows a summary of differences. - Example Output: file1.txt | 10 +++++----- file2.py | 2 +- folder/file | 15 +++++++++------ 3 files changed, 12 insertions(+), 15 deletions(-)","title":"git diff --stat HEAD other_branch"},{"location":"Basics/git_inspect/#git-diff-branch1-branch2-pathtofiletxt","text":"This command compares a specific file ( path/to/file.txt ) between two branches ( branch1 and branch2 ). The -- separator ensures Git interprets path/to/file.txt as a file path, not a branch or commit. git diff main feature -- src/file.txt - Compares src/file.txt between the main branch and the feature branch. - Example Output: --- a/src/file.txt +++ b/src/file.txt @@ -1,3 +1,3 @@ Line 1 -Line 2 +Updated Line 2 Line 3","title":"git diff branch1 branch2 -- path/to/file.txt"},{"location":"Basics/git_inspect/#git-log","text":"Displays the commit history. git log Review the commit history, including commit messages, authors, dates, and commit hashes. By default, with no arguments, git log lists the commits made in that repository in reverse chronological order; that is, the most recent commits show up first","title":"git log"},{"location":"Basics/git_inspect/#git-log-graph-oneline","text":"Shows a compact view of the commit history with a graph. git log --graph --oneline Visualize the branching and merging history of the repository.","title":"git log --graph --oneline"},{"location":"Basics/git_inspect/#git-log-file","text":"Displays the commit history for a specific file. git log file.txt Review the commit history for a particular file, including changes made to it over time.","title":"git log {file}"},{"location":"Basics/git_inspect/#git-log-branchbbrancha","text":"Shows the commits on branchA that are not on branchB. git log branchB..branchA Identify the commits unique to one branch compared to another, useful for understanding divergent development paths. ```bash git log branchB..branchA --oneline --no-merges ``` List the commits unique to one branch compared to another, excluding merge commits.","title":"git log branchB..branchA"},{"location":"Basics/git_inspect/#git-log-follow-file","text":"Shows the commits that changed the specified file, even across renames. git log --follow file.txt Track the history of changes for a specific file, even if it was renamed in subsequent commits.","title":"git log --follow [file]"},{"location":"Basics/git_inspect/#git-log-patch","text":"Shows the commit history in a unified diff format. One of the more helpful options is -p or --patch, which shows the difference (the patch output) introduced in each commit. You can also limit the number of log entries displayed, such as using -2 to show only the last two entries. git log -p -2","title":"git log --patch"},{"location":"Basics/git_inspect/#git-log-stat","text":"Shows the commit history in a more readable format. git log --stat -M The --stat option prints below each commit entry a list of modified files, how many files were changed, and how many lines in those files were added and removed. It also puts a summary of the information at the end. This command is used to display the commit history along with statistics about the changes introduced in each commit, including information about file modifications, additions, and deletions. The -M option is particularly used to detect file renames. git log : Displays the commit logs. --stat : Includes additional statistics at the end of each commit entry, providing a summary of changes. -M : Enables Git's rename detection, which identifies file renames between commits. git log --stat -M This command will output a detailed log that includes commit information and statistics. The statistics section shows the number of lines added and removed for each file affected by the commit. Additionally, if a file has been renamed, Git will provide information about the rename. Here is a simplified example of what the output might look like: commit abcd1234 (HEAD) Author: John Doe <john.doe@example.com> Date: Tue Jan 18 12:00:00 2024 +0000 Updated README.md README.md | 10 +++++----- 1 file changed, 5 insertions(+), 5 deletions(-) In this example: commit abcd1234 : The unique identifier of the commit. Author : The author of the commit. Date : The date and time of the commit. Updated README.md : The commit message. The statistics section ( README.md | 10 +++++----- ) indicates that in the file README.md , 10 lines were added, and 5 lines were removed. This section provides a quick overview of the changes made in each commit. The -M option enhances this by detecting file renames. If a file has been renamed, Git will track the rename and display the old and new filenames. The -M option can take an optional value to set a similarity index for rename detection. For example, -M90% would consider files as renamed if 90% of their content is similar. Using -M can be especially useful when you want to track the history of a file that has been renamed over time.","title":"git log --stat"},{"location":"Basics/git_inspect/#limit-the-output-of-git-log","text":"Option Description -<n> Show only the last n commits. --since, --after Limit the commits to those made after the specified date. --until, --before Limit the commits to those made before the specified date. --author Only show commits in which the author entry matches the specified string. --committer Only show commits in which the committer entry matches the specified string. --grep Only show commits with a commit message containing the string. -S Only show commits adding or removing code matching the string. git log --pretty = \"%h - %s\" --author = 'Junio C Hamano' --since = \"2008-10-01\" --before = \"2008-11-01\" --no-merges -- t/ This git log command is used to display a filtered and formatted list of commits from the Git repository. git log : This is the main Git command for viewing commit history. --pretty=\"%h - %s\" : The --pretty option specifies the output format for each commit. In this case, %h represents the abbreviated commit hash and %s represents the commit subject. The format string %h - %s prints the abbreviated commit hash followed by the commit subject. --author='Junio C Hamano' : The --author option filters the commits based on the author's name. Only commits authored by \"Junio C Hamano\" will be included in the output. --since=\"2008-10-01\" : The --since option specifies the start date for filtering commits. Only commits made after October 1st, 2008, will be included in the output. --before=\"2008-11-01\" : The --before option specifies the end date for filtering commits. Only commits made before November 1st, 2008, will be included in the output. --no-merges : The --no-merges option excludes merge commits from the output. Only non-merge commits will be displayed. -- t/ : This specifies the pathspec, which limits the commits to those that affect files or directories under the t/ directory.","title":"Limit the output of git log"},{"location":"Basics/git_inspect/#git-show-commit","text":"Displays the details of a specific commit. git show abc123 View the changes introduced by a commit and its metadata.","title":"git show {commit}"},{"location":"Basics/git_inspect/#git-branch","text":"Lists all local branches. git branch Check the available branches and see the current branch.","title":"git branch"},{"location":"Basics/git_inspect/#git-branch-a","text":"Lists all local and remote branches. git branch -a View all branches, including those from remote repositories. These Git commands for inspection and comparison are invaluable for understanding the state of the repository, tracking changes, reviewing history, and identifying differences between branches or commits. Incorporating these commands into your Git workflow can enhance your ability to manage and collaborate on projects effectively.","title":"git branch -a"},{"location":"Basics/git_install/","text":"Git is a powerful version control system that helps you manage and track changes in your codebase. Here's a simple guide on how to install Git on your machine: Windows Download Git: Visit the official Git website at https://git-scm.com/download/win. Run Installer: Once the download is complete, run the installer and follow the on-screen instructions. Make sure to leave all default settings unless you have specific preferences. Adjusting your PATH environment: Choose the default option to \"Use Git from Git Bash only\" to avoid potential conflicts with other software. Select \"Use the OpenSSL library\" for secure connections. Choosing the Terminal Emulator: You can use Git Bash as your terminal emulator, providing a Unix-like environment on Windows. Alternatively, you can choose to use the Windows Command Prompt or PowerShell. Configuring Line Endings: Select \"Checkout as-is, commit Unix-style line endings\" unless you have a specific reason to choose otherwise. Completing the Installation: Click \"Install\" to complete the installation process. Updating Installation: git update-git-for-windows macOS Install Homebrew: Open Terminal and run the following command to install Homebrew, a package manager for macOS: /bin/bash -c \" $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh ) \" 2. Install Git: Once Homebrew is installed, run the following command to install Git: brew install git Linux Ubuntu/Debian sudo apt update sudo apt install git-all Fedora sudo dnf install git Arch Linux sudo pacman -S git Update Git sudo apt update sudo apt install git Verify Installation Regardless of your operating system, after installation, open a terminal and run: git --version This should display the installed Git version, confirming a successful installation. Now that Git is installed, you're ready to start using version control for your projects!","title":"Installing Git"},{"location":"Basics/git_install/#windows","text":"Download Git: Visit the official Git website at https://git-scm.com/download/win. Run Installer: Once the download is complete, run the installer and follow the on-screen instructions. Make sure to leave all default settings unless you have specific preferences. Adjusting your PATH environment: Choose the default option to \"Use Git from Git Bash only\" to avoid potential conflicts with other software. Select \"Use the OpenSSL library\" for secure connections. Choosing the Terminal Emulator: You can use Git Bash as your terminal emulator, providing a Unix-like environment on Windows. Alternatively, you can choose to use the Windows Command Prompt or PowerShell. Configuring Line Endings: Select \"Checkout as-is, commit Unix-style line endings\" unless you have a specific reason to choose otherwise. Completing the Installation: Click \"Install\" to complete the installation process. Updating Installation: git update-git-for-windows","title":"Windows"},{"location":"Basics/git_install/#macos","text":"Install Homebrew: Open Terminal and run the following command to install Homebrew, a package manager for macOS: /bin/bash -c \" $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh ) \" 2. Install Git: Once Homebrew is installed, run the following command to install Git: brew install git","title":"macOS"},{"location":"Basics/git_install/#linux","text":"","title":"Linux"},{"location":"Basics/git_install/#ubuntudebian","text":"sudo apt update sudo apt install git-all","title":"Ubuntu/Debian"},{"location":"Basics/git_install/#fedora","text":"sudo dnf install git","title":"Fedora"},{"location":"Basics/git_install/#arch-linux","text":"sudo pacman -S git","title":"Arch Linux"},{"location":"Basics/git_install/#update-git","text":"sudo apt update sudo apt install git","title":"Update Git"},{"location":"Basics/git_install/#verify-installation","text":"Regardless of your operating system, after installation, open a terminal and run: git --version This should display the installed Git version, confirming a successful installation. Now that Git is installed, you're ready to start using version control for your projects!","title":"Verify Installation"},{"location":"Basics/git_remotes/","text":"SHARE & UPDATE Retrieving updates from another repository and updating local repos. Working with remotes in Git involves collaborating with repositories hosted on remote servers. Viewing Remote Information To see which remote servers you have configured, run the following command: git remote -v Displays the URLs of the remote repositories. It lists the shortnames of each remote handle you\u2019ve specified. If you\u2019ve cloned your repository, you should at least see origin\u2009\u2014\u2009that is the default name Git gives to the server you cloned from. The -v flag displays the full remote URLs. When you have multiple remotes then you can pull contributions from any of these remotes. Adding a Remote Here\u2019s how to add a new remote explicitly. git remote add <remote-name> <remote-url> git remote add origin https://github.com/user/repo.git Adds a remote repository with a given name and URL. Now you can use the string origin on the command line in lieu of the whole URL. For example, if you want to fetch all the information from the remote repository, you can use: git fetch origin Fetching Changes from a Remote The command goes out to that remote project and pulls down all the data from that remote project that you don\u2019t have yet. After you do this, you should have references to all the branches from that remote, which you can merge in or inspect at any time. git fetch <remote-name> git fetch origin Fetches changes from all branches in the remote repository but does not merge them into the local branch. git fetch <remote-name> <branch-name> git fetch origin main Fetches changes from the main branch in the remote repository and merges them into the local branch. Pulling Changes from a Remote git pull <remote-name> <branch-name> git pull origin main Fetches changes from the remote repository and merges them into the local branch. From Git version 2.27 onward, git pull will give a warning if the pull.rebase variable is not set. Git will keep warning you until you set the variable. If you want the default behavior of Git (fast-forward if possible, else create a merge commit): git config --global pull.rebase \"false\" If you want to rebase when pulling: git config --global pull.rebase \"true\" Pushing Changes to a Remote When you have your project at a point that you want to share, you have to push it upstream. The command for this is simple. git push <remote-name> <branch-name> git push origin main Pushes local commits to the remote repository. This command works only if you cloned from a server to which you have write access and if nobody has pushed in the meantime. If you and someone else clone at the same time and they push upstream and then you push upstream, your push will rightly be rejected. You\u2019ll have to fetch their work first and incorporate it into yours before you\u2019ll be allowed to push. Creating a Branch in a Remote Repository git push <remote-name> <local-branch-name>:<remote-branch-name> git push origin feature-branch:feature-branch Creates a new branch in the remote repository based on the local branch. Cloning a Repository git clone <remote-url> git clone https://github.com/user/repo.git Creates a local copy of a remote repository. Renaming a Remote git remote rename <old-name> <new-name> git remote rename origin upstream Renames an existing remote. Removing a Remote git remote remove <remote-name> git remote remove origin Removes a remote from the list of remotes. Inspecting Remote Branches git branch -r Lists remote branches. The git remote show command is used to display information about a specific remote repository. It provides details such as the URL of the remote repository, the branches it tracks, and additional information about the remote branches. git remote show <remote-name> git remote show origin The output of git remote show <remote-name> typically includes the following information: Remote URL: The URL of the remote repository. Fetch URL: The URL used by git fetch to fetch from the remote repository. This may differ from the remote URL if the repository supports fetching from a different location. Push URL: The URL used by git push to push to the remote repository. This may differ from the remote URL if the repository supports pushing to a different location. Remote branches: Lists the branches present in the remote repository. Local branch configured for git pull : Indicates the local branch that git pull will merge into. Local refs configured for git push : Indicates the local branch that git push will push to. Tracking information for each branch: Shows information about the local branch's relationship with the remote branches. This includes the branch name, the remote branch it tracks, whether it is up to date, and the number of commits behind or ahead. * remote origin Fetch URL: https://github.com/user/repo.git Push URL: https://github.com/user/repo.git HEAD branch: main Remote branches: main tracked feature tracked Local branch configured for 'git pull': main merges with remote main Local refs configured for 'git push': main pushes to main (up to date) feature pushes to feature (local out of date) The git remote show command is useful for inspecting the configuration and status of a remote repository. It helps in understanding how local branches are synchronized with remote branches. The output provides valuable information for managing and coordinating work with remote repositories. Using git remote show can provide insights into the state of your remote repository, aiding in decision-making when performing operations such as fetching, pulling, or pushing changes. Tracking Branches Checking out a local branch from a remote-tracking branch automatically creates what is called a \u201ctracking branch\u201d (and the branch it tracks is called an \u201cupstream branch\u201d). Tracking branches are local branches that have a direct relationship to a remote branch. If you\u2019re on a tracking branch and type git pull, Git automatically knows which server to fetch from and which branch to merge in. When you clone a repository, it generally automatically creates a master branch that tracks origin/master. However, you can set up other tracking branches if you wish\u2009\u2014\u2009ones that track branches on other remotes, or don\u2019t track the master branch. git checkout -b <branch> <remote>/<branch> This is a common enough operation that Git provides the --track shorthand: git checkout --track origin/hotfix In fact, this is so common that there\u2019s even a shortcut for that shortcut. If the branch name you\u2019re trying to checkout (a) doesn\u2019t exist and (b) exactly matches a name on only one remote, Git will create a tracking branch for you: git checkout hotfix To set up a local branch with a different name than the remote branch, you can easily use the first version with a different local branch name: git checkout -b htfx origin/hotfix Now, your local branch htfx will automatically pull from origin/hotfix. If you already have a local branch and want to set it to a remote branch you just pulled down, or want to change the upstream branch you\u2019re tracking, you can use the -u or --set-upstream-to option to git branch to explicitly set it at any time. git branch -u origin/hotfix Upstream shorthand When you have a tracking branch set up, you can reference its upstream branch with the @{upstream} or @{u} shorthand. So if you\u2019re on the master branch and it\u2019s tracking origin/master, you can say something like git merge @{u} instead of git merge origin/master if you wish. Updating Remote Branches git remote update origin --prune This command updates the local list of remote branches ( origin ) and prunes (removes) any remote-tracking branches that no longer exist on the remote repository. git remote update is equivalent to git fetch , but it updates all remote-tracking branches instead of just the default one. --prune ensures that any remote-tracking branches that have been deleted on the remote repository are also deleted locally. git fetch --prune This command fetches updates from the remote repository and prunes (removes) any remote-tracking branches that no longer exist on the remote repository. It's similar to git remote update origin --prune , but it only updates the default remote and its branches. git config remote.origin.prune true Setting this configuration option makes --prune automatic for git fetch when fetching from the origin remote. With this configuration, running git fetch will automatically prune stale remote branches from the local copy. git fetch --all --prune --tags --prune-tags --progress This command fetches updates from all remotes ( --all ) and prunes (removes) any remote-tracking branches and tags that no longer exist on their respective remotes. --tags ensures that tags are also fetched. --prune-tags prunes any local tags that no longer exist on the remote. --progress displays progress information during the fetch operation.","title":"Remotes"},{"location":"Basics/git_remotes/#viewing-remote-information","text":"To see which remote servers you have configured, run the following command: git remote -v Displays the URLs of the remote repositories. It lists the shortnames of each remote handle you\u2019ve specified. If you\u2019ve cloned your repository, you should at least see origin\u2009\u2014\u2009that is the default name Git gives to the server you cloned from. The -v flag displays the full remote URLs. When you have multiple remotes then you can pull contributions from any of these remotes.","title":"Viewing Remote Information"},{"location":"Basics/git_remotes/#adding-a-remote","text":"Here\u2019s how to add a new remote explicitly. git remote add <remote-name> <remote-url> git remote add origin https://github.com/user/repo.git Adds a remote repository with a given name and URL. Now you can use the string origin on the command line in lieu of the whole URL. For example, if you want to fetch all the information from the remote repository, you can use: git fetch origin","title":"Adding a Remote"},{"location":"Basics/git_remotes/#fetching-changes-from-a-remote","text":"The command goes out to that remote project and pulls down all the data from that remote project that you don\u2019t have yet. After you do this, you should have references to all the branches from that remote, which you can merge in or inspect at any time. git fetch <remote-name> git fetch origin Fetches changes from all branches in the remote repository but does not merge them into the local branch. git fetch <remote-name> <branch-name> git fetch origin main Fetches changes from the main branch in the remote repository and merges them into the local branch.","title":"Fetching Changes from a Remote"},{"location":"Basics/git_remotes/#pulling-changes-from-a-remote","text":"git pull <remote-name> <branch-name> git pull origin main Fetches changes from the remote repository and merges them into the local branch. From Git version 2.27 onward, git pull will give a warning if the pull.rebase variable is not set. Git will keep warning you until you set the variable. If you want the default behavior of Git (fast-forward if possible, else create a merge commit): git config --global pull.rebase \"false\" If you want to rebase when pulling: git config --global pull.rebase \"true\"","title":"Pulling Changes from a Remote"},{"location":"Basics/git_remotes/#pushing-changes-to-a-remote","text":"When you have your project at a point that you want to share, you have to push it upstream. The command for this is simple. git push <remote-name> <branch-name> git push origin main Pushes local commits to the remote repository. This command works only if you cloned from a server to which you have write access and if nobody has pushed in the meantime. If you and someone else clone at the same time and they push upstream and then you push upstream, your push will rightly be rejected. You\u2019ll have to fetch their work first and incorporate it into yours before you\u2019ll be allowed to push.","title":"Pushing Changes to a Remote"},{"location":"Basics/git_remotes/#creating-a-branch-in-a-remote-repository","text":"git push <remote-name> <local-branch-name>:<remote-branch-name> git push origin feature-branch:feature-branch Creates a new branch in the remote repository based on the local branch.","title":"Creating a Branch in a Remote Repository"},{"location":"Basics/git_remotes/#cloning-a-repository","text":"git clone <remote-url> git clone https://github.com/user/repo.git Creates a local copy of a remote repository.","title":"Cloning a Repository"},{"location":"Basics/git_remotes/#renaming-a-remote","text":"git remote rename <old-name> <new-name> git remote rename origin upstream Renames an existing remote.","title":"Renaming a Remote"},{"location":"Basics/git_remotes/#removing-a-remote","text":"git remote remove <remote-name> git remote remove origin Removes a remote from the list of remotes.","title":"Removing a Remote"},{"location":"Basics/git_remotes/#inspecting-remote-branches","text":"git branch -r Lists remote branches. The git remote show command is used to display information about a specific remote repository. It provides details such as the URL of the remote repository, the branches it tracks, and additional information about the remote branches. git remote show <remote-name> git remote show origin The output of git remote show <remote-name> typically includes the following information: Remote URL: The URL of the remote repository. Fetch URL: The URL used by git fetch to fetch from the remote repository. This may differ from the remote URL if the repository supports fetching from a different location. Push URL: The URL used by git push to push to the remote repository. This may differ from the remote URL if the repository supports pushing to a different location. Remote branches: Lists the branches present in the remote repository. Local branch configured for git pull : Indicates the local branch that git pull will merge into. Local refs configured for git push : Indicates the local branch that git push will push to. Tracking information for each branch: Shows information about the local branch's relationship with the remote branches. This includes the branch name, the remote branch it tracks, whether it is up to date, and the number of commits behind or ahead. * remote origin Fetch URL: https://github.com/user/repo.git Push URL: https://github.com/user/repo.git HEAD branch: main Remote branches: main tracked feature tracked Local branch configured for 'git pull': main merges with remote main Local refs configured for 'git push': main pushes to main (up to date) feature pushes to feature (local out of date) The git remote show command is useful for inspecting the configuration and status of a remote repository. It helps in understanding how local branches are synchronized with remote branches. The output provides valuable information for managing and coordinating work with remote repositories. Using git remote show can provide insights into the state of your remote repository, aiding in decision-making when performing operations such as fetching, pulling, or pushing changes.","title":"Inspecting Remote Branches"},{"location":"Basics/git_remotes/#tracking-branches","text":"Checking out a local branch from a remote-tracking branch automatically creates what is called a \u201ctracking branch\u201d (and the branch it tracks is called an \u201cupstream branch\u201d). Tracking branches are local branches that have a direct relationship to a remote branch. If you\u2019re on a tracking branch and type git pull, Git automatically knows which server to fetch from and which branch to merge in. When you clone a repository, it generally automatically creates a master branch that tracks origin/master. However, you can set up other tracking branches if you wish\u2009\u2014\u2009ones that track branches on other remotes, or don\u2019t track the master branch. git checkout -b <branch> <remote>/<branch> This is a common enough operation that Git provides the --track shorthand: git checkout --track origin/hotfix In fact, this is so common that there\u2019s even a shortcut for that shortcut. If the branch name you\u2019re trying to checkout (a) doesn\u2019t exist and (b) exactly matches a name on only one remote, Git will create a tracking branch for you: git checkout hotfix To set up a local branch with a different name than the remote branch, you can easily use the first version with a different local branch name: git checkout -b htfx origin/hotfix Now, your local branch htfx will automatically pull from origin/hotfix. If you already have a local branch and want to set it to a remote branch you just pulled down, or want to change the upstream branch you\u2019re tracking, you can use the -u or --set-upstream-to option to git branch to explicitly set it at any time. git branch -u origin/hotfix Upstream shorthand When you have a tracking branch set up, you can reference its upstream branch with the @{upstream} or @{u} shorthand. So if you\u2019re on the master branch and it\u2019s tracking origin/master, you can say something like git merge @{u} instead of git merge origin/master if you wish.","title":"Tracking Branches"},{"location":"Basics/git_remotes/#updating-remote-branches","text":"git remote update origin --prune This command updates the local list of remote branches ( origin ) and prunes (removes) any remote-tracking branches that no longer exist on the remote repository. git remote update is equivalent to git fetch , but it updates all remote-tracking branches instead of just the default one. --prune ensures that any remote-tracking branches that have been deleted on the remote repository are also deleted locally. git fetch --prune This command fetches updates from the remote repository and prunes (removes) any remote-tracking branches that no longer exist on the remote repository. It's similar to git remote update origin --prune , but it only updates the default remote and its branches. git config remote.origin.prune true Setting this configuration option makes --prune automatic for git fetch when fetching from the origin remote. With this configuration, running git fetch will automatically prune stale remote branches from the local copy. git fetch --all --prune --tags --prune-tags --progress This command fetches updates from all remotes ( --all ) and prunes (removes) any remote-tracking branches and tags that no longer exist on their respective remotes. --tags ensures that tags are also fetched. --prune-tags prunes any local tags that no longer exist on the remote. --progress displays progress information during the fetch operation.","title":"Updating Remote Branches"},{"location":"Basics/git_stage/","text":"The Lifecycle of Git files Understanding the lifecycle of the status of files in Git is crucial for effectively managing changes in your repository. The lifecycle consists of several stages that files can transition through as you work with Git. These stages are reflected in the output of git status and represent the state of files in relation to the repository. Transition between Stages: Files transition between these stages as you work with Git commands like git add , git commit , and others. Workflow: The typical workflow involves modifying files in the working directory, staging the changes with git add , and committing the changes with git commit . Visibility: Use git status to view the current status of files in your repository and identify which stage they are in. Stage Description Representation Action Untracked Files that exist in your working directory but are not yet tracked by Git. These files have not been added to the repository. Shown in red in the output of git status . Use git add <file> to stage untracked files for the next commit. Tracked (or Modified) Files that have been modified in the working directory after being staged or committed. Shown in red in the output of git status . Use git add <file> to stage the modified files, then commit the changes with git commit . Deleted Files that have been deleted from the working directory after being staged or committed. Shown in red in the output of git status . Use git add <file> to stage the deletion, then commit the changes with git commit . Renamed or Moved Files that have been renamed or moved in the working directory after being staged or committed. Shown as both deleted and untracked files in the output of git status . Use git add <file> to stage the rename or move, then commit the changes with git commit . Staged (or Indexed) Files that have been added to the staging area. These changes are ready to be included in the next commit. Shown in green in the output of git status . Use git commit to create a commit containing the staged changes. Committed (or Unmodified) Files are stored securely in the Git repository. They are unchanged and represent a specific snapshot in the project's history. Files that have not been modified since the last commit. Typically not displayed in the output of git status unless using certain flags. No action required unless you intend to stage or modify the files. The working tree is a single checkout of one version of the project. These files are pulled out of the compressed database in the Git directory and placed on disk for you to use or modify. The staging area is a file, generally contained in your Git directory, that stores information about what will go into your next commit. The Git directory is where Git stores the metadata and object database for your project. This is the most important part of Git, and it is what is copied when you clone a repository from another computer. Working with snapshots and the Git staging area For the basic workflow of staging content and committing it to your history, there are only a few basic commands. Command Example git status git status git add git add myfile.txt git diff git diff git commit git commit -m \"Add new feature\" Snapshooting The difference between Git's snapshooting and delta-based version control systems lies in how git store and track changes within a repository. Git's Snapshooting Git is a distributed version control system (DVCS) that operates based on snapshots of the entire repository at each point in time. When a commit is made in Git, the entire state of the project at that moment is captured as a snapshot, including all files and their contents. Each commit creates a new snapshot, and Git tracks the changes between snapshots rather than individual file changes. Advantages: Offers robustness and data integrity since each commit is self-contained and immutable. Allows for efficient branching and merging operations since entire snapshots are managed independently. Facilitates offline work and collaboration by enabling users to work with their local repositories and synchronize changes later. Delta-based Version Control (CVS, Subversion, Perforce) Delta-based version control systems track changes by storing the differences (or deltas) between successive versions of a file or repository. Instead of storing complete snapshots of files or repositories, delta-based systems store the changes (insertions, deletions, modifications) made to files over time. Each new version is represented as a set of changes applied to the previous version. Advantages: Can be more space-efficient for repositories with large binary files or frequent, small changes since only the differences are stored. Allows for quicker network operations when transmitting changes since only the deltas need to be transferred. May provide more granular control over individual file versions, especially for large files with small modifications. Key Differences Granularity: Git's snapshot-based approach captures the entire state of the repository at each commit, offering a holistic view of the project's history. Delta-based systems track changes at a finer granularity, focusing on individual file modifications. Efficiency: Git's approach can be less space-efficient for repositories with frequent changes or large binary files since it stores complete snapshots. Delta-based systems may offer better efficiency in such cases by only storing the differences between versions. Complexity: Managing deltas and applying them to reconstruct files can introduce complexity and potential performance overhead in delta-based systems. Git's snapshot-based approach simplifies operations like branching and merging since each commit represents a complete, self-contained snapshot. Network Operations: Git's approach may lead to larger repository sizes due to storing complete snapshots, but it offers efficient network operations since it transfers complete commits during push and pull operations. Delta-based systems may have smaller repository sizes but may require more processing to reconstruct files during network operations. Overall, Git's snapshot-based approach provides robustness, simplicity, and efficiency for version control, making it a popular choice for software development projects of all sizes. Delta-based version control systems offer advantages in specific use cases where space efficiency or granular control over individual file versions is paramount. Git doesn\u2019t store data as a series of changesets or differences, but instead as a series of snapshots. When you make a commit, Git stores a commit object that contains a pointer to the snapshot of the content you staged. This object also contains the author\u2019s name and email address, the message that you typed, and pointers to the commit or commits that directly came before this commit (its parent or parents): zero parents for the initial commit, one parent for a normal commit, and multiple parents for a commit that results from a merge of two or more branches. Let\u2019s assume that you have a directory containing three files, and you stage them all and commit. Staging the files computes a checksum for each one (the SHA-1 hash), stores that version of the file in the Git repository (Git refers to them as blobs), and adds that checksum to the staging area: $ git add . $ git commit -m \"initial commit\" When you create the commit by running git commit, Git checksums each subdirectory (in this case, just the root project directory) and stores them as a tree object in the Git repository. Git then creates a commit object that has the metadata and a pointer to the root project tree so it can re-create that snapshot when needed. Your Git repository now contains five objects: three blobs (each representing the contents of one of the three files), one tree that lists the contents of the directory and specifies which file names are stored as which blobs, and one commit with the pointer to that root tree and all the commit metadata. If you make some changes and commit again, the next commit stores a pointer to the commit that came immediately before it. A branch in Git is simply a lightweight movable pointer to one commit. The default branch name in Git is master. As you start making commits, you\u2019re given a master branch that points to the last commit you made. Every time you commit, the master branch pointer moves forward automatically. The pointer HEAD tells you where you are in the repository. When you switch branches, HEAD moves to the tip of the new branch. Fore more details on branches and their history, see Git Branching . git status Shows the status of your working directory, indicating which files are modified, untracked, and staged for the next commit. git status This command provides a detailed summary of the changes in your working directory. Files listed under \"Changes not staged for commit\" are modified but not staged, and files under \"Changes to be committed\" are staged for the next commit. git add Adds changes in the specified file to the staging area, preparing them for the next commit. # Create or modify a file echo \"Hello, Git!\" > myfile.txt # Stage the changes git add myfile.txt This sequence of commands creates or modifies myfile.txt and stages the changes for the next commit. Use git add . to stage all changes in the working directory. git diff The git diff command is used when you want to see differences between any two trees. This could be the difference between your working environment and your staging area (git diff by itself), between your staging area and your last commit (git diff --staged), or between two commits (git diff master branchB). # Make changes to myfile.txt echo \"Updated content\" >> myfile.txt # View the differences git diff This command displays the unstaged changes in myfile.txt since the last commit. git diff --staged Shows the differences between the staging area and the last commit (changes that are staged but not yet committed). # Stage the changes in myfile.txt git add myfile.txt # View the differences in the staging area git diff --staged This command displays the changes that are currently staged for the next commit. git difftool The git difftool command simply launches an external tool to show you the difference between two trees in case you want to use something other than the built in git diff command. P4Merge For example, P4Merge is a visual diff and merge tool provided by Perforce. It offers a user-friendly interface for comparing and merging files and directories, making it a popular choice among developers and teams working with version control systems like Git. Here are some key features of P4Merge: Visual Diffing: P4Merge provides a graphical representation of the differences between files, allowing users to easily identify changes with color-coded highlights and line-by-line comparisons. Three-Way Merge: It supports three-way merging, which is essential for resolving conflicts that arise during collaborative development. P4Merge intelligently combines changes from two different branches or versions with a common ancestor, helping users reconcile differences efficiently. Image Comparison: In addition to text-based files, P4Merge can compare and merge images, making it suitable for projects involving graphical assets or multimedia content. Folder Diff: P4Merge can compare entire directories, displaying side-by-side comparisons of files within the folders. This feature is useful for understanding the overall differences between two directory structures and identifying missing or added files. Customizable Settings: Users can customize various aspects of P4Merge, such as colors, fonts, and keyboard shortcuts, to tailor the tool to their preferences and workflow. VS Code The git difftool command can be used with VS Code's diff and merge capabilities. The Diff editor has a separate gutter in the middle, which enables you to Stage or Revert changes code blocks. If you select a block of text, you can revert or stage the changes that are included in the selection. You can diff any two files by first right clicking on a file in the Explorer or OPEN EDITORS list and selecting Select for Compare and then right-click on the second file to compare with and select Compare with 'file_name_you_chose'. Alternatively from the keyboard hit Ctrl+Shift+P and select File: Compare Active File With and you will be presented with a list of recent files. There is an Accessible Diff Viewer in the Diff editor that presents changes in a unified patch format. You can navigate between changes with Go to Next Difference (F7) and Go to Previous Difference (Shift+F7). Lines can be navigated with arrow keys and pressing Enter will jump back in the Diff editor and the selected line. This experience is especially helpful for screen reader users. git commit The git commit command in Git is a powerful tool for creating and committing changes. It has several options, each affecting different parts of the Git repository. git commit When you run git commit without any arguments, it opens your editor of choice to create a commit message. You can see that the default commit message contains the latest output of the git status command commented out and one empty line on top. You can remove these comments and type your commit message, or you can leave them there to help you remember what you\u2019re committing. When you exit the editor, Git creates your commit with that commit message (with the comments and diff stripped out). Alternatively, you can type your commit message inline with the commit command by specifying it after a -m flag. This commits the changes that are staged in the snapshot, with a descriptive commit message. # Commit the changes with a message git commit -m \"Add new feature\" This command creates a new commit with the staged changes and the specified commit message. Combine git add and git commit in one step using git commit -am \"[descriptive message]\" to stage and commit changes. For an even more explicit reminder of what you\u2019ve modified, you can pass the -v option to git commit. Doing so also puts the diff of your change in the editor so you can see exactly what changes you\u2019re committing. Committing Specific Files # Stage changes in specific files git add file1.txt file2.txt # Commit the changes with a message git commit -m \"Fix issues in file1.txt and file2.txt\" Here, only specific files ( file1.txt and file2.txt ) are staged and then committed with a message describing the fix. Amending the Last Commit # Make additional changes echo \"Additional content\" >> myfile.txt # Amend the last commit with new changes git add myfile.txt git commit --amend -m \"Update myfile.txt with additional content\" This example adds new content to myfile.txt and then amends the last commit with the additional changes. Interactive Commit # Interactively stage changes git add -i # Follow the interactive prompts to stage changes and commit Running git add -i opens an interactive mode where you can choose which changes to stage, unstage, or commit. This provides a more granular control over the commit process. Committing with Multiple Messages # Stage changes in files git add file1.txt file2.txt # Commit changes with multiple messages git commit -m \"Fix issues in file1.txt\" -m \"Add new feature in file2.txt\" You can use the -m option multiple times to provide multiple commit messages. Each -m adds a new paragraph to the commit message. Committing with a Future Date # Stage changes git add . # Commit with a future date git commit --date = \"2023-01-01T12:00:00\" -m \"Commit with a future date\" This example commits changes with a specified future date using the --date option. Committing Only Tracked Changes # Stage changes in tracked files git add -u # Commit only tracked changes git commit -m \"Commit tracked changes\" The git add -u command stages only tracked files, and then a commit is made with a message indicating the commit of tracked changes.","title":"Snapshotting"},{"location":"Basics/git_stage/#the-lifecycle-of-git-files","text":"Understanding the lifecycle of the status of files in Git is crucial for effectively managing changes in your repository. The lifecycle consists of several stages that files can transition through as you work with Git. These stages are reflected in the output of git status and represent the state of files in relation to the repository. Transition between Stages: Files transition between these stages as you work with Git commands like git add , git commit , and others. Workflow: The typical workflow involves modifying files in the working directory, staging the changes with git add , and committing the changes with git commit . Visibility: Use git status to view the current status of files in your repository and identify which stage they are in. Stage Description Representation Action Untracked Files that exist in your working directory but are not yet tracked by Git. These files have not been added to the repository. Shown in red in the output of git status . Use git add <file> to stage untracked files for the next commit. Tracked (or Modified) Files that have been modified in the working directory after being staged or committed. Shown in red in the output of git status . Use git add <file> to stage the modified files, then commit the changes with git commit . Deleted Files that have been deleted from the working directory after being staged or committed. Shown in red in the output of git status . Use git add <file> to stage the deletion, then commit the changes with git commit . Renamed or Moved Files that have been renamed or moved in the working directory after being staged or committed. Shown as both deleted and untracked files in the output of git status . Use git add <file> to stage the rename or move, then commit the changes with git commit . Staged (or Indexed) Files that have been added to the staging area. These changes are ready to be included in the next commit. Shown in green in the output of git status . Use git commit to create a commit containing the staged changes. Committed (or Unmodified) Files are stored securely in the Git repository. They are unchanged and represent a specific snapshot in the project's history. Files that have not been modified since the last commit. Typically not displayed in the output of git status unless using certain flags. No action required unless you intend to stage or modify the files. The working tree is a single checkout of one version of the project. These files are pulled out of the compressed database in the Git directory and placed on disk for you to use or modify. The staging area is a file, generally contained in your Git directory, that stores information about what will go into your next commit. The Git directory is where Git stores the metadata and object database for your project. This is the most important part of Git, and it is what is copied when you clone a repository from another computer. Working with snapshots and the Git staging area For the basic workflow of staging content and committing it to your history, there are only a few basic commands. Command Example git status git status git add git add myfile.txt git diff git diff git commit git commit -m \"Add new feature\"","title":"The Lifecycle of Git files"},{"location":"Basics/git_stage/#snapshooting","text":"The difference between Git's snapshooting and delta-based version control systems lies in how git store and track changes within a repository. Git's Snapshooting Git is a distributed version control system (DVCS) that operates based on snapshots of the entire repository at each point in time. When a commit is made in Git, the entire state of the project at that moment is captured as a snapshot, including all files and their contents. Each commit creates a new snapshot, and Git tracks the changes between snapshots rather than individual file changes. Advantages: Offers robustness and data integrity since each commit is self-contained and immutable. Allows for efficient branching and merging operations since entire snapshots are managed independently. Facilitates offline work and collaboration by enabling users to work with their local repositories and synchronize changes later. Delta-based Version Control (CVS, Subversion, Perforce) Delta-based version control systems track changes by storing the differences (or deltas) between successive versions of a file or repository. Instead of storing complete snapshots of files or repositories, delta-based systems store the changes (insertions, deletions, modifications) made to files over time. Each new version is represented as a set of changes applied to the previous version. Advantages: Can be more space-efficient for repositories with large binary files or frequent, small changes since only the differences are stored. Allows for quicker network operations when transmitting changes since only the deltas need to be transferred. May provide more granular control over individual file versions, especially for large files with small modifications. Key Differences Granularity: Git's snapshot-based approach captures the entire state of the repository at each commit, offering a holistic view of the project's history. Delta-based systems track changes at a finer granularity, focusing on individual file modifications. Efficiency: Git's approach can be less space-efficient for repositories with frequent changes or large binary files since it stores complete snapshots. Delta-based systems may offer better efficiency in such cases by only storing the differences between versions. Complexity: Managing deltas and applying them to reconstruct files can introduce complexity and potential performance overhead in delta-based systems. Git's snapshot-based approach simplifies operations like branching and merging since each commit represents a complete, self-contained snapshot. Network Operations: Git's approach may lead to larger repository sizes due to storing complete snapshots, but it offers efficient network operations since it transfers complete commits during push and pull operations. Delta-based systems may have smaller repository sizes but may require more processing to reconstruct files during network operations. Overall, Git's snapshot-based approach provides robustness, simplicity, and efficiency for version control, making it a popular choice for software development projects of all sizes. Delta-based version control systems offer advantages in specific use cases where space efficiency or granular control over individual file versions is paramount. Git doesn\u2019t store data as a series of changesets or differences, but instead as a series of snapshots. When you make a commit, Git stores a commit object that contains a pointer to the snapshot of the content you staged. This object also contains the author\u2019s name and email address, the message that you typed, and pointers to the commit or commits that directly came before this commit (its parent or parents): zero parents for the initial commit, one parent for a normal commit, and multiple parents for a commit that results from a merge of two or more branches. Let\u2019s assume that you have a directory containing three files, and you stage them all and commit. Staging the files computes a checksum for each one (the SHA-1 hash), stores that version of the file in the Git repository (Git refers to them as blobs), and adds that checksum to the staging area: $ git add . $ git commit -m \"initial commit\" When you create the commit by running git commit, Git checksums each subdirectory (in this case, just the root project directory) and stores them as a tree object in the Git repository. Git then creates a commit object that has the metadata and a pointer to the root project tree so it can re-create that snapshot when needed. Your Git repository now contains five objects: three blobs (each representing the contents of one of the three files), one tree that lists the contents of the directory and specifies which file names are stored as which blobs, and one commit with the pointer to that root tree and all the commit metadata. If you make some changes and commit again, the next commit stores a pointer to the commit that came immediately before it. A branch in Git is simply a lightweight movable pointer to one commit. The default branch name in Git is master. As you start making commits, you\u2019re given a master branch that points to the last commit you made. Every time you commit, the master branch pointer moves forward automatically. The pointer HEAD tells you where you are in the repository. When you switch branches, HEAD moves to the tip of the new branch. Fore more details on branches and their history, see Git Branching .","title":"Snapshooting"},{"location":"Basics/git_stage/#git-status","text":"Shows the status of your working directory, indicating which files are modified, untracked, and staged for the next commit. git status This command provides a detailed summary of the changes in your working directory. Files listed under \"Changes not staged for commit\" are modified but not staged, and files under \"Changes to be committed\" are staged for the next commit.","title":"git status"},{"location":"Basics/git_stage/#git-add","text":"Adds changes in the specified file to the staging area, preparing them for the next commit. # Create or modify a file echo \"Hello, Git!\" > myfile.txt # Stage the changes git add myfile.txt This sequence of commands creates or modifies myfile.txt and stages the changes for the next commit. Use git add . to stage all changes in the working directory.","title":"git add"},{"location":"Basics/git_stage/#git-diff","text":"The git diff command is used when you want to see differences between any two trees. This could be the difference between your working environment and your staging area (git diff by itself), between your staging area and your last commit (git diff --staged), or between two commits (git diff master branchB). # Make changes to myfile.txt echo \"Updated content\" >> myfile.txt # View the differences git diff This command displays the unstaged changes in myfile.txt since the last commit.","title":"git diff"},{"location":"Basics/git_stage/#git-diff-staged","text":"Shows the differences between the staging area and the last commit (changes that are staged but not yet committed). # Stage the changes in myfile.txt git add myfile.txt # View the differences in the staging area git diff --staged This command displays the changes that are currently staged for the next commit.","title":"git diff --staged"},{"location":"Basics/git_stage/#git-difftool","text":"The git difftool command simply launches an external tool to show you the difference between two trees in case you want to use something other than the built in git diff command.","title":"git difftool"},{"location":"Basics/git_stage/#git-commit","text":"The git commit command in Git is a powerful tool for creating and committing changes. It has several options, each affecting different parts of the Git repository. git commit When you run git commit without any arguments, it opens your editor of choice to create a commit message. You can see that the default commit message contains the latest output of the git status command commented out and one empty line on top. You can remove these comments and type your commit message, or you can leave them there to help you remember what you\u2019re committing. When you exit the editor, Git creates your commit with that commit message (with the comments and diff stripped out). Alternatively, you can type your commit message inline with the commit command by specifying it after a -m flag. This commits the changes that are staged in the snapshot, with a descriptive commit message. # Commit the changes with a message git commit -m \"Add new feature\" This command creates a new commit with the staged changes and the specified commit message. Combine git add and git commit in one step using git commit -am \"[descriptive message]\" to stage and commit changes. For an even more explicit reminder of what you\u2019ve modified, you can pass the -v option to git commit. Doing so also puts the diff of your change in the editor so you can see exactly what changes you\u2019re committing.","title":"git commit"},{"location":"Basics/git_stage/#committing-specific-files","text":"# Stage changes in specific files git add file1.txt file2.txt # Commit the changes with a message git commit -m \"Fix issues in file1.txt and file2.txt\" Here, only specific files ( file1.txt and file2.txt ) are staged and then committed with a message describing the fix.","title":"Committing Specific Files"},{"location":"Basics/git_stage/#amending-the-last-commit","text":"# Make additional changes echo \"Additional content\" >> myfile.txt # Amend the last commit with new changes git add myfile.txt git commit --amend -m \"Update myfile.txt with additional content\" This example adds new content to myfile.txt and then amends the last commit with the additional changes.","title":"Amending the Last Commit"},{"location":"Basics/git_stage/#interactive-commit","text":"# Interactively stage changes git add -i # Follow the interactive prompts to stage changes and commit Running git add -i opens an interactive mode where you can choose which changes to stage, unstage, or commit. This provides a more granular control over the commit process.","title":"Interactive Commit"},{"location":"Basics/git_stage/#committing-with-multiple-messages","text":"# Stage changes in files git add file1.txt file2.txt # Commit changes with multiple messages git commit -m \"Fix issues in file1.txt\" -m \"Add new feature in file2.txt\" You can use the -m option multiple times to provide multiple commit messages. Each -m adds a new paragraph to the commit message.","title":"Committing with Multiple Messages"},{"location":"Basics/git_stage/#committing-with-a-future-date","text":"# Stage changes git add . # Commit with a future date git commit --date = \"2023-01-01T12:00:00\" -m \"Commit with a future date\" This example commits changes with a specified future date using the --date option.","title":"Committing with a Future Date"},{"location":"Basics/git_stage/#committing-only-tracked-changes","text":"# Stage changes in tracked files git add -u # Commit only tracked changes git commit -m \"Commit tracked changes\" The git add -u command stages only tracked files, and then a commit is made with a message indicating the commit of tracked changes.","title":"Committing Only Tracked Changes"},{"location":"Basics/git_start/","text":"This section describes the process of initializing a Git project. You typically obtain a Git repository in one of two ways: you can take a local directory that is currently not under version control, and turn it into a Git repository, or you can clone an existing Git repository from elsewhere. In either case, you end up with a Git repository on your local machine, ready for work. Initialize the Git Repository Before initializing a Git repository, navigate to the directory of your existing project or create a new project folder. Open a terminal or command prompt and change into the project directory: cd path/to/your/project Initializing a Git repository involves setting up Git to manage your project's version control. It creates a hidden subfolder within your project that houses the internal data structure required for version control. Version control allows you to track changes, collaborate with others, and revert to previous states of your project. Initializing a Git repository is the first step to harnessing these benefits. Run the following command to initialize a Git repository in your project folder: git init After running git init , Git creates a .git directory in your project folder. This directory contains all the necessary files for version control.The .git directory is where Git stores information about your project's history, branches, configurations, and more. git init Options Initialize a New Git Repository git init Initializes a new Git repository in the current working directory. Initialize in a Specific Directory git init <directory> Initializes a new Git repository in the specified directory. Example: git init my_project git init Flags --bare The git init --bare command is used to create a new Git repository with a bare structure. A bare repository does not have a working directory like a typical Git repository. Instead, it only contains the version history, branches, tags, and configuration files. This type of repository is commonly used for remote repositories in a centralized workflow, where multiple developers collaborate on the same codebase. To create a bare repository using git init --bare , you simply run the command in the desired location where you want to create the repository: git init --bare <repository_name> <repository_name> : The name of the bare repository directory to be created. This parameter is optional, and if not provided, Git will create the repository in the current directory. Characteristics of a Bare Repository No Working Directory: Unlike a regular Git repository, a bare repository does not have a working directory where you can edit files. It only contains the version history and other metadata. Storage of Commits and Branches: The bare repository stores commits, branches, tags, and other version control information directly in its .git directory, without the need for a separate working directory. Remote Access: Bare repositories are typically used as central repositories that multiple developers can push changes to and pull changes from. They are accessed over a network, often via protocols like SSH or HTTP. Collaboration: Bare repositories facilitate collaboration by serving as a central point where developers can share their changes and synchronize their work. Use Cases Centralized Workflow: In a centralized workflow, a bare repository is set up on a server or a central location accessible to all team members. Developers push their changes to this repository, and other team members pull changes from it. Remote Hosting Services Many remote hosting services, such as GitHub, GitLab, and Bitbucket, use bare repositories to store project code. When you create a new repository on one of these platforms, it is typically initialized as a bare repository on the server. Advantages of Bare Repositories Efficient Collaboration: Bare repositories simplify collaboration by providing a central location for sharing changes and synchronizing work among team members. Reduced Disk Usage: Bare repositories consume less disk space compared to regular repositories since they do not store individual working copies of files. Security: Since a bare repository does not have a working directory, it cannot accidentally expose sensitive information or execute malicious code. It is not recommended to work directly with a bare repository on your local machine. Instead, clone the bare repository to create a working copy with a proper working directory where you can edit files and commit changes. --template=<tmplt_dir> git init --template = <template_directory> Initializes a new Git repository using the specified template directory. This can be useful for setting up a custom project structure. Example: git init --template = /path/to/custom/template The git init --template command is used to initialize a new Git repository with a custom template directory. This feature allows you to provide a set of predefined files and directories that will be automatically copied into the newly initialized repository. It can be useful for setting up a standardized project structure, including default configuration files, README templates, or other resources commonly used in your projects. Let's say you have a template directory named my_template with the following structure: my_template/ \u251c\u2500\u2500 .gitignore \u251c\u2500\u2500 README.md \u2514\u2500\u2500 scripts/ \u2514\u2500\u2500 setup.sh To initialize a new Git repository using this template, you would run the following command: git init --template = my_template After running this command, Git will create a new repository in the current directory, copying the files and directories from the my_template directory into the newly created repository. The resulting repository will have the same structure as the template directory, including the .gitignore file, README.md , and the scripts directory with its contents. Use Cases: Standardized Project Setup: You can use a template directory to define a standardized project structure, including default configuration files, license files, and directory layouts. Consistent READMEs: By including a README template in the template directory, you can ensure that all new repositories start with a consistent README file that includes essential project information. Custom Gitignore Files: Including a .gitignore file in the template directory allows you to specify default patterns for ignoring files and directories commonly found in your projects. The --template option is available in Git version 1.7.1 and later. You can customize the template directory to suit your specific needs, including any files or directories that you want to include in all new repositories. Using git init --template allows you to streamline the process of setting up new Git repositories by providing a standardized starting point for your projects. It promotes consistency and helps ensure that all new repositories adhere to your project's conventions and best practices. --separate-git-dir=<git_dir> The git init --separate-git-dir=<git_dir> command is used to initialize a new Git repository while specifying a separate directory ( <git_dir> ) to store the Git metadata ( .git directory). This allows you to decouple the location of the repository's working directory from the location of the .git directory, providing flexibility in managing your Git setup. git init --separate-git-dir = <git_dir> [ <working_dir> ] <git_dir> : The path to the directory where Git should store its metadata ( .git directory). <working_dir> : (Optional) The path to the directory where the working directory should be created. If not provided, the current directory is used. Let's say you want to create a new Git repository with the working directory located in the ~/projects/my_project directory and the Git metadata stored in the ~/git/my_project.git directory. You would use the following command: git init --separate-git-dir = ~/git/my_project.git ~/projects/my_project After running this command, Git will initialize the repository in the specified working directory ( ~/projects/my_project ) and create the .git directory with all the necessary metadata in the separate location ( ~/git/my_project.git ). Decoupling Working Directory and Git Metadata: This command allows you to separate the working directory from the Git metadata, which can be useful in various scenarios, such as managing multiple working directories that share the same Git repository. Centralized Git Metadata Storage: You can centralize the storage of Git metadata by specifying a shared location for the .git directory, which can be accessed by multiple working directories. Custom Git Metadata Location: You may have specific requirements or constraints that necessitate storing the Git metadata in a custom location, such as a network drive or a designated system directory. When using git init --separate-git-dir , the specified <git_dir> directory must not exist prior to running the command. Git will create the directory and initialize it as a new Git repository. If <working_dir> is not provided, the current directory is used as the working directory. Using git init --separate-git-dir=<git_dir> provides flexibility in managing your Git repositories by allowing you to customize the location of the Git metadata independently of the working directory. This can be beneficial in various workflows and setups, especially when dealing with multiple repositories or centralized storage of Git metadata. --quiet or -q git init --quiet Suppresses all output during the initialization process. Example: git init --quiet Using VSCode If your workspace is on your local machine, you can enable Git source control by creating a Git repository with the Initialize Repository command. When VS Code doesn't detect an existing Git repository, the Source Control view will give you the options to Initialize Repository or Publish to GitHub. You can also run the Git: Initialize Repository and Publish to GitHub commands from the Command Palette (Ctrl+Shift+P). Running Initialize Repository will create the necessary Git repository metadata files and show your workspace files as untracked changes ready to be staged. Publish to GitHub will directly publish your workspace folder to a GitHub repository, allowing you to choose between private and public repositories. Clone an existing Git Repository The git clone command is used to create a copy of a remote Git repository. It copies the entire repository, including the commit history, branches, and files, to your local machine. Here's a detailed explanation of the git clone command along with some commonly used flags and options: 1. git clone <repository_url> Clones a remote Git repository to your local machine in the folder that you are in. To obtain a local copy of a project, collaborate with others, or contribute to open-source projects. git clone <repository_url> Example: git clone https://github.com/example/repo.git 2. git clone --branch <branch_name> Clones a specific branch from the remote repository. To clone a specific branch instead of the default branch (usually master or main ). git clone --branch <branch_name> <repository_url> Example: git clone --branch develop https://github.com/example/repo.git 3. git clone --branch <branch_name> <repository_url> Clones a specific branch from the remote repository to a specific folder. To clone a specific branch instead of the default branch (usually master or main ) into a specific folder. git clone --branch <branch_name> <repository_url> <path/to/folder> Example: git clone --branch master git@github.com:ArceLopera/git_refresher.git mylocalrepo 4. git clone --depth <depth> Clones a specified number of commits from the remote repository, creating a shallow clone.To reduce the size of the clone by fetching only a limited commit history. git clone --depth <depth> <repository_url> Example: git clone --depth 1 https://github.com/example/repo.git 5. git clone --recursive Clones submodules along with the main repository. To clone and initialize submodules contained within the repository. git clone --recursive <repository_url> Example: git clone --recursive https://github.com/example/repo.git 6. git clone --mirror When cloning a Git repository, only the default branch (usually main or master) is checked out by default, but all other branches are downloaded. If you want to explicitly ensure all branches are cloned and available locally, you can use the --mirror flag. This command allows you to upload your mirrored repository to another remote repository after converting it to a regular repository: 1. Mirror Clone the Original Repository Start by creating a bare mirror clone of the original repository: git clone --mirror <original-repository-url> repo.git This clones the repository into repo.git , containing all branches, tags, and references. 2. Convert the Bare Repository to a Regular Repository Navigate into the mirrored repository: cd repo.git Unset the bare configuration: git config --unset core.bare Move .git into a new working directory: cd .. mkdir repo mv repo.git repo/.git cd repo Check out the default branch to create the working directory: git checkout <branch-name> Replace <branch-name> with the default branch name, such as main or master . 3. Prepare for Uploading to a New GitLab Repository Create a New Repository in GitLab Go to your GitLab/Github instance and create a new repository. Copy the repository's SSH or HTTPS URL (e.g., git@gitlab.com:username/new-repo.git ). Set the New Repository as Remote In your local repository, remove the old remote (if any): git remote remove origin Add the new GitLab repository as the remote: git remote add origin <new-repository-url> Verify the remote URL: git remote -v 4. Push All Branches and Tags to the New Repository Push all branches to the new repository: git push --all origin Push all tags to the new repository: git push --tags origin 5. Verify the New Repository Go to the new GitLab repository in your browser. Confirm that all branches, tags, and files are present. 6. Optional: Set the Default Branch In the new GitLab repository, go to Settings > Repository . Set the default branch (e.g., main or master ). Summary of Commands Mirror clone the original repository : git clone --mirror <original-repository-url> repo.git Convert to a regular repository : cd repo.git git config --unset core.bare cd .. mkdir repo mv repo.git repo/.git cd repo git checkout <branch-name> Set up the new remote : git remote remove origin git remote add origin <new-repository-url> Push all branches and tags : git push --all origin git push --tags origin Verify and adjust settings in GitLab . This workflow ensures you upload a complete copy of the original repository, including all branches, tags, and history, to the new GitLab repository. this is called Mirror Clone and it is useful for maintaining an exact copy of the repository, including all refs. There is also Repository Export: Convenient for platform-managed repositories. Platforms like GitHub and GitLab provide backup or export options that include the full repository, including its .git directory. For GitLab: Go to the project settings. Use the Export project feature. Download the exported project, which includes the history. For GitHub: Use the Archive repository feature (if available) or manually download the .git directory. Finally an other strategy is to use Git Bundle : Ideal for transferring repositories when direct cloning is not possible (e.g., no network access).","title":"Starting a Project"},{"location":"Basics/git_start/#initialize-the-git-repository","text":"Before initializing a Git repository, navigate to the directory of your existing project or create a new project folder. Open a terminal or command prompt and change into the project directory: cd path/to/your/project Initializing a Git repository involves setting up Git to manage your project's version control. It creates a hidden subfolder within your project that houses the internal data structure required for version control. Version control allows you to track changes, collaborate with others, and revert to previous states of your project. Initializing a Git repository is the first step to harnessing these benefits. Run the following command to initialize a Git repository in your project folder: git init After running git init , Git creates a .git directory in your project folder. This directory contains all the necessary files for version control.The .git directory is where Git stores information about your project's history, branches, configurations, and more.","title":"Initialize the Git Repository"},{"location":"Basics/git_start/#git-init-options","text":"","title":"git init Options"},{"location":"Basics/git_start/#git-init-flags","text":"","title":"git init Flags"},{"location":"Basics/git_start/#-bare","text":"The git init --bare command is used to create a new Git repository with a bare structure. A bare repository does not have a working directory like a typical Git repository. Instead, it only contains the version history, branches, tags, and configuration files. This type of repository is commonly used for remote repositories in a centralized workflow, where multiple developers collaborate on the same codebase. To create a bare repository using git init --bare , you simply run the command in the desired location where you want to create the repository: git init --bare <repository_name> <repository_name> : The name of the bare repository directory to be created. This parameter is optional, and if not provided, Git will create the repository in the current directory. Characteristics of a Bare Repository No Working Directory: Unlike a regular Git repository, a bare repository does not have a working directory where you can edit files. It only contains the version history and other metadata. Storage of Commits and Branches: The bare repository stores commits, branches, tags, and other version control information directly in its .git directory, without the need for a separate working directory. Remote Access: Bare repositories are typically used as central repositories that multiple developers can push changes to and pull changes from. They are accessed over a network, often via protocols like SSH or HTTP. Collaboration: Bare repositories facilitate collaboration by serving as a central point where developers can share their changes and synchronize their work. Use Cases Centralized Workflow: In a centralized workflow, a bare repository is set up on a server or a central location accessible to all team members. Developers push their changes to this repository, and other team members pull changes from it. Remote Hosting Services Many remote hosting services, such as GitHub, GitLab, and Bitbucket, use bare repositories to store project code. When you create a new repository on one of these platforms, it is typically initialized as a bare repository on the server. Advantages of Bare Repositories Efficient Collaboration: Bare repositories simplify collaboration by providing a central location for sharing changes and synchronizing work among team members. Reduced Disk Usage: Bare repositories consume less disk space compared to regular repositories since they do not store individual working copies of files. Security: Since a bare repository does not have a working directory, it cannot accidentally expose sensitive information or execute malicious code. It is not recommended to work directly with a bare repository on your local machine. Instead, clone the bare repository to create a working copy with a proper working directory where you can edit files and commit changes.","title":"--bare"},{"location":"Basics/git_start/#-templatetmplt_dir","text":"git init --template = <template_directory> Initializes a new Git repository using the specified template directory. This can be useful for setting up a custom project structure. Example: git init --template = /path/to/custom/template The git init --template command is used to initialize a new Git repository with a custom template directory. This feature allows you to provide a set of predefined files and directories that will be automatically copied into the newly initialized repository. It can be useful for setting up a standardized project structure, including default configuration files, README templates, or other resources commonly used in your projects. Let's say you have a template directory named my_template with the following structure: my_template/ \u251c\u2500\u2500 .gitignore \u251c\u2500\u2500 README.md \u2514\u2500\u2500 scripts/ \u2514\u2500\u2500 setup.sh To initialize a new Git repository using this template, you would run the following command: git init --template = my_template After running this command, Git will create a new repository in the current directory, copying the files and directories from the my_template directory into the newly created repository. The resulting repository will have the same structure as the template directory, including the .gitignore file, README.md , and the scripts directory with its contents. Use Cases: Standardized Project Setup: You can use a template directory to define a standardized project structure, including default configuration files, license files, and directory layouts. Consistent READMEs: By including a README template in the template directory, you can ensure that all new repositories start with a consistent README file that includes essential project information. Custom Gitignore Files: Including a .gitignore file in the template directory allows you to specify default patterns for ignoring files and directories commonly found in your projects. The --template option is available in Git version 1.7.1 and later. You can customize the template directory to suit your specific needs, including any files or directories that you want to include in all new repositories. Using git init --template allows you to streamline the process of setting up new Git repositories by providing a standardized starting point for your projects. It promotes consistency and helps ensure that all new repositories adhere to your project's conventions and best practices.","title":"--template=&lt;tmplt_dir&gt;"},{"location":"Basics/git_start/#-separate-git-dirgit_dir","text":"The git init --separate-git-dir=<git_dir> command is used to initialize a new Git repository while specifying a separate directory ( <git_dir> ) to store the Git metadata ( .git directory). This allows you to decouple the location of the repository's working directory from the location of the .git directory, providing flexibility in managing your Git setup. git init --separate-git-dir = <git_dir> [ <working_dir> ] <git_dir> : The path to the directory where Git should store its metadata ( .git directory). <working_dir> : (Optional) The path to the directory where the working directory should be created. If not provided, the current directory is used. Let's say you want to create a new Git repository with the working directory located in the ~/projects/my_project directory and the Git metadata stored in the ~/git/my_project.git directory. You would use the following command: git init --separate-git-dir = ~/git/my_project.git ~/projects/my_project After running this command, Git will initialize the repository in the specified working directory ( ~/projects/my_project ) and create the .git directory with all the necessary metadata in the separate location ( ~/git/my_project.git ). Decoupling Working Directory and Git Metadata: This command allows you to separate the working directory from the Git metadata, which can be useful in various scenarios, such as managing multiple working directories that share the same Git repository. Centralized Git Metadata Storage: You can centralize the storage of Git metadata by specifying a shared location for the .git directory, which can be accessed by multiple working directories. Custom Git Metadata Location: You may have specific requirements or constraints that necessitate storing the Git metadata in a custom location, such as a network drive or a designated system directory. When using git init --separate-git-dir , the specified <git_dir> directory must not exist prior to running the command. Git will create the directory and initialize it as a new Git repository. If <working_dir> is not provided, the current directory is used as the working directory. Using git init --separate-git-dir=<git_dir> provides flexibility in managing your Git repositories by allowing you to customize the location of the Git metadata independently of the working directory. This can be beneficial in various workflows and setups, especially when dealing with multiple repositories or centralized storage of Git metadata.","title":"--separate-git-dir=&lt;git_dir&gt;"},{"location":"Basics/git_start/#-quiet-or-q","text":"git init --quiet Suppresses all output during the initialization process. Example: git init --quiet","title":"--quiet or -q"},{"location":"Basics/git_start/#using-vscode","text":"If your workspace is on your local machine, you can enable Git source control by creating a Git repository with the Initialize Repository command. When VS Code doesn't detect an existing Git repository, the Source Control view will give you the options to Initialize Repository or Publish to GitHub. You can also run the Git: Initialize Repository and Publish to GitHub commands from the Command Palette (Ctrl+Shift+P). Running Initialize Repository will create the necessary Git repository metadata files and show your workspace files as untracked changes ready to be staged. Publish to GitHub will directly publish your workspace folder to a GitHub repository, allowing you to choose between private and public repositories.","title":"Using VSCode"},{"location":"Basics/git_start/#clone-an-existing-git-repository","text":"The git clone command is used to create a copy of a remote Git repository. It copies the entire repository, including the commit history, branches, and files, to your local machine. Here's a detailed explanation of the git clone command along with some commonly used flags and options:","title":"Clone an existing Git Repository"},{"location":"Basics/git_start/#1-git-clone-repository_url","text":"Clones a remote Git repository to your local machine in the folder that you are in. To obtain a local copy of a project, collaborate with others, or contribute to open-source projects. git clone <repository_url>","title":"1. git clone &lt;repository_url&gt;"},{"location":"Basics/git_start/#2-git-clone-branch-branch_name","text":"Clones a specific branch from the remote repository. To clone a specific branch instead of the default branch (usually master or main ). git clone --branch <branch_name> <repository_url>","title":"2. git clone --branch &lt;branch_name&gt;"},{"location":"Basics/git_start/#3-git-clone-branch-branch_name-repository_url","text":"Clones a specific branch from the remote repository to a specific folder. To clone a specific branch instead of the default branch (usually master or main ) into a specific folder. git clone --branch <branch_name> <repository_url> <path/to/folder>","title":"3. git clone --branch &lt;branch_name&gt; &lt;repository_url&gt;"},{"location":"Basics/git_start/#4-git-clone-depth-depth","text":"Clones a specified number of commits from the remote repository, creating a shallow clone.To reduce the size of the clone by fetching only a limited commit history. git clone --depth <depth> <repository_url>","title":"4. git clone --depth &lt;depth&gt;"},{"location":"Basics/git_start/#5-git-clone-recursive","text":"Clones submodules along with the main repository. To clone and initialize submodules contained within the repository. git clone --recursive <repository_url>","title":"5. git clone --recursive"},{"location":"Basics/git_start/#6-git-clone-mirror","text":"When cloning a Git repository, only the default branch (usually main or master) is checked out by default, but all other branches are downloaded. If you want to explicitly ensure all branches are cloned and available locally, you can use the --mirror flag. This command allows you to upload your mirrored repository to another remote repository after converting it to a regular repository:","title":"6. git clone --mirror"},{"location":"Basics/git_undoingthings/","text":"Undoing changes in Git involves various commands and strategies, depending on the nature of the changes and the stage at which they are. Here is a comprehensive guide on common Git undo commands and strategies: Summary table of common Git undo commands and strategies: Action Command Description Undoing Commits git commit --amend Amend the last commit by adding new changes or modifying the commit message. git revert <commit-hash> Create a new commit that undoes changes introduced by a specific commit. git rebase -i <commit-hash> Open an interactive rebase session, allowing you to edit, squash, or drop commits. Undoing Uncommitted Changes git checkout -- file.txt Discard changes in a specific file, reverting it to the state in the last commit. git reset --hard Discard all uncommitted changes, reverting the working directory to the state of the last commit. Undoing Staged Changes git reset file.txt Unstage changes in a specific file, moving them back to the working directory. git reset --soft HEAD^ Undo the last commit, keeping changes staged in the working directory. git reset --mixed HEAD^ Undo the last commit, unstaging changes but keeping them in the working directory. git reset --hard HEAD^ Undo the last commit, discarding changes both in the commit and the working directory. Undoing Remote Changes git push --force origin <branch-name> Force push local changes to a remote branch (use with caution, as it rewrites remote history). Restoring Files git restore file.txt Restore the specified file to the state in the last commit (introduced in Git 2.23). Rewriting history git rebase main Apply any commits of the current branch ahead of the specified one. git filter-branch Rewrite branches to remove unwanted data Removing files git rm Remove files git mv Rename files git checkout -f [branch] Switch branches, discarding any local changes git clean -ffd Erase all untracked files and directories in the working directory Please note that some commands, like force push and hard reset, should be used with caution, especially when collaborating with others, as they can alter Git history. Always be mindful of the consequences and potential impacts on collaborators before executing these commands. 1. Undoing Commits git commit --amend , and git revert are all Git commands used to manipulate commit history, but they serve different purposes and are used in different scenarios. Amend the Last Commit git commit --amend git commit --amend is used to modify the most recent commit by adding or changing files or the commit message. It allows you to make corrections to the most recent commit before pushing it to the remote repository. Use git commit --amend when you want to make minor adjustments to the most recent commit, such as fixing typos in the commit message or adding files that were forgotten to be included. Only amend commits that are still local and have not been pushed somewhere. Amending previously pushed commits and force pushing the branch will cause problems for your collaborators. Reverting Commits git revert <commit-hash> This command creates a new commit that undoes the changes introduced by a specific commit. git revert is used to undo the changes introduced by a specific commit by creating a new commit that undoes those changes. It's a safe way to undo commits without altering the commit history. Use git revert when you want to undo the changes introduced by a particular commit while preserving the commit history. It's useful for reverting changes that have already been shared with others or pushed to a remote repository. Interactively Reverting or Editing Commits For more information, check out the Git Rebase practical guide. git rebase -i <commit-hash> This command opens an interactive rebase session, allowing you to edit, squash, or drop commits. The git rebase -i HEAD~6 command initiates an interactive rebase for the last six commits starting from the current HEAD . This allows you to modify, reorder, squash, or drop commits interactively before applying them onto a new base commit. Let's break down the components of this command: git rebase : The main command for reorganizing or combining commits. -i : Stands for \"interactive,\" which opens an interactive rebase session. HEAD~6 : Specifies the commit range to rebase. In this case, it's the last six commits from the current HEAD . git rebase -i HEAD~6 This command opens a text editor with a list of the last six commits in your default branch. The list might look something like this: pick abc123 Commit message 1 pick def456 Commit message 2 pick 789ghi Commit message 3 pick jkl012 Commit message 4 pick mno345 Commit message 5 pick pqr678 Commit message 6 In the interactive rebase editor, you can choose actions for each commit: pick : Keep the commit as is. reword : Change the commit message. edit : Pause for amending the commit. squash or fixup : Combine the commit with the previous one. drop : Remove the commit. Squashing Commits For example, to squash the last three commits into a single commit, you can modify the file to look like this: pick abc123 Commit message 1 pick def456 Commit message 2 squash 789ghi Commit message 3 squash jkl012 Commit message 4 squash mno345 Commit message 5 pick pqr678 Commit message 6 After saving and closing the file, Git will prompt you to modify the commit message for the new squashed commit. Interactive rebasing allows you to create a cleaner and more organized commit history. Use edit to pause at a specific commit and make changes (e.g., amend, add files, or reword the commit message). Always make sure to review and understand the changes you're making during an interactive rebase, as it rewrites commit history. Interactive rebasing is a powerful but potentially risky operation. Be cautious and ensure you have a backup or a way to recover your changes if needed. It\u2019s important to note that these commits are listed in the opposite order than you normally see them using the log command. If you run a log, you see something like this: git log --pretty = format: \"%h %s\" HEAD~6..HEAD pqr678 Commit message 6 mno345 Commit message 5 jkl012 Commit message 4 789ghi Commit message 3 def456 Commit message 2 abc123 Commit message 1 Notice the reverse order. The interactive rebase gives you a script that it\u2019s going to run. It will start at the commit you specify on the command line (HEAD~3) and replay the changes introduced in each of these commits from top to bottom. It lists the oldest at the top, rather than the newest, because that\u2019s the first one it will replay. You need to edit the script so that it stops at the commit you want to edit. To do so, change the word \u201cpick\u201d to the word \u201cedit\u201d for each of the commits you want the script to stop after. Remember to use git rebase --continue to continue the rebase. Reordering Commits You can also use interactive rebases to reorder or remove commits entirely. If you want to remove commits and/or change the order in which the other two commits are introduced, you can change the rebase script. pick def456 Commit message 2 pick abc123 Commit message 1 pick 789ghi Commit message 3 pick pqr678 Commit message 6 When you save and exit the editor, Git rewinds your branch to the parent of these commits, applies the specified commits in order, and then stops. You effectively change the order of those commits and remove commits completely. Splitting Commits Splitting a commit undoes a commit and then partially stages and commits as many times as commits you want to end up with. For example, suppose you want to split the middle commit of your three commits. Instead of \u201cCommit message 2 and 3\u201d, you want to split it into two commits: \u201cCommit message 2\u201d for the first, and \u201cCommit message 3\u201d for the second. You can do that in the rebase -i script by changing the instruction on the commit you want to split to \u201cedit\u201d: pick abc123 Commit message 1 pick def456 Commit message 2 and 3 edit 789ghi Commit message 4 Then, when the script drops you to the command line, you reset that commit, take the changes that have been reset, and create multiple commits out of them. When you save and exit the editor, Git rewinds to the parent of the first commit in your list, applies the first commit (abc123), applies the second (def456), and drops you to the console. There, you can do a mixed reset of that commit with git reset HEAD^, which effectively undoes that commit and leaves the modified files unstaged. Now you can stage and commit files until you have several commits, and run git rebase --continue when you\u2019re done. git reset HEAD^ git add README git commit -m 'Commit message 2' git add file2.txt git commit -m 'Commit message 3' git rebase --continue Then, git apply the third commit (def456) and you\u2019re done. This changes the SHA-1s of the three most recent commits in your list, so make sure no changed commit shows up in that list that you\u2019ve already pushed to a shared repository. Deleting Commits If you want to get rid of a commit, you can delete it using the rebase -i script. In the list of commits, put the word \u201cdrop\u201d before the commit you want to delete (or just delete that line from the rebase script). Because of the way Git builds commit objects, deleting or altering a commit will cause the rewriting of all the commits that follow it. The further back in your repo\u2019s history you go, the more commits will need to be recreated. This can cause lots of merge conflicts if you have many commits later in the sequence that depend on the one you just deleted. If you get partway through a rebase like this and decide it\u2019s not a good idea, you can always stop. Type git rebase --abort, and your repo will be returned to the state it was in before you started the rebase. If you finish a rebase and decide it\u2019s not what you want, you can use git reflog to recover an earlier version of your branch. filter-branch There is another history-rewriting option that you can use if you need to rewrite a larger number of commits in some scriptable way\u2009\u2014\u2009for instance, changing your email address globally or removing a file from every commit. The command is filter-branch, and it can rewrite huge swaths of your history, so you probably shouldn\u2019t use it unless your project isn\u2019t yet public and other people haven\u2019t based work off the commits you\u2019re about to rewrite. git filter-branch has many pitfalls, and is no longer the recommended way to rewrite history. Instead, consider using git-filter-repo, which is a Python script that does a better job for most applications where you would normally turn to filter-branch. Check its documentation and source code . 2. Undoing Uncommitted Changes Discard Changes in a File git checkout -- file.txt This command discards changes in the specified file, reverting it to the state in the last commit. It\u2019s important to understand that git checkout -- <file> is a dangerous command. Any local changes you made to that file are gone\u2009\u2014\u2009Git just replaced that file with the last staged or committed version. Don\u2019t ever use this command unless you absolutely know that you don\u2019t want those unsaved local changes. Discard All Changes git reset --hard This command discards all uncommitted changes in the working directory, reverting it to the state of the last commit. For more details on the difference between git reset and git checkout, see the differences . 3. Undoing Staged Changes The git reset command in Git is a powerful tool for manipulating the commit history, moving branches, and resetting the staging area. It has several options, each affecting different parts of the Git repository. git reset --soft <commit> Resets the current branch's HEAD to the specified commit, leaving the changes staged. Moves the HEAD pointer to the specified commit, keeping the changes from commits after that commit staged for a new commit. git reset --soft HEAD~3 This command resets the current branch's HEAD to three commits behind the current position, keeping the changes staged. It essentially undid the last 3 git commit commands.You could now update the index (by adding or removing files) and run git commit again to accomplish what git commit --amend would have done. git reset --mixed <commit> Resets the current branch's HEAD to the specified commit, unstaging the changes. This is also the default, so if you specify no option at all (just git reset HEAD~3 in this case). Moves the HEAD pointer to the specified commit, unstaging the changes from commits after that commit. git reset --mixed HEAD~3 This command resets the current branch's HEAD to three commits behind the current position, unstaging the changes. You rolled back to before you ran all your git add and git commit commands. git reset --hard <commit> Resets the current branch's HEAD to the specified commit, discarding all changes. Moves the HEAD pointer to the specified commit, discarding all changes made after that commit. git reset --hard HEAD~3 This command resets the current branch's HEAD to three commits behind the current position, discarding all changes. Use when you want to completely replace the current branch with the specified commit by discarding all changes made after that commit. Remember to use git reset with caution, especially the --hard option, as it can lead to irreversible data loss. Always make sure you understand the consequences of the reset operation before executing it. git reset file.txt The command git reset with a path to a file (since a commit SHA-1 or branch is not specified) is shorthand for git reset --mixed HEAD file.txt. It will: Move the branch HEAD points to (skipped). Make the index look like HEAD (stop here). So it essentially just copies file.txt from HEAD to the index. This has the practical effect of unstaging the file. If we look at the diagram for that command and think about what git add does, they are exact opposites. This is why the output of the git status command suggests that you run this to unstage a file. We could just as easily not let Git assume we meant \u201cpull the data from HEAD\u201d by specifying a specific commit to pull that file version from. We would just run something like: git reset eb43bf file.txt git reset vs git checkout Without Paths Running git checkout [branch] is pretty similar to running git reset --hard [branch] in that it updates all three trees for you to look like [branch], but there are two important differences. Unlike git reset --hard, git checkout is working-directory safe. \u2009It tries to do a trivial merge in the working directory, so all of the files you haven\u2019t changed will be updated. git reset --hard, on the other hand, will simply replace everything across the board without checking. git checkout will move HEAD itself to point to another branch or commit, while git reset will move the branch that HEAD points to. That is why when using git checkout you may end up with a detached HEAD, which is not possible with git reset. With Paths The other way to run checkout is with a file path, which, like reset, does not move HEAD. It is just like git reset [branch] file in that it updates the index with that file at that commit, but it also overwrites the file in the working directory. It would be exactly like git reset --hard [branch] file (if reset would let you run that)\u2009\u2014\u2009it\u2019s not working-directory safe, and it does not move HEAD. Cheat-sheet This table shows a cheat-sheet for which commands affect which trees. The \u201cHEAD\u201d column reads \u201cREF\u201d if that command moves the reference (branch) that HEAD points to, and \u201cHEAD\u201d if it moves HEAD itself. Pay especial attention to the 'WD Safe?' column\u2009\u2014\u2009if it says NO, take a second to think before running that command. HEAD Index Workdir WD Safe? Commit Level reset --soft [commit] REF NO NO YES reset [commit] REF YES NO YES reset --hard [commit] REF YES YES NO checkout HEAD YES YES YES File Level reset [commit] NO YES NO YES checkout [commit] NO YES YES NO 4. Undoing Remote Changes Force Push to Remote (use with caution) git push --force origin <branch-name> Use this command to force push local changes to a remote branch. Be cautious as it rewrites the remote history. 5. Restoring Files The git restore command is a versatile command introduced in Git version 2.23. It is designed to restore parts of the working directory or discard changes in a way that is more explicit and flexible than some of the previous commands. git reset VS git restore git reset and git restore are both Git commands that deal with modifying the working directory, staging area, and commit history, but they serve slightly different purposes. Feature git reset git restore Purpose Resets the state of the repository, moving the HEAD pointer to a different commit or updating the staging area and working directory. Restores files in the working directory to a specified state, either from the index or a commit. Designed for restoring files, either discarding changes or moving them between the working directory and staging area. Syntax git reset [--soft | --mixed | --hard] [<commit>] git restore [--source=<commit>] [--staged] [--worktree] <pathspec>\u2026 Unmodifying a Modified File git checkout -- <file> git restore <file> Unstaging a Staged File git reset <file> git restore --staged <file> Restore Entire Working Directory git reset --hard <commit> git restore --source=<commit> --worktree --staged --worktree . When comparing using git restore with git reset there are a few key differences to consider: Effect on Staging Area and Working Directory: git reset : When using git reset , you have the option to reset changes directly in the staging area and/or the working directory. However, resetting changes with git reset typically involves moving the HEAD pointer to a different commit, potentially altering the commit history. git restore : With git restore , you explicitly specify the source of the changes you want to restore to the staging area ( --staged ) and/or the working directory ( --worktree ). This allows for more granular control over which changes are affected, without altering the commit history. Granularity: git reset : git reset allows you to reset changes at a commit level or a file level. You can choose to reset all changes introduced by the last commit, specific files, or even specific hunks within files. git restore : git restore allows you to restore changes at a file or directory level. You can restore changes from a specific commit to the staging area and/or the working directory, but it doesn't provide the same level of granularity for selecting individual hunks within files. Ease of Use: git reset : While git reset can be powerful, it requires a bit more care and understanding, especially when choosing between --soft , --mixed , or --hard reset modes. Choosing the wrong mode can lead to unintended consequences, such as losing changes in the working directory. git restore : git restore offers a simpler and more explicit way to restore changes to the staging area and/or the working directory. By specifying the source of the changes and the target locations, you can be more confident in the outcome. In summary, both git reset and git restore offer a powerful tool for managing changes in the working directory and staging area. They differ in granularity, control, and ease of use. git reset offers more options but requires careful consideration of its modes, while git restore provides a simpler and more explicit approach for restoring changes. Discard Uncommitted Changes in a File To discard uncommitted changes in a specific file and restore it to the state in the last commit: git restore file.txt This command reverts the changes made to file.txt in the working directory, making it identical to the state of the file in the last commit. Unstaged Changes in a File To unstage changes in a file and move them back to the working directory: git restore --staged file.txt This command effectively undoes the staging of changes in file.txt and puts them back into the working directory. It is similar to git reset file.txt , but git restore is more explicit in this context. Restore Entire Working Directory To discard all uncommitted changes and restore the entire working directory to the state of the last commit: git restore --source = <commit> --worktree --staged --worktree . --source=<commit> : Specifies the commit from which to take the files states. --staged : Restores all changes to the staging area. --worktree : Restores all changes to the working directory. The git restore command provides a clearer and more explicit syntax for specific use cases, making it a powerful tool for managing changes in the working directory and staging area. Always use it with care, especially when dealing with commands that modify or discard changes. # restore working tree from HEAD content, # without touching the index/staging area git restore . # restore working tree from master content, # without touching the index/staging area git restore -s master . Both worktree and index could also be restored at the same time (from a tree) when both --staged and --worktree are specified. This overlaps with 'git checkout [tree] [paths]'. Specify the restore location. If neither option is specified, by default the working tree is restored. Specifying --staged will only restore the index. Specifying both restores both. 6. Rewriting history In Git, rewriting branches, updating commits, and clearing history are common tasks that allow you to modify the commit history of a repository. These actions can be useful for cleaning up history, organizing commits, or incorporating changes from other branches. Git allows changing the order of the commits, changing messages or modifying files in a commit, squashing together or splitting apart commits, or removing commits entirely\u2009\u2014\u2009all before you share your work with others. git rebase [branch] Apply any commits of the current branch ahead of the specified one. git rebase main Incorporate changes from another branch ( main in this example) into the current branch, moving your commits to the tip of the specified branch. git filter-branch Rewrite branches to remove unwanted data, such as sensitive information or large files. git filter-branch --tree-filter 'rm -f passwords.txt' HEAD Filter branch content by applying a specified command to each commit, useful for history rewriting tasks. 7. Removing Files Versioning file removes and path changes Command Example git rm git rm file.txt git mv git mv oldfile.txt newfile.txt git checkout git checkout -f feature-branch git clean git clean -ffd git rm Removes files from both your working directory and the staging area. It stages the removal of the specified files, and you need to commit to apply the changes. # Remove a file from the staging area and stage the removal git rm -f file.txt # Commit the removal git commit -m \"Remove file.txt\" This sequence removes file.txt from both the staging area and the working directory , and the removal is committed. Another useful thing you may want to do is to keep the file in your working tree but remove it from your staging area. # Remove a file from the staging area git rm --cached file.txt You can pass files, directories, and file-glob patterns to the git rm command. That means you can do things such as: $ git rm log/ \\* .log Note the backslash () in front of the *. This is necessary because Git does its own filename expansion in addition to your shell\u2019s filename expansion. This command removes all files that have the .log extension in the log/ directory. Or, you can do something like this: $ git rm \\* ~ This command removes all files whose names end with a ~. git mv Renames or moves files in both your working directory and the Git repository. Similar to git rm , it stages the rename/move, and you need to commit to apply the changes. # Rename a file and stage the change git mv oldfile.txt newfile.txt # Commit the rename git commit -m \"Rename oldfile.txt to newfile.txt\" This example renames oldfile.txt to newfile.txt , stages the change, and commits the rename. With git mv , you can also use it to move files to a different directory, like git mv file.txt new_directory/ . Use -r with git rm and git mv to handle removals or moves recursively in directories. git checkout When switching branches, proceed even if the index or the working tree differs from HEAD, and even if there are untracked files in the way. This command is used to forcefully switch branches, discarding any local changes or untracked files that may prevent the branch switch. git checkout -f feature-branch - Note: Be cautious when using this command, as it will discard any local changes without warning. git clean Erase all untracked files and directories in the working directory. This command is used to clean up the working directory by removing any untracked files or directories that are not under version control. git clean -ffd - Note: The -f option is used to force the clean operation, and the -d option is used to include untracked directories. There is a quirky situation where you might need to be extra forceful in asking Git to clean your working directory. If you happen to be in a working directory under which you\u2019ve copied or cloned other Git repositories (perhaps as submodules), even git clean -fd will refuse to delete those directories. In cases like that, you need to add a second -f option for emphasis. These commands are useful for cleaning up a Git repository before starting fresh or resolving conflicts that prevent branch switching. However, they should be used with caution, as they can permanently delete local changes and untracked files. It's essential to understand the implications of using these commands and ensure that any necessary changes or files are backed up before proceeding. # List untracked files that will be removed (dry run) git clean -n # Remove untracked files git clean -f The command ( git clean -n or git clean --dry-run ) is a dry run that shows you what files would be removed. The second command ( git clean -f ) actually removes the untracked files. git clean has additional options, such as -i for an interactive mode where you can choose which files to clean. The -f means 'force' or \u201creally do this,\u201d and is required if the Git configuration variable clean.requireForce is not explicitly set to false. By default, the git clean command will only remove untracked files that are not ignored. Any file that matches a pattern in your .gitignore or other ignore files will not be removed. If you want to remove those files too, such as to remove all .o files generated from a build so you can do a fully clean build, you can add a -x to the clean command.","title":"Undoing Things"},{"location":"Basics/git_undoingthings/#summary-table","text":"of common Git undo commands and strategies: Action Command Description Undoing Commits git commit --amend Amend the last commit by adding new changes or modifying the commit message. git revert <commit-hash> Create a new commit that undoes changes introduced by a specific commit. git rebase -i <commit-hash> Open an interactive rebase session, allowing you to edit, squash, or drop commits. Undoing Uncommitted Changes git checkout -- file.txt Discard changes in a specific file, reverting it to the state in the last commit. git reset --hard Discard all uncommitted changes, reverting the working directory to the state of the last commit. Undoing Staged Changes git reset file.txt Unstage changes in a specific file, moving them back to the working directory. git reset --soft HEAD^ Undo the last commit, keeping changes staged in the working directory. git reset --mixed HEAD^ Undo the last commit, unstaging changes but keeping them in the working directory. git reset --hard HEAD^ Undo the last commit, discarding changes both in the commit and the working directory. Undoing Remote Changes git push --force origin <branch-name> Force push local changes to a remote branch (use with caution, as it rewrites remote history). Restoring Files git restore file.txt Restore the specified file to the state in the last commit (introduced in Git 2.23). Rewriting history git rebase main Apply any commits of the current branch ahead of the specified one. git filter-branch Rewrite branches to remove unwanted data Removing files git rm Remove files git mv Rename files git checkout -f [branch] Switch branches, discarding any local changes git clean -ffd Erase all untracked files and directories in the working directory Please note that some commands, like force push and hard reset, should be used with caution, especially when collaborating with others, as they can alter Git history. Always be mindful of the consequences and potential impacts on collaborators before executing these commands.","title":"Summary table"},{"location":"Basics/git_undoingthings/#1-undoing-commits","text":"git commit --amend , and git revert are all Git commands used to manipulate commit history, but they serve different purposes and are used in different scenarios.","title":"1. Undoing Commits"},{"location":"Basics/git_undoingthings/#2-undoing-uncommitted-changes","text":"","title":"2. Undoing Uncommitted Changes"},{"location":"Basics/git_undoingthings/#3-undoing-staged-changes","text":"The git reset command in Git is a powerful tool for manipulating the commit history, moving branches, and resetting the staging area. It has several options, each affecting different parts of the Git repository.","title":"3. Undoing Staged Changes"},{"location":"Basics/git_undoingthings/#git-reset-soft-commit","text":"Resets the current branch's HEAD to the specified commit, leaving the changes staged. Moves the HEAD pointer to the specified commit, keeping the changes from commits after that commit staged for a new commit. git reset --soft HEAD~3 This command resets the current branch's HEAD to three commits behind the current position, keeping the changes staged. It essentially undid the last 3 git commit commands.You could now update the index (by adding or removing files) and run git commit again to accomplish what git commit --amend would have done.","title":"git reset --soft &lt;commit>"},{"location":"Basics/git_undoingthings/#git-reset-mixed-commit","text":"Resets the current branch's HEAD to the specified commit, unstaging the changes. This is also the default, so if you specify no option at all (just git reset HEAD~3 in this case). Moves the HEAD pointer to the specified commit, unstaging the changes from commits after that commit. git reset --mixed HEAD~3 This command resets the current branch's HEAD to three commits behind the current position, unstaging the changes. You rolled back to before you ran all your git add and git commit commands.","title":"git reset --mixed &lt;commit>"},{"location":"Basics/git_undoingthings/#git-reset-hard-commit","text":"Resets the current branch's HEAD to the specified commit, discarding all changes. Moves the HEAD pointer to the specified commit, discarding all changes made after that commit. git reset --hard HEAD~3 This command resets the current branch's HEAD to three commits behind the current position, discarding all changes. Use when you want to completely replace the current branch with the specified commit by discarding all changes made after that commit. Remember to use git reset with caution, especially the --hard option, as it can lead to irreversible data loss. Always make sure you understand the consequences of the reset operation before executing it.","title":"git reset --hard &lt;commit>"},{"location":"Basics/git_undoingthings/#git-reset-filetxt","text":"The command git reset with a path to a file (since a commit SHA-1 or branch is not specified) is shorthand for git reset --mixed HEAD file.txt. It will: Move the branch HEAD points to (skipped). Make the index look like HEAD (stop here). So it essentially just copies file.txt from HEAD to the index. This has the practical effect of unstaging the file. If we look at the diagram for that command and think about what git add does, they are exact opposites. This is why the output of the git status command suggests that you run this to unstage a file. We could just as easily not let Git assume we meant \u201cpull the data from HEAD\u201d by specifying a specific commit to pull that file version from. We would just run something like: git reset eb43bf file.txt","title":"git reset file.txt"},{"location":"Basics/git_undoingthings/#git-reset-vs-git-checkout","text":"","title":"git reset vs git checkout"},{"location":"Basics/git_undoingthings/#cheat-sheet","text":"This table shows a cheat-sheet for which commands affect which trees. The \u201cHEAD\u201d column reads \u201cREF\u201d if that command moves the reference (branch) that HEAD points to, and \u201cHEAD\u201d if it moves HEAD itself. Pay especial attention to the 'WD Safe?' column\u2009\u2014\u2009if it says NO, take a second to think before running that command. HEAD Index Workdir WD Safe? Commit Level reset --soft [commit] REF NO NO YES reset [commit] REF YES NO YES reset --hard [commit] REF YES YES NO checkout HEAD YES YES YES File Level reset [commit] NO YES NO YES checkout [commit] NO YES YES NO","title":"Cheat-sheet"},{"location":"Basics/git_undoingthings/#4-undoing-remote-changes","text":"Force Push to Remote (use with caution) git push --force origin <branch-name> Use this command to force push local changes to a remote branch. Be cautious as it rewrites the remote history.","title":"4. Undoing Remote Changes"},{"location":"Basics/git_undoingthings/#5-restoring-files","text":"The git restore command is a versatile command introduced in Git version 2.23. It is designed to restore parts of the working directory or discard changes in a way that is more explicit and flexible than some of the previous commands.","title":"5. Restoring Files"},{"location":"Basics/git_undoingthings/#git-reset-vs-git-restore","text":"git reset and git restore are both Git commands that deal with modifying the working directory, staging area, and commit history, but they serve slightly different purposes. Feature git reset git restore Purpose Resets the state of the repository, moving the HEAD pointer to a different commit or updating the staging area and working directory. Restores files in the working directory to a specified state, either from the index or a commit. Designed for restoring files, either discarding changes or moving them between the working directory and staging area. Syntax git reset [--soft | --mixed | --hard] [<commit>] git restore [--source=<commit>] [--staged] [--worktree] <pathspec>\u2026 Unmodifying a Modified File git checkout -- <file> git restore <file> Unstaging a Staged File git reset <file> git restore --staged <file> Restore Entire Working Directory git reset --hard <commit> git restore --source=<commit> --worktree --staged --worktree . When comparing using git restore with git reset there are a few key differences to consider: Effect on Staging Area and Working Directory: git reset : When using git reset , you have the option to reset changes directly in the staging area and/or the working directory. However, resetting changes with git reset typically involves moving the HEAD pointer to a different commit, potentially altering the commit history. git restore : With git restore , you explicitly specify the source of the changes you want to restore to the staging area ( --staged ) and/or the working directory ( --worktree ). This allows for more granular control over which changes are affected, without altering the commit history. Granularity: git reset : git reset allows you to reset changes at a commit level or a file level. You can choose to reset all changes introduced by the last commit, specific files, or even specific hunks within files. git restore : git restore allows you to restore changes at a file or directory level. You can restore changes from a specific commit to the staging area and/or the working directory, but it doesn't provide the same level of granularity for selecting individual hunks within files. Ease of Use: git reset : While git reset can be powerful, it requires a bit more care and understanding, especially when choosing between --soft , --mixed , or --hard reset modes. Choosing the wrong mode can lead to unintended consequences, such as losing changes in the working directory. git restore : git restore offers a simpler and more explicit way to restore changes to the staging area and/or the working directory. By specifying the source of the changes and the target locations, you can be more confident in the outcome. In summary, both git reset and git restore offer a powerful tool for managing changes in the working directory and staging area. They differ in granularity, control, and ease of use. git reset offers more options but requires careful consideration of its modes, while git restore provides a simpler and more explicit approach for restoring changes.","title":"git reset VS git restore"},{"location":"Basics/git_undoingthings/#6-rewriting-history","text":"In Git, rewriting branches, updating commits, and clearing history are common tasks that allow you to modify the commit history of a repository. These actions can be useful for cleaning up history, organizing commits, or incorporating changes from other branches. Git allows changing the order of the commits, changing messages or modifying files in a commit, squashing together or splitting apart commits, or removing commits entirely\u2009\u2014\u2009all before you share your work with others.","title":"6. Rewriting history"},{"location":"Basics/git_undoingthings/#7-removing-files","text":"Versioning file removes and path changes Command Example git rm git rm file.txt git mv git mv oldfile.txt newfile.txt git checkout git checkout -f feature-branch git clean git clean -ffd","title":"7. Removing Files"},{"location":"Github/git_ssh/","text":"Setting up SSH keys with GitHub allows you to securely authenticate with GitHub without needing to enter your username and password every time you interact with a repository. Here's a step-by-step guide to setting up SSH keys with GitHub: Check for Existing SSH Keys Before generating new SSH keys, check if you already have SSH keys on your system. ls -al ~/.ssh Generate a New SSH Key If you don't have an SSH key pair, generate one using the ssh-keygen command. Press Enter to accept the default file location and optionally set a passphrase for added security. ssh-keygen -t ed25519 -C \"your_email@example.com\" Add SSH Key to SSH Agent Start the SSH agent and add your SSH private key to the agent. eval \" $( ssh-agent -s ) \" ssh-add ~/.ssh/id_rsa Copy SSH Public Key Copy the SSH public key to your clipboard using the pbcopy command (macOS) or display it in the terminal and manually copy it. pbcopy < ~/.ssh/id_rsa.pub # macOS cat ~/.ssh/id_rsa.pub # Linux Add SSH Key to GitHub Go to your GitHub account settings. Click on \"SSH and GPG keys\" in the left sidebar. Click on \"New SSH key\" or \"Add SSH key.\" Paste your SSH public key into the \"Key\" field. Provide a descriptive title for the SSH key. Click on \"Add SSH key\" or \"Save SSH key.\" Test SSH Connection To verify that your SSH key is correctly set up, try connecting to GitHub. ssh -T git@github.com Configure SSH for Multiple Accounts (Optional) If you have multiple GitHub accounts, you may need to configure SSH to use different keys for different accounts. This involves creating a config file in your ~/.ssh directory. touch ~/.ssh/config Edit the config file and specify which SSH key to use for each GitHub hostname: # Default GitHub Host github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa # Second GitHub account Host github-other HostName github.com User git IdentityFile ~/.ssh/other_id_rsa Setting up SSH keys with GitHub provides a secure and convenient way to authenticate with GitHub repositories. By generating SSH keys, adding them to your GitHub account, and configuring your SSH client, you can securely interact with GitHub repositories without needing to enter your username and password for each operation.","title":"Adding SSH Keys to Github"},{"location":"Github/git_ssh/#check-for-existing-ssh-keys","text":"Before generating new SSH keys, check if you already have SSH keys on your system. ls -al ~/.ssh","title":"Check for Existing SSH Keys"},{"location":"Github/git_ssh/#generate-a-new-ssh-key","text":"If you don't have an SSH key pair, generate one using the ssh-keygen command. Press Enter to accept the default file location and optionally set a passphrase for added security. ssh-keygen -t ed25519 -C \"your_email@example.com\"","title":"Generate a New SSH Key"},{"location":"Github/git_ssh/#add-ssh-key-to-ssh-agent","text":"Start the SSH agent and add your SSH private key to the agent. eval \" $( ssh-agent -s ) \" ssh-add ~/.ssh/id_rsa","title":"Add SSH Key to SSH Agent"},{"location":"Github/git_ssh/#copy-ssh-public-key","text":"Copy the SSH public key to your clipboard using the pbcopy command (macOS) or display it in the terminal and manually copy it. pbcopy < ~/.ssh/id_rsa.pub # macOS cat ~/.ssh/id_rsa.pub # Linux","title":"Copy SSH Public Key"},{"location":"Github/git_ssh/#add-ssh-key-to-github","text":"Go to your GitHub account settings. Click on \"SSH and GPG keys\" in the left sidebar. Click on \"New SSH key\" or \"Add SSH key.\" Paste your SSH public key into the \"Key\" field. Provide a descriptive title for the SSH key. Click on \"Add SSH key\" or \"Save SSH key.\"","title":"Add SSH Key to GitHub"},{"location":"Github/git_ssh/#test-ssh-connection","text":"To verify that your SSH key is correctly set up, try connecting to GitHub. ssh -T git@github.com","title":"Test SSH Connection"},{"location":"Github/git_ssh/#configure-ssh-for-multiple-accounts-optional","text":"If you have multiple GitHub accounts, you may need to configure SSH to use different keys for different accounts. This involves creating a config file in your ~/.ssh directory. touch ~/.ssh/config Edit the config file and specify which SSH key to use for each GitHub hostname: # Default GitHub Host github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa # Second GitHub account Host github-other HostName github.com User git IdentityFile ~/.ssh/other_id_rsa Setting up SSH keys with GitHub provides a secure and convenient way to authenticate with GitHub repositories. By generating SSH keys, adding them to your GitHub account, and configuring your SSH client, you can securely interact with GitHub repositories without needing to enter your username and password for each operation.","title":"Configure SSH for Multiple Accounts (Optional)"},{"location":"More/git_attributes/","text":"Git attributes are a powerful feature of Git that allow you to define how different types of files are handled by Git in various operations, such as merging, diffing, and exporting. Git attributes are configured in a file named .gitattributes located at the root of your repository or in any subdirectory or in the .git/info/attributes file if you don\u2019t want the attributes file committed with your project.. The basic syntax for defining attributes in a .gitattributes file is: <pattern> <attribute> [value] <pattern> : A glob pattern that matches one or more files. <attribute> : The name of the attribute to set. [value] : An optional value for the attribute (e.g., true , false , unset ). Common Git Attributes Text Attributes text : Normalizes line endings for text files. *.txt text crlf : Controls the line-ending conversion. Can be input or true . *.sh text eol = lf Example: Normalizing Line Endings Ensure consistent line endings by normalizing text files to LF in the repository: *.txt text *.sh text eol = lf *.bat text eol = crlf Binary Attributes binary : Marks files as binary to prevent diff and merge operations. *.jpg binary Example 2: Marking Files as Binary Prevent diff and merge operations on binary files: *.jpg binary *.png binary Diff Attributes diff : Customizes how diffs are generated for specific file types. Example: Custom Diff Drivers Define a custom diff driver for Markdown files: 1. Add the following to your .gitattributes : *.md diff = markdown Define the custom diff driver in your .git/config or global .gitconfig : [ diff \"markdown\" ] textconv = markdown-diff Create a script named markdown-diff that converts Markdown to a plain text format for comparison. For word documents: *.docx diff = word This tells Git that any file that matches this pattern (.docx) should use the \u201cword\u201d filter when you try to view a diff that contains changes. What is the \u201cword\u201d filter? You have to set it up. Here you\u2019ll configure Git to use the docx2txt program to convert Word documents into readable text files, which it will then diff properly. First, you\u2019ll need to install docx2txt; you can download it from https://sourceforge.net/projects/docx2txt. Follow the instructions in the INSTALL file to put it somewhere your shell can find it. Next, you\u2019ll write a wrapper script to convert output to the format Git expects. Create a file that\u2019s somewhere in your path called docx2txt, and add these contents: #!/bin/bash docx2txt.pl \" $1 \" - Don\u2019t forget to chmod a+x that file. Finally, you can configure Git to use this script: git config diff.word.textconv docx2txt Now Git knows that if it tries to do a diff between two snapshots, and any of the files end in .docx, it should run those files through the \u201cword\u201d filter, which is defined as the docx2txt program. This effectively makes nice text-based versions of your Word files before attempting to diff them. Merge Attributes merge : Specifies custom merge strategies. *.lock merge = ours Example: Custom Merge Strategies Use a custom merge strategy for lock files: *.lock merge = ours Add the following to your .git/config or global .gitconfig : [ merge \"ours\" ] driver = true Export Attributes export-ignore : Excludes files from archive operations. secret.txt export-ignore Example: Exporting Archives Exclude certain files from git archive operations: secret.txt export-ignore *.log export-ignore Additional Attributes filter : Defines custom filters for content smudging and cleaning. *.doc filter = docx2txt Configure the filter in your .git/config : [ filter \"docx2txt\" ] clean = docx2txt-clean smudge = docx2txt-smudge ident : Expands $Id$ keywords in files. *.c ident linguist-language : Overrides the language detected by GitHub\u2019s linguist tool. *.txt linguist-language = Text whitespace : Customizes how whitespace errors are flagged. *.py whitespace = fix Practical Use Case Use Case: Custom Diff and Merge for JSON Files Suppose you frequently edit JSON files and want a custom diff and merge strategy that pretty-prints JSON before comparing or merging. Add to your .gitattributes : *.json diff = json *.json merge = json Define the custom diff and merge drivers in your .git/config : [ diff \"json\" ] textconv = jq . -M [ merge \"json\" ] driver = jq -s '.[0] * .[1]' %O %A %B > %A Ensure you have jq installed, a lightweight and flexible command-line JSON processor. Conclusion Git attributes provide a versatile way to customize how Git handles different types of files in your repository. By using the .gitattributes file, you can define specific behaviors for text normalization, binary handling, custom diff and merge strategies, export rules, and more. Understanding and utilizing these attributes effectively can greatly enhance your workflow and ensure consistent handling of files across different environments.","title":"Attributes"},{"location":"More/git_attributes/#common-git-attributes","text":"","title":"Common Git Attributes"},{"location":"More/git_attributes/#text-attributes","text":"text : Normalizes line endings for text files. *.txt text crlf : Controls the line-ending conversion. Can be input or true . *.sh text eol = lf Example: Normalizing Line Endings Ensure consistent line endings by normalizing text files to LF in the repository: *.txt text *.sh text eol = lf *.bat text eol = crlf","title":"Text Attributes"},{"location":"More/git_attributes/#binary-attributes","text":"binary : Marks files as binary to prevent diff and merge operations. *.jpg binary Example 2: Marking Files as Binary Prevent diff and merge operations on binary files: *.jpg binary *.png binary","title":"Binary Attributes"},{"location":"More/git_attributes/#diff-attributes","text":"diff : Customizes how diffs are generated for specific file types. Example: Custom Diff Drivers Define a custom diff driver for Markdown files: 1. Add the following to your .gitattributes : *.md diff = markdown Define the custom diff driver in your .git/config or global .gitconfig : [ diff \"markdown\" ] textconv = markdown-diff Create a script named markdown-diff that converts Markdown to a plain text format for comparison. For word documents: *.docx diff = word This tells Git that any file that matches this pattern (.docx) should use the \u201cword\u201d filter when you try to view a diff that contains changes. What is the \u201cword\u201d filter? You have to set it up. Here you\u2019ll configure Git to use the docx2txt program to convert Word documents into readable text files, which it will then diff properly. First, you\u2019ll need to install docx2txt; you can download it from https://sourceforge.net/projects/docx2txt. Follow the instructions in the INSTALL file to put it somewhere your shell can find it. Next, you\u2019ll write a wrapper script to convert output to the format Git expects. Create a file that\u2019s somewhere in your path called docx2txt, and add these contents: #!/bin/bash docx2txt.pl \" $1 \" - Don\u2019t forget to chmod a+x that file. Finally, you can configure Git to use this script: git config diff.word.textconv docx2txt Now Git knows that if it tries to do a diff between two snapshots, and any of the files end in .docx, it should run those files through the \u201cword\u201d filter, which is defined as the docx2txt program. This effectively makes nice text-based versions of your Word files before attempting to diff them.","title":"Diff Attributes"},{"location":"More/git_attributes/#merge-attributes","text":"merge : Specifies custom merge strategies. *.lock merge = ours Example: Custom Merge Strategies Use a custom merge strategy for lock files: *.lock merge = ours Add the following to your .git/config or global .gitconfig : [ merge \"ours\" ] driver = true","title":"Merge Attributes"},{"location":"More/git_attributes/#export-attributes","text":"export-ignore : Excludes files from archive operations. secret.txt export-ignore Example: Exporting Archives Exclude certain files from git archive operations: secret.txt export-ignore *.log export-ignore","title":"Export Attributes"},{"location":"More/git_attributes/#additional-attributes","text":"filter : Defines custom filters for content smudging and cleaning. *.doc filter = docx2txt Configure the filter in your .git/config : [ filter \"docx2txt\" ] clean = docx2txt-clean smudge = docx2txt-smudge ident : Expands $Id$ keywords in files. *.c ident linguist-language : Overrides the language detected by GitHub\u2019s linguist tool. *.txt linguist-language = Text whitespace : Customizes how whitespace errors are flagged. *.py whitespace = fix","title":"Additional Attributes"},{"location":"More/git_attributes/#practical-use-case","text":"","title":"Practical Use Case"},{"location":"More/git_attributes/#use-case-custom-diff-and-merge-for-json-files","text":"Suppose you frequently edit JSON files and want a custom diff and merge strategy that pretty-prints JSON before comparing or merging. Add to your .gitattributes : *.json diff = json *.json merge = json Define the custom diff and merge drivers in your .git/config : [ diff \"json\" ] textconv = jq . -M [ merge \"json\" ] driver = jq -s '.[0] * .[1]' %O %A %B > %A Ensure you have jq installed, a lightweight and flexible command-line JSON processor.","title":"Use Case: Custom Diff and Merge for JSON Files"},{"location":"More/git_attributes/#conclusion","text":"Git attributes provide a versatile way to customize how Git handles different types of files in your repository. By using the .gitattributes file, you can define specific behaviors for text normalization, binary handling, custom diff and merge strategies, export rules, and more. Understanding and utilizing these attributes effectively can greatly enhance your workflow and ensure consistent handling of files across different environments.","title":"Conclusion"},{"location":"More/git_bundle/","text":"Bundling in Git is a way to package multiple Git objects (such as commits, trees, and blobs) into a single file, which can be transferred and applied to another repository. This is particularly useful for scenarios where direct access to a remote repository is not available, such as offline transfers or sneakernet situations. Offline Transfers: When network access is limited or unavailable, you can bundle changes, transfer them via physical media (like USB drives), and apply them to another repository. Archiving: Bundle can be used to archive a specific state of a repository, which can be stored and applied later. Distribution: Distribute a repository snapshot without requiring direct network access to the Git server. By understanding and utilizing Git bundling, you can efficiently manage and transfer repository data in scenarios where traditional network operations are impractical. Command Description git bundle create <file> <reference> Creates a bundle file containing the specified reference(s) git bundle list-heads <file> Lists the references stored in a bundle file git clone <bundle-file> <directory> Clones a new repository from the bundle git fetch <bundle-file> <reference> Fetches updates from a bundle into an existing repository git pull <bundle-file> <reference> Applies changes from a bundle to the current branch Creating a Bundle To create a bundle, you use the git bundle create command, specifying the name of the bundle file and the range of commits or references you want to include. Suppose you have a repository with the following commit history: A -- B -- C -- D (master) You want to create a bundle that includes all commits in the master branch. git bundle create repo.bundle master This command creates a file named repo.bundle containing all the commits from the master branch. If you intend for this to be cloned somewhere else, you should add HEAD as a reference. git bundle create repo.bundle HEAD master Listing References in a Bundle You can list the references stored in a bundle file using the git bundle list-heads command. This shows the branches and commits included in the bundle. git bundle list-heads repo.bundle Output: b1a2d3c4e5f6g7h8i9j0 - refs/heads/master Cloning from a Bundle If you want to create a new repository from a bundle, you can use the git clone command with the bundle file. git clone repo.bundle new-repo This creates a new repository named new-repo initialized with the contents of the bundle. If you don\u2019t include HEAD in the references, you have to also specify -b master or whatever branch is included because otherwise it won\u2019t know what branch to check out. Fetching from a Bundle If you already have a repository and want to fetch updates from a bundle, you can use the git fetch command with the bundle file. Suppose you have a repository that already contains commits up to B , and you want to fetch commits C and D from the bundle. git fetch repo.bundle master After this command, your repository will include the commits from the bundle. Bundling Specific Revisions You can also bundle specific revisions or ranges of commits. For example, to bundle commits from a specific tag to the current commit: git bundle create updates.bundle v1.0..HEAD This bundles all commits from the v1.0 tag to the current HEAD . To get the differences between my local changes to the bundle and the remote repository, you can use the git log command with the bundle file. git log --oneline master ^origin/master Then only bundle the differences. git bundle create updates.bundle master ^origin/master Applying a Bundle To apply a bundle to an existing repository, you can use the git pull command with the bundle file. git pull repo.bundle master This applies the changes from the master branch in the bundle to your current repository. Verifying Bundles The bundle verify command will make sure the file is actually a valid Git bundle and that you have all the necessary ancestors to reconstitute it properly. git bundle verify repo.bundle The verify sub-command will tell you the heads as well. The point is to see what can be pulled in, so you can use the fetch or pull commands to import commits from this bundle. Here we\u2019ll fetch the master branch of the bundle to a branch named other-master in our repository. git fetch repo.bundle master:other-master","title":"Bundling"},{"location":"More/git_bundle/#creating-a-bundle","text":"To create a bundle, you use the git bundle create command, specifying the name of the bundle file and the range of commits or references you want to include. Suppose you have a repository with the following commit history: A -- B -- C -- D (master) You want to create a bundle that includes all commits in the master branch. git bundle create repo.bundle master This command creates a file named repo.bundle containing all the commits from the master branch. If you intend for this to be cloned somewhere else, you should add HEAD as a reference. git bundle create repo.bundle HEAD master","title":"Creating a Bundle"},{"location":"More/git_bundle/#listing-references-in-a-bundle","text":"You can list the references stored in a bundle file using the git bundle list-heads command. This shows the branches and commits included in the bundle. git bundle list-heads repo.bundle Output: b1a2d3c4e5f6g7h8i9j0 - refs/heads/master","title":"Listing References in a Bundle"},{"location":"More/git_bundle/#cloning-from-a-bundle","text":"If you want to create a new repository from a bundle, you can use the git clone command with the bundle file. git clone repo.bundle new-repo This creates a new repository named new-repo initialized with the contents of the bundle. If you don\u2019t include HEAD in the references, you have to also specify -b master or whatever branch is included because otherwise it won\u2019t know what branch to check out.","title":"Cloning from a Bundle"},{"location":"More/git_bundle/#fetching-from-a-bundle","text":"If you already have a repository and want to fetch updates from a bundle, you can use the git fetch command with the bundle file. Suppose you have a repository that already contains commits up to B , and you want to fetch commits C and D from the bundle. git fetch repo.bundle master After this command, your repository will include the commits from the bundle.","title":"Fetching from a Bundle"},{"location":"More/git_bundle/#bundling-specific-revisions","text":"You can also bundle specific revisions or ranges of commits. For example, to bundle commits from a specific tag to the current commit: git bundle create updates.bundle v1.0..HEAD This bundles all commits from the v1.0 tag to the current HEAD . To get the differences between my local changes to the bundle and the remote repository, you can use the git log command with the bundle file. git log --oneline master ^origin/master Then only bundle the differences. git bundle create updates.bundle master ^origin/master","title":"Bundling Specific Revisions"},{"location":"More/git_bundle/#applying-a-bundle","text":"To apply a bundle to an existing repository, you can use the git pull command with the bundle file. git pull repo.bundle master This applies the changes from the master branch in the bundle to your current repository.","title":"Applying a Bundle"},{"location":"More/git_bundle/#verifying-bundles","text":"The bundle verify command will make sure the file is actually a valid Git bundle and that you have all the necessary ancestors to reconstitute it properly. git bundle verify repo.bundle The verify sub-command will tell you the heads as well. The point is to see what can be pulled in, so you can use the fetch or pull commands to import commits from this bundle. Here we\u2019ll fetch the master branch of the bundle to a branch named other-master in our repository. git fetch repo.bundle master:other-master","title":"Verifying Bundles"},{"location":"More/git_debug/","text":"Debugging with Git involves using various commands to trace the history of changes, identify when and where bugs were introduced, and understand the context of those changes. Here are some essential commands for debugging: git blame : Shows the last modification for each line of a file. git blame -L : Limits the blame output to specified line ranges. git blame -C -L : Tracks lines that have been copied or moved. git bisect : Performs a binary search to find the commit that introduced a bug. File Annotation The git blame command is used to show what revision and author last modified each line of a file. This is particularly useful for finding out who introduced a bug in a specific line of code. git blame file.txt In the output, the first column is the commit hash, the second column is the author, and the third column is the line number. The ^ prefix designates lines that were introduced in the repository\u2019s initial commit and have remained unchanged ever since. git blame -L The -L option allows you to specify line ranges to limit the output to specific parts of the file. # Show blame for lines 10 to 20 in file.txt git blame -L 10 ,20 file.txt git blame -C -L The -C option detects lines that have been copied or moved. Combined with -L , it helps find the origin of specific lines even if they have been moved from another file. # Show blame for lines 10 to 20 in file.txt, detecting moved lines git blame -C -L 10 ,20 file.txt git bisect The git bisect command is a powerful tool to find the commit that introduced a bug by performing a binary search between known good and bad commits. Start the Bisecting Process : git bisect start Mark the Current Commit as Bad : git bisect bad Mark an Older Commit as Good : git bisect good <commit-hash> Git will checkout an intermediate commit . Test your code to see if it has the bug: # Test the code and if the bug is present, mark the commit as bad git bisect bad # If the bug is not present, mark the commit as good git bisect good Repeat the process until Git identifies the first bad commit. Reset Bisecting once you've found the bad commit: git bisect reset Example Scenario Suppose you have a bug in your code and you suspect it was introduced recently. Here\u2019s how you can debug it: Use git blame to identify the commit that modified a specific line : git blame -L 45 ,45 src/main.py This command will show who last modified line 45 in src/main.py . If the change was copied or moved from another file, use git blame -C -L : git blame -C -L 45 ,45 src/main.py If you need to find the commit that introduced a bug, use git bisect : git bisect start git bisect bad git bisect good <commit-hash> Test each commit Git checks out to determine if the bug is present and mark it as good or bad until Git identifies the problematic commit. By using these commands, you can effectively trace the history of changes, identify the introduction of bugs, and understand the context behind those changes, making debugging with Git a powerful technique in your development workflow.","title":"Debugging"},{"location":"More/git_debug/#file-annotation","text":"The git blame command is used to show what revision and author last modified each line of a file. This is particularly useful for finding out who introduced a bug in a specific line of code. git blame file.txt In the output, the first column is the commit hash, the second column is the author, and the third column is the line number. The ^ prefix designates lines that were introduced in the repository\u2019s initial commit and have remained unchanged ever since.","title":"File Annotation"},{"location":"More/git_debug/#git-blame-l","text":"The -L option allows you to specify line ranges to limit the output to specific parts of the file. # Show blame for lines 10 to 20 in file.txt git blame -L 10 ,20 file.txt","title":"git blame -L"},{"location":"More/git_debug/#git-blame-c-l","text":"The -C option detects lines that have been copied or moved. Combined with -L , it helps find the origin of specific lines even if they have been moved from another file. # Show blame for lines 10 to 20 in file.txt, detecting moved lines git blame -C -L 10 ,20 file.txt","title":"git blame -C -L"},{"location":"More/git_debug/#git-bisect","text":"The git bisect command is a powerful tool to find the commit that introduced a bug by performing a binary search between known good and bad commits. Start the Bisecting Process : git bisect start Mark the Current Commit as Bad : git bisect bad Mark an Older Commit as Good : git bisect good <commit-hash> Git will checkout an intermediate commit . Test your code to see if it has the bug: # Test the code and if the bug is present, mark the commit as bad git bisect bad # If the bug is not present, mark the commit as good git bisect good Repeat the process until Git identifies the first bad commit. Reset Bisecting once you've found the bad commit: git bisect reset","title":"git bisect"},{"location":"More/git_debug/#example-scenario","text":"Suppose you have a bug in your code and you suspect it was introduced recently. Here\u2019s how you can debug it: Use git blame to identify the commit that modified a specific line : git blame -L 45 ,45 src/main.py This command will show who last modified line 45 in src/main.py . If the change was copied or moved from another file, use git blame -C -L : git blame -C -L 45 ,45 src/main.py If you need to find the commit that introduced a bug, use git bisect : git bisect start git bisect bad git bisect good <commit-hash> Test each commit Git checks out to determine if the bug is present and mark it as good or bad until Git identifies the problematic commit. By using these commands, you can effectively trace the history of changes, identify the introduction of bugs, and understand the context behind those changes, making debugging with Git a powerful technique in your development workflow.","title":"Example Scenario"},{"location":"More/git_notes/","text":"git notes is a command that allows you to add, inspect, and manage additional information (referred to as notes ) toobjects without altering the objects themselves. This is particularly useful for attaching metadata like comments, code reviews, or documentation to objectss without changing their hash (which would occur if you amend or edit them directly). It is a lesser-known yet powerful feature of git, often overshadowed by its challenging usability. Git notes allow users to append metadata to commits, blobs, and trees in git without altering the original objects. This feature is highly versatile, enabling a range of applications from tracking time per commit, adding review and testing information, to facilitating fully distributed code reviews. Despite their potential, git notes suffer from limited adoption and usability issues, as seen in GitHub discontinuing their display in 2014. Use Cases for Git Notes Adding documentation to commits (e.g., explaining why a specific change was made). Code reviews and feedback without altering the commit. Tracking external information (e.g., bug tracker IDs or task numbers) linked to a commit. Tracking time per commit without altering the commit. Adding Notes to Commits You can add notes to any commit using the git notes add command. By default, notes are added to the most recent commit. Example 1: Adding a Note to the Latest Commit First, create a new commit: git commit -m \"Initial commit\" Now, add a note to this commit: git notes add -m \"This is an extra explanation for the initial commit.\" You can inspect the note with: git log --show-notes Output: commit <hash> Author: Your Name <you@example.com> Date: <date> Initial commit Notes: This is an extra explanation for the initial commit. Example 2: Adding Notes to a Specific Commit To add a note to a specific commit, you need to specify the commit hash: git notes add -m \"Fixes bug #1234.\" <commit_hash> Now if you check the logs: git log --show-notes You\u2019ll see: commit <commit_hash> Author: Your Name <you@example.com> Date: <date> Some previous commit message Notes: Fixes bug #1234. Viewing Notes To view notes attached to commits, use: git log --show-notes Alternatively, to view the note for a specific commit: git notes show <commit_hash> Editing Notes If you need to modify a note after it\u2019s been created, use: git notes edit <commit_hash> This will open your default editor where you can modify the note. Removing Notes To delete a note from a commit: git notes remove <commit_hash> Listing All Notes To list all notes in your repository: git notes list This will display all the commit hashes along with their associated notes. Merging Notes When collaborating on a project, different contributors might add notes to the same commit. Git provides a way to merge these notes. Example: Merging Notes First, fetch the notes from the remote repository: git fetch origin refs/notes/*:refs/notes/* Then, merge the notes from another branch: git notes merge Splitting Notes by Ref Namespace You can have multiple sets of notes for the same commit by specifying different namespaces. By default, notes are saved under the refs/notes/commits reference, but you can store them elsewhere using the --ref option. Example: Using a Custom Namespace for Notes Add notes under a different reference (e.g., refs/notes/review ): git notes --ref = review add -m \"This commit has passed the review.\" <commit_hash> To view these notes: git log --show-notes = review This allows you to have multiple categories of notes, such as code reviews or documentation , without conflicting with one another. Notes with Multiple Lines If you want to add a note with multiple lines, use: git notes add This will open the default editor, where you can write your multi-line note. Alternatively, you can use: git notes add -m \"First line\" -m \"Second line\" Storing Notes in Remote Repositories By default, notes are not pushed to remotes. You need to explicitly push and fetch notes. Example: Pushing Notes to a Remote To push notes to a remote repository: git push origin refs/notes/commits Example: Fetching Notes from a Remote To fetch notes from a remote: git fetch origin refs/notes/commits:refs/notes/commits Why Git Notes Face Usability Challenges Despite their potential, Git notes have limited adoption due to usability challenges and limited toolchain support. For example, GitHub supported displaying notes for a time, but discontinued this feature in 2014 due to low usage and technical limitations. Lack of visibility: Notes are not shown in a default git log output unless explicitly requested with git log --show-notes. This can make them \"invisible\" to most users unless they are aware of the feature. Not synchronized by default: Notes are not pushed or fetched by default when collaborating with remote repositories. Developers must manually handle pushing and fetching notes using commands like git push origin refs/notes/commits and git fetch origin refs/notes/commits:refs/notes/commits. Toolchain integration: Many popular Git hosting services (e.g., GitHub, GitLab) and GUIs do not natively support Git notes in their interfaces. This limits their visibility and usefulness in typical workflows, which focus more on commit messages and branch structures. Conclusion git notes provides a flexible way to attach additional metadata to commits without modifying them. This feature is particularly useful for attaching comments, reviews, or documentation to commits, and can be customized by namespaces for different purposes. It\u2019s also a great way to keep a clean history while still having the context you need.","title":"Adding Notes"},{"location":"More/git_notes/#use-cases-for-git-notes","text":"Adding documentation to commits (e.g., explaining why a specific change was made). Code reviews and feedback without altering the commit. Tracking external information (e.g., bug tracker IDs or task numbers) linked to a commit. Tracking time per commit without altering the commit.","title":"Use Cases for Git Notes"},{"location":"More/git_notes/#adding-notes-to-commits","text":"You can add notes to any commit using the git notes add command. By default, notes are added to the most recent commit.","title":"Adding Notes to Commits"},{"location":"More/git_notes/#example-1-adding-a-note-to-the-latest-commit","text":"First, create a new commit: git commit -m \"Initial commit\" Now, add a note to this commit: git notes add -m \"This is an extra explanation for the initial commit.\" You can inspect the note with: git log --show-notes Output: commit <hash> Author: Your Name <you@example.com> Date: <date> Initial commit Notes: This is an extra explanation for the initial commit.","title":"Example 1: Adding a Note to the Latest Commit"},{"location":"More/git_notes/#example-2-adding-notes-to-a-specific-commit","text":"To add a note to a specific commit, you need to specify the commit hash: git notes add -m \"Fixes bug #1234.\" <commit_hash> Now if you check the logs: git log --show-notes You\u2019ll see: commit <commit_hash> Author: Your Name <you@example.com> Date: <date> Some previous commit message Notes: Fixes bug #1234.","title":"Example 2: Adding Notes to a Specific Commit"},{"location":"More/git_notes/#viewing-notes","text":"To view notes attached to commits, use: git log --show-notes Alternatively, to view the note for a specific commit: git notes show <commit_hash>","title":"Viewing Notes"},{"location":"More/git_notes/#editing-notes","text":"If you need to modify a note after it\u2019s been created, use: git notes edit <commit_hash> This will open your default editor where you can modify the note.","title":"Editing Notes"},{"location":"More/git_notes/#removing-notes","text":"To delete a note from a commit: git notes remove <commit_hash>","title":"Removing Notes"},{"location":"More/git_notes/#listing-all-notes","text":"To list all notes in your repository: git notes list This will display all the commit hashes along with their associated notes.","title":"Listing All Notes"},{"location":"More/git_notes/#merging-notes","text":"When collaborating on a project, different contributors might add notes to the same commit. Git provides a way to merge these notes.","title":"Merging Notes"},{"location":"More/git_notes/#example-merging-notes","text":"First, fetch the notes from the remote repository: git fetch origin refs/notes/*:refs/notes/* Then, merge the notes from another branch: git notes merge","title":"Example: Merging Notes"},{"location":"More/git_notes/#splitting-notes-by-ref-namespace","text":"You can have multiple sets of notes for the same commit by specifying different namespaces. By default, notes are saved under the refs/notes/commits reference, but you can store them elsewhere using the --ref option.","title":"Splitting Notes by Ref Namespace"},{"location":"More/git_notes/#example-using-a-custom-namespace-for-notes","text":"Add notes under a different reference (e.g., refs/notes/review ): git notes --ref = review add -m \"This commit has passed the review.\" <commit_hash> To view these notes: git log --show-notes = review This allows you to have multiple categories of notes, such as code reviews or documentation , without conflicting with one another.","title":"Example: Using a Custom Namespace for Notes"},{"location":"More/git_notes/#notes-with-multiple-lines","text":"If you want to add a note with multiple lines, use: git notes add This will open the default editor, where you can write your multi-line note. Alternatively, you can use: git notes add -m \"First line\" -m \"Second line\"","title":"Notes with Multiple Lines"},{"location":"More/git_notes/#storing-notes-in-remote-repositories","text":"By default, notes are not pushed to remotes. You need to explicitly push and fetch notes.","title":"Storing Notes in Remote Repositories"},{"location":"More/git_notes/#example-pushing-notes-to-a-remote","text":"To push notes to a remote repository: git push origin refs/notes/commits","title":"Example: Pushing Notes to a Remote"},{"location":"More/git_notes/#example-fetching-notes-from-a-remote","text":"To fetch notes from a remote: git fetch origin refs/notes/commits:refs/notes/commits","title":"Example: Fetching Notes from a Remote"},{"location":"More/git_notes/#why-git-notes-face-usability-challenges","text":"Despite their potential, Git notes have limited adoption due to usability challenges and limited toolchain support. For example, GitHub supported displaying notes for a time, but discontinued this feature in 2014 due to low usage and technical limitations. Lack of visibility: Notes are not shown in a default git log output unless explicitly requested with git log --show-notes. This can make them \"invisible\" to most users unless they are aware of the feature. Not synchronized by default: Notes are not pushed or fetched by default when collaborating with remote repositories. Developers must manually handle pushing and fetching notes using commands like git push origin refs/notes/commits and git fetch origin refs/notes/commits:refs/notes/commits. Toolchain integration: Many popular Git hosting services (e.g., GitHub, GitLab) and GUIs do not natively support Git notes in their interfaces. This limits their visibility and usefulness in typical workflows, which focus more on commit messages and branch structures.","title":"Why Git Notes Face Usability Challenges"},{"location":"More/git_notes/#conclusion","text":"git notes provides a flexible way to attach additional metadata to commits without modifying them. This feature is particularly useful for attaching comments, reviews, or documentation to commits, and can be customized by namespaces for different purposes. It\u2019s also a great way to keep a clean history while still having the context you need.","title":"Conclusion"},{"location":"More/git_replace/","text":"The git replace command in Git allows you to create replacement objects, which can be used to substitute one Git object with another. This feature is particularly useful for rewriting commit history, testing changes without altering the original objects, and temporarily substituting parts of your repository for debugging or other purposes. git replace <old-object> <new-object> old-object : The SHA-1 hash of the object you want to replace. new-object : The SHA-1 hash of the replacement object. Basic Usage Creating a Replacement Suppose you have two commit objects, and you want to replace commit1 with commit2 . Identify the SHA-1 hashes of the two commits: git log Let's say commit1 has the SHA-1 abcdef123456... and commit2 has 123456abcdef... . Create the replacement: git replace abcdef123456 123456abcdef This command tells Git to use commit2 whenever it encounters commit1 . Listing Replacements To list all existing replacements, use: git replace -l Deleting a Replacement To delete a replacement, use: git replace -d <old-object> For example: git replace -d abcdef123456 Use Cases for git replace Testing Changes : You can test changes by creating replacement objects without altering the original repository history. Rewriting History : Temporarily rewrite parts of your history for demonstrations or experiments. Debugging : Substitute objects to debug issues in different parts of the repository. Examples Example 1: Replacing a Commit Imagine you have a commit history like this: A -- B -- C -- D (master) You want to replace commit C with a new commit C' for testing purposes. Create a new commit C' : git checkout -b temp-branch C echo \"New changes\" > file.txt git add file.txt git commit -m \"Commit C'\" Identify the SHA-1 hashes of C and C' : git log Let's say C is ccccc and C' is ddddd . Replace C with C' : git replace ccccc ddddd Verify the replacement: git log You should see that the history now shows C' instead of C . Example 2: Replacing a Blob (File Content) Suppose you have a file file.txt with an object ID blob1 , and you want to replace its content with another blob blob2 . Identify the SHA-1 hash of the blobs: git hash-object file.txt Create a new blob: echo \"New content\" > new_file.txt git hash-object -w new_file.txt Let's say blob1 is bbbbb and blob2 is fffff . Replace blob1 with blob2 : git replace bbbbb fffff Verify the replacement: git cat-file -p bbbbb This should show the content of blob2 instead of blob1 . Important Notes Temporary Nature : The replacements are temporary and only affect your local repository unless explicitly shared with others. Sharing Replacements : To share the replacements, you need to push the .git/refs/replace/ namespace to the remote repository: git push origin refs/replace/* Removal of Replacements : When you no longer need the replacement, remove it using the -d flag as shown earlier. Using git replace , you can flexibly manage and test changes in your repository without permanently altering your commit history or object data.","title":"Replace"},{"location":"More/git_replace/#basic-usage","text":"","title":"Basic Usage"},{"location":"More/git_replace/#creating-a-replacement","text":"Suppose you have two commit objects, and you want to replace commit1 with commit2 . Identify the SHA-1 hashes of the two commits: git log Let's say commit1 has the SHA-1 abcdef123456... and commit2 has 123456abcdef... . Create the replacement: git replace abcdef123456 123456abcdef This command tells Git to use commit2 whenever it encounters commit1 .","title":"Creating a Replacement"},{"location":"More/git_replace/#listing-replacements","text":"To list all existing replacements, use: git replace -l","title":"Listing Replacements"},{"location":"More/git_replace/#deleting-a-replacement","text":"To delete a replacement, use: git replace -d <old-object> For example: git replace -d abcdef123456","title":"Deleting a Replacement"},{"location":"More/git_replace/#use-cases-for-git-replace","text":"Testing Changes : You can test changes by creating replacement objects without altering the original repository history. Rewriting History : Temporarily rewrite parts of your history for demonstrations or experiments. Debugging : Substitute objects to debug issues in different parts of the repository.","title":"Use Cases for git replace"},{"location":"More/git_replace/#examples","text":"","title":"Examples"},{"location":"More/git_replace/#example-1-replacing-a-commit","text":"Imagine you have a commit history like this: A -- B -- C -- D (master) You want to replace commit C with a new commit C' for testing purposes. Create a new commit C' : git checkout -b temp-branch C echo \"New changes\" > file.txt git add file.txt git commit -m \"Commit C'\" Identify the SHA-1 hashes of C and C' : git log Let's say C is ccccc and C' is ddddd . Replace C with C' : git replace ccccc ddddd Verify the replacement: git log You should see that the history now shows C' instead of C .","title":"Example 1: Replacing a Commit"},{"location":"More/git_replace/#example-2-replacing-a-blob-file-content","text":"Suppose you have a file file.txt with an object ID blob1 , and you want to replace its content with another blob blob2 . Identify the SHA-1 hash of the blobs: git hash-object file.txt Create a new blob: echo \"New content\" > new_file.txt git hash-object -w new_file.txt Let's say blob1 is bbbbb and blob2 is fffff . Replace blob1 with blob2 : git replace bbbbb fffff Verify the replacement: git cat-file -p bbbbb This should show the content of blob2 instead of blob1 .","title":"Example 2: Replacing a Blob (File Content)"},{"location":"More/git_replace/#important-notes","text":"Temporary Nature : The replacements are temporary and only affect your local repository unless explicitly shared with others. Sharing Replacements : To share the replacements, you need to push the .git/refs/replace/ namespace to the remote repository: git push origin refs/replace/* Removal of Replacements : When you no longer need the replacement, remove it using the -d flag as shown earlier. Using git replace , you can flexibly manage and test changes in your repository without permanently altering your commit history or object data.","title":"Important Notes"},{"location":"More/git_rerere/","text":"git rerere (reuse recorded resolution) is a useful tool for handling repeated merge conflicts in Git. When enabled, Git records how you resolve a merge conflict and automatically applies the same resolution if the same conflict occurs again in the future. This can be a significant time saver when working on long-lived branches or frequently rebasing/merging. This same tactic can be used if you want to keep a branch rebased so you don\u2019t have to deal with the same rebasing conflicts each time you do it. Or if you want to take a branch that you merged and fixed a bunch of conflicts and then decide to rebase it instead\u2009\u2014\u2009you likely won\u2019t have to do all the same conflicts again. Enabling git rerere Before you can use git rerere , you need to enable it. You can do this globally or per repository: # Enable rerere globally git config --global rerere.enabled true # Enable rerere for a specific repository git config rerere.enabled true You can also turn it on by creating the .git/rr-cache directory in a specific repository, but the config setting is clearer and enables that feature globally for you. Basic Usage Setup a Scenario for git rerere Let's set up a scenario where git rerere can be useful. Consider two branches that both modify the same line in a file: # Create a new repository mkdir rerere-example cd rerere-example git init # Create a file and commit it echo \"Line 1\" > file.txt git add file.txt git commit -m \"Initial commit\" # Create a new branch and modify the file git checkout -b branch1 echo \"Line 1 - branch1\" > file.txt git commit -am \"Change in branch1\" # Switch back to master and create another branch with a conflicting change git checkout master git checkout -b branch2 echo \"Line 1 - branch2\" > file.txt git commit -am \"Change in branch2\" Merge with Conflict Merge branch1 into branch2 , causing a conflict: git checkout branch2 git merge branch1 When rerere is enabled, the merge will output an additional line in the log: Recorded preimage for FILE Otherwise it should look exactly like a normal merge conflict. At this point, rerere can tell us a few things. Normally, you might run git status at this point to see what all conflicted. However, git rerere will also tell you what it has recorded the pre-merge state for with git rerere status. git rerere status And git rerere diff will show the current state of the resolution\u2009\u2014\u2009what you started with to resolve and what you\u2019ve resolved it to. git rerere diff Also (and this isn\u2019t really related to rerere), you can use git ls-files -u to see the conflicted files and the before, left and right versions of the file. git ls-files -u Resolve the conflict manually: # Edit file.txt to resolve the conflict # For example, make the file content: \"Line 1 - resolved\" echo \"Line 1 - resolved\" > file.txt git add file.txt git commit -m \"Resolve conflict between branch1 and branch2\" You can see that it \"Recorded resolution for FILE\". You can run git rerere diff again to see what rerere will remember. Reuse Recorded Resolution Now, let's create another conflict scenario to see git rerere in action: # Create a new conflicting branch git checkout master git checkout -b branch3 echo \"Line 1 - branch3\" > file.txt git commit -am \"Change in branch3\" # Merge branch1 into branch3, causing the same conflict git merge branch1 At this point, git rerere automatically recognizes the conflict and reuses the previously recorded resolution: # Git should have automatically resolved the conflict # Check the resolution cat file.txt # The content should be: \"Line 1 - resolved\" There should be in the output a line, Resolved FILE using previous resolution. Also, git diff will show you how it was automatically re-resolved. You can also recreate the conflicted file state with git checkout. git checkout --conflict = merge file.txt Finalize the Merge Finalize the merge with the reused resolution: git add file.txt git commit -m # Automatically resolve conflict between branch1 and branch3 using rerere. Viewing and Managing git rerere Data You can view recorded resolutions and manage them: # List conflicts that have been recorded by rerere ls .git/rr-cache # Clean up old recorded resolutions git rerere gc Summary git rerere is an advanced Git tool that records conflict resolutions and reuses them in future conflicts, saving time and effort when dealing with repeated conflicts. It is particularly useful in workflows involving frequent rebasing or merging, where the same conflicts might appear multiple times. By enabling rerere and leveraging its capabilities, you can streamline your conflict resolution process significantly.","title":"Reuse Recorded Resolution"},{"location":"More/git_rerere/#enabling-git-rerere","text":"Before you can use git rerere , you need to enable it. You can do this globally or per repository: # Enable rerere globally git config --global rerere.enabled true # Enable rerere for a specific repository git config rerere.enabled true You can also turn it on by creating the .git/rr-cache directory in a specific repository, but the config setting is clearer and enables that feature globally for you.","title":"Enabling git rerere"},{"location":"More/git_rerere/#basic-usage","text":"","title":"Basic Usage"},{"location":"More/git_rerere/#setup-a-scenario-for-git-rerere","text":"Let's set up a scenario where git rerere can be useful. Consider two branches that both modify the same line in a file: # Create a new repository mkdir rerere-example cd rerere-example git init # Create a file and commit it echo \"Line 1\" > file.txt git add file.txt git commit -m \"Initial commit\" # Create a new branch and modify the file git checkout -b branch1 echo \"Line 1 - branch1\" > file.txt git commit -am \"Change in branch1\" # Switch back to master and create another branch with a conflicting change git checkout master git checkout -b branch2 echo \"Line 1 - branch2\" > file.txt git commit -am \"Change in branch2\"","title":"Setup a Scenario for git rerere"},{"location":"More/git_rerere/#merge-with-conflict","text":"Merge branch1 into branch2 , causing a conflict: git checkout branch2 git merge branch1 When rerere is enabled, the merge will output an additional line in the log: Recorded preimage for FILE Otherwise it should look exactly like a normal merge conflict. At this point, rerere can tell us a few things. Normally, you might run git status at this point to see what all conflicted. However, git rerere will also tell you what it has recorded the pre-merge state for with git rerere status. git rerere status And git rerere diff will show the current state of the resolution\u2009\u2014\u2009what you started with to resolve and what you\u2019ve resolved it to. git rerere diff Also (and this isn\u2019t really related to rerere), you can use git ls-files -u to see the conflicted files and the before, left and right versions of the file. git ls-files -u Resolve the conflict manually: # Edit file.txt to resolve the conflict # For example, make the file content: \"Line 1 - resolved\" echo \"Line 1 - resolved\" > file.txt git add file.txt git commit -m \"Resolve conflict between branch1 and branch2\" You can see that it \"Recorded resolution for FILE\". You can run git rerere diff again to see what rerere will remember.","title":"Merge with Conflict"},{"location":"More/git_rerere/#reuse-recorded-resolution","text":"Now, let's create another conflict scenario to see git rerere in action: # Create a new conflicting branch git checkout master git checkout -b branch3 echo \"Line 1 - branch3\" > file.txt git commit -am \"Change in branch3\" # Merge branch1 into branch3, causing the same conflict git merge branch1 At this point, git rerere automatically recognizes the conflict and reuses the previously recorded resolution: # Git should have automatically resolved the conflict # Check the resolution cat file.txt # The content should be: \"Line 1 - resolved\" There should be in the output a line, Resolved FILE using previous resolution. Also, git diff will show you how it was automatically re-resolved. You can also recreate the conflicted file state with git checkout. git checkout --conflict = merge file.txt","title":"Reuse Recorded Resolution"},{"location":"More/git_rerere/#finalize-the-merge","text":"Finalize the merge with the reused resolution: git add file.txt git commit -m # Automatically resolve conflict between branch1 and branch3 using rerere.","title":"Finalize the Merge"},{"location":"More/git_rerere/#viewing-and-managing-git-rerere-data","text":"You can view recorded resolutions and manage them: # List conflicts that have been recorded by rerere ls .git/rr-cache # Clean up old recorded resolutions git rerere gc","title":"Viewing and Managing git rerere Data"},{"location":"More/git_rerere/#summary","text":"git rerere is an advanced Git tool that records conflict resolutions and reuses them in future conflicts, saving time and effort when dealing with repeated conflicts. It is particularly useful in workflows involving frequent rebasing or merging, where the same conflicts might appear multiple times. By enabling rerere and leveraging its capabilities, you can streamline your conflict resolution process significantly.","title":"Summary"},{"location":"More/git_search/","text":"Git offers several tools and commands for searching through your repository's history and content. These tools provide powerful capabilities for searching through your repository's history and content, allowing you to find specific commits, changes, or patterns quickly and efficiently. git grep The git grep command searches through the contents of files in the repository for a specific pattern. It supports options like --all-match to match all patterns, --ignore-case for case-insensitive searches, and --extended-regexp to use extended regular expressions. git grep <pattern> : Searches for the specified <pattern> in the contents of tracked files within the Git repository. Basic Usage git grep \"search_string\" This command searches for \"search_string\" in all tracked files in the repository. Search in Specific Files # Searches for \"pattern\" only in `file1.txt` and `file2.txt`. git grep \"pattern\" file1.txt file2.txt Options -i or --ignore-case : Performs a Case-Insensitive Search . # Performs a case-insensitive search for \"pattern\". git grep -i \"pattern\" -n or --line-number : Shows line numbers where the pattern is found. # Shows line numbers where \"pattern\" is found. git grep -n \"pattern\" -w or --word-regexp : Search for Whole Words # Matches \"pattern\" as a whole word only. git grep -w \"pattern\" -e <pattern> : Search for Multiple Patterns # Searches for both \"pattern1\" and \"pattern2\". git grep -e \"pattern1\" -e \"pattern2\" --cached : Searches staged changes instead of working directory files. git grep --cached \"pattern\" -I : Excludes files that match patterns from .gitignore and .git/info/exclude . git grep -I \"pattern\" --untracked : Includes untracked files in the search. git grep --untracked \"pattern\" --all-match : Only lines containing all of the specified patterns are matched. git grep --all-match \"pattern1\" \"pattern2\" By default, when you provide multiple patterns, git grep matches lines containing any of the provided patterns. With --all-match , only lines containing all patterns are considered matches. --extended-regexp : This option allows you to use extended regular expressions (ERE) instead of the default basic regular expressions (BRE). Extended regular expressions provide additional features such as alternation ( | ), grouping ( () ), and quantifiers ( {} , ? , * , + ) which can make pattern matching more flexible and powerful. git grep --extended-regexp \"pattern1|pattern2\" -c or --count : Only display a count of the lines that match the given pattern. git grep -c \"pattern\" This command searches for \"pattern\" in all tracked files and displays the total count of lines matching the pattern across all files, rather than displaying the actual matching lines themselves. This can be useful when you're interested in the total number of occurrences of a pattern across multiple files, rather than the specific lines where the pattern occurs. -p or --show-function option in git grep allows you to display the surrounding function context of the matched lines, providing more context for each match. This can be particularly useful when searching through source code files where functions are defined. git grep -p \"pattern\" git log The git log command displays the commit history of the repository. It allows you to search for commits based on various criteria such as author, date range, commit message, and paths affected. You can use options like --grep to search for commits with specific patterns in their commit messages. Perhaps you\u2019re looking not for where a term exists, but when it existed or was introduced. The git log command has a number of powerful tools for finding specific commits by the content of their messages or even the content of the diff they introduce. git log --grep To search the commit log (across all branches) for the given text: git log --all --grep = 'Build 0051' To do so while ignoring case in the grep search: git log --all -i --grep = 'Build 0051' To search the actual content of commits through a repo's history, use: git grep 'Build 0051' $( git rev-list --all ) to show all instances of the given text, the containing file name, and the commit sha1. And to do this while ignoring case, use: git grep -i 'Build 0051' $( git rev-list --all ) Note that this searches the entire content of the commit at each stage, and not just the diff changes. To search just the diff changes, use one of the following: git log -S (Git \u201cpickaxe\u201d option) The -S option with git log allows you to search for commits that introduced or removed specific strings of text. It's useful for finding commits that added or removed specific functionality or code snippets. git log -S \"string\" --oneline If you need to be more specific, you can provide a regular expression to search for with the -G option. git log -G The -G option with git log allows you to search for commits that changed the number of occurrences of a specific regular expression. It's useful for finding commits that modified specific patterns in the codebase. git log -G \"pattern\" To illustrate the difference between -S --pickaxe-regex and -G , consider a commit with the following diff in the same file: + return frotz ( nitfol, two->ptr, 1 , 0 ) ; ... - hit = frotz ( nitfol, mf2.ptr, 1 , 0 ) ; While git log -G\"frotz\\(nitfol\" will show this commit, git log -S\"frotz\\(nitfol\" --pickaxe-regex will not (because the number of occurrences of that string did not change). Unless --text is supplied patches of binary files without a textconv filter will be ignored. Line Log Search git log with the -L option, and it will show you the history of a function or line of code in your codebase. git log -L '/int main/' ,/^ } /:main.c #Shows how the function main() in the file main.c evolved over time. For example, if we wanted to see every change made to the function git_deflate_bound in the zlib.c file, we could run git log -L :git_deflate_bound:zlib.c This will try to figure out what the bounds of that function are and then look through the history and show us every change that was made to the function as a series of patches back to when the function was first created. You could also give it a range of lines or a single line number and you\u2019ll get the same sort of output. git blame The git blame command shows the revision and author of each line in a file. It's useful for identifying when and by whom each line was last modified. You can use it to track down the origin of specific changes. git rev-list The git rev-list command lists commit objects in reverse chronological order. It can be combined with other commands like git grep or git log to search for commits that match specific criteria. git rev-list is a powerful and flexible command in Git used to list commit objects in reverse chronological order. It can be applied in various ways, from simple listing of commits to more advanced filtering options. Here are some common uses of git rev-list with explanations and examples. Basic Usage of git rev-list git rev-list [ options ] [ <commit>... ] <commit> : The starting point for listing commits. If none is provided, it defaults to HEAD . Options : A variety of options are available to control the output, such as limiting the number of commits, excluding certain commits, or showing only merge commits. Common Use Cases List All Commits in a Branch This is the most basic use of git rev-list . You can list all the commits in the current branch (or any other branch) in reverse chronological order. Example: git rev-list HEAD This lists all commits from the current HEAD to the beginning of the history. Limit the Number of Commits You can limit the number of commits returned by using the --max-count option. Example: git rev-list HEAD --max-count = 5 This command lists the most recent 5 commits from the current HEAD . List Commits Between Two Branches git rev-list can also be used to show commits that are unique to one branch compared to another. Example: git rev-list branchA --not branchB This shows all the commits that exist on branchA but are not present on branchB . List Commits Within a Time Range You can filter commits by specifying a date range using the --since and --until options. Example: git rev-list HEAD --since = \"2 weeks ago\" This command lists all commits from the last two weeks. You can also combine --since and --until to specify a more specific date range: git rev-list HEAD --since = \"2023-01-01\" --until = \"2023-02-01\" List Commits by Author You can filter commits by a specific author using the --author option. Example: git rev-list HEAD --author = \"John Doe\" This lists all commits authored by \"John Doe\" in the current branch. List Commits with a Specific Message If you're looking for commits with a particular keyword in the commit message, use the --grep option. Example: git rev-list HEAD --grep = \"fix bug\" This will list all commits whose commit messages contain \"fix bug\". List Only Merge Commits Sometimes you want to list only merge commits. This can be done using the --merges option. Example: git rev-list HEAD --merges This will show only the merge commits in the current branch. List Commits That Introduced a Specific File You can use git rev-list to trace the history of a file to find out when it was introduced or modified. Example: git rev-list HEAD -- <file-path> This lists all commits that modified the specified file. List Commits that Changed Files in a Given Directory If you want to list the commits that modified files in a specific directory, you can provide the directory path. Example: git rev-list HEAD -- path/to/directory/ This shows all commits that affected the files in the specified directory. Find Commits That Introduced a Bug (via Bisecting) You can use git rev-list in combination with git bisect to find a bug in the code by reviewing only a subset of commits. Example: git bisect start HEAD <bad-commit> git rev-list --bisect HEAD <bad-commit> This can help you narrow down the range of commits to find the specific one that introduced the issue. Counting Commits If you want to know how many commits exist in a certain range or branch, you can combine git rev-list with --count . Example: git rev-list --count HEAD This outputs the total number of commits in the current branch. View the SHA-1s of all Parents of a Commit You can view the parent commits for a given commit using git rev-list . Example: git rev-list --parents HEAD This will display each commit and its parent(s). For merge commits, more than one parent will be shown. Advanced Options --all-match Use --all-match to show only the commits that match all the given --grep and --author conditions. Example: git rev-list HEAD --grep = \"fix\" --author = \"John\" --all-match This lists commits where the message contains \"fix\" and the author is \"John\". --extended-regexp This option enables the use of extended regular expressions in commit message filtering. Example: git rev-list HEAD --grep = '(fix|bug)' --extended-regexp This command lists all commits where the message contains either \"fix\" or \"bug\". --bisect The --bisect option is used to mark commits for binary searching (bisecting) to find which commit introduced a bug or a feature. Example: git rev-list --bisect <bad-commit> This shows the list of commits to be tested during a bisect operation to locate an issue. git show The git show command displays information about a specific commit. You can use it to view the changes introduced by a commit and search for specific patterns within those changes. These tools provide powerful capabilities for searching through your repository's history and content, allowing you to find specific commits, changes, or patterns quickly and efficiently.","title":"Searching Tools"},{"location":"More/git_search/#git-grep","text":"The git grep command searches through the contents of files in the repository for a specific pattern. It supports options like --all-match to match all patterns, --ignore-case for case-insensitive searches, and --extended-regexp to use extended regular expressions. git grep <pattern> : Searches for the specified <pattern> in the contents of tracked files within the Git repository. Basic Usage git grep \"search_string\" This command searches for \"search_string\" in all tracked files in the repository. Search in Specific Files # Searches for \"pattern\" only in `file1.txt` and `file2.txt`. git grep \"pattern\" file1.txt file2.txt","title":"git grep"},{"location":"More/git_search/#options","text":"-i or --ignore-case : Performs a Case-Insensitive Search . # Performs a case-insensitive search for \"pattern\". git grep -i \"pattern\" -n or --line-number : Shows line numbers where the pattern is found. # Shows line numbers where \"pattern\" is found. git grep -n \"pattern\" -w or --word-regexp : Search for Whole Words # Matches \"pattern\" as a whole word only. git grep -w \"pattern\" -e <pattern> : Search for Multiple Patterns # Searches for both \"pattern1\" and \"pattern2\". git grep -e \"pattern1\" -e \"pattern2\" --cached : Searches staged changes instead of working directory files. git grep --cached \"pattern\" -I : Excludes files that match patterns from .gitignore and .git/info/exclude . git grep -I \"pattern\" --untracked : Includes untracked files in the search. git grep --untracked \"pattern\" --all-match : Only lines containing all of the specified patterns are matched. git grep --all-match \"pattern1\" \"pattern2\" By default, when you provide multiple patterns, git grep matches lines containing any of the provided patterns. With --all-match , only lines containing all patterns are considered matches. --extended-regexp : This option allows you to use extended regular expressions (ERE) instead of the default basic regular expressions (BRE). Extended regular expressions provide additional features such as alternation ( | ), grouping ( () ), and quantifiers ( {} , ? , * , + ) which can make pattern matching more flexible and powerful. git grep --extended-regexp \"pattern1|pattern2\" -c or --count : Only display a count of the lines that match the given pattern. git grep -c \"pattern\" This command searches for \"pattern\" in all tracked files and displays the total count of lines matching the pattern across all files, rather than displaying the actual matching lines themselves. This can be useful when you're interested in the total number of occurrences of a pattern across multiple files, rather than the specific lines where the pattern occurs. -p or --show-function option in git grep allows you to display the surrounding function context of the matched lines, providing more context for each match. This can be particularly useful when searching through source code files where functions are defined. git grep -p \"pattern\"","title":"Options"},{"location":"More/git_search/#git-log","text":"The git log command displays the commit history of the repository. It allows you to search for commits based on various criteria such as author, date range, commit message, and paths affected. You can use options like --grep to search for commits with specific patterns in their commit messages. Perhaps you\u2019re looking not for where a term exists, but when it existed or was introduced. The git log command has a number of powerful tools for finding specific commits by the content of their messages or even the content of the diff they introduce.","title":"git log"},{"location":"More/git_search/#git-log-grep","text":"To search the commit log (across all branches) for the given text: git log --all --grep = 'Build 0051' To do so while ignoring case in the grep search: git log --all -i --grep = 'Build 0051' To search the actual content of commits through a repo's history, use: git grep 'Build 0051' $( git rev-list --all ) to show all instances of the given text, the containing file name, and the commit sha1. And to do this while ignoring case, use: git grep -i 'Build 0051' $( git rev-list --all ) Note that this searches the entire content of the commit at each stage, and not just the diff changes. To search just the diff changes, use one of the following:","title":"git log --grep"},{"location":"More/git_search/#git-log-s-git-pickaxe-option","text":"The -S option with git log allows you to search for commits that introduced or removed specific strings of text. It's useful for finding commits that added or removed specific functionality or code snippets. git log -S \"string\" --oneline If you need to be more specific, you can provide a regular expression to search for with the -G option.","title":"git log -S (Git \u201cpickaxe\u201d option)"},{"location":"More/git_search/#git-log-g","text":"The -G option with git log allows you to search for commits that changed the number of occurrences of a specific regular expression. It's useful for finding commits that modified specific patterns in the codebase. git log -G \"pattern\" To illustrate the difference between -S --pickaxe-regex and -G , consider a commit with the following diff in the same file: + return frotz ( nitfol, two->ptr, 1 , 0 ) ; ... - hit = frotz ( nitfol, mf2.ptr, 1 , 0 ) ; While git log -G\"frotz\\(nitfol\" will show this commit, git log -S\"frotz\\(nitfol\" --pickaxe-regex will not (because the number of occurrences of that string did not change). Unless --text is supplied patches of binary files without a textconv filter will be ignored.","title":"git log -G"},{"location":"More/git_search/#line-log-search","text":"git log with the -L option, and it will show you the history of a function or line of code in your codebase. git log -L '/int main/' ,/^ } /:main.c #Shows how the function main() in the file main.c evolved over time. For example, if we wanted to see every change made to the function git_deflate_bound in the zlib.c file, we could run git log -L :git_deflate_bound:zlib.c This will try to figure out what the bounds of that function are and then look through the history and show us every change that was made to the function as a series of patches back to when the function was first created. You could also give it a range of lines or a single line number and you\u2019ll get the same sort of output.","title":"Line Log Search"},{"location":"More/git_search/#git-blame","text":"The git blame command shows the revision and author of each line in a file. It's useful for identifying when and by whom each line was last modified. You can use it to track down the origin of specific changes.","title":"git blame"},{"location":"More/git_search/#git-rev-list","text":"The git rev-list command lists commit objects in reverse chronological order. It can be combined with other commands like git grep or git log to search for commits that match specific criteria. git rev-list is a powerful and flexible command in Git used to list commit objects in reverse chronological order. It can be applied in various ways, from simple listing of commits to more advanced filtering options. Here are some common uses of git rev-list with explanations and examples.","title":"git rev-list"},{"location":"More/git_search/#basic-usage-of-git-rev-list","text":"git rev-list [ options ] [ <commit>... ] <commit> : The starting point for listing commits. If none is provided, it defaults to HEAD . Options : A variety of options are available to control the output, such as limiting the number of commits, excluding certain commits, or showing only merge commits.","title":"Basic Usage of git rev-list"},{"location":"More/git_search/#common-use-cases","text":"","title":"Common Use Cases"},{"location":"More/git_search/#advanced-options","text":"","title":"Advanced Options"},{"location":"More/git_search/#-all-match","text":"Use --all-match to show only the commits that match all the given --grep and --author conditions. Example: git rev-list HEAD --grep = \"fix\" --author = \"John\" --all-match This lists commits where the message contains \"fix\" and the author is \"John\".","title":"--all-match"},{"location":"More/git_search/#-extended-regexp","text":"This option enables the use of extended regular expressions in commit message filtering. Example: git rev-list HEAD --grep = '(fix|bug)' --extended-regexp This command lists all commits where the message contains either \"fix\" or \"bug\".","title":"--extended-regexp"},{"location":"More/git_search/#-bisect","text":"The --bisect option is used to mark commits for binary searching (bisecting) to find which commit introduced a bug or a feature. Example: git rev-list --bisect <bad-commit> This shows the list of commits to be tested during a bisect operation to locate an issue.","title":"--bisect"},{"location":"More/git_search/#git-show","text":"The git show command displays information about a specific commit. You can use it to view the changes introduced by a commit and search for specific patterns within those changes. These tools provide powerful capabilities for searching through your repository's history and content, allowing you to find specific commits, changes, or patterns quickly and efficiently.","title":"git show"},{"location":"More/git_sign/","text":"GPG Introduction GPG (GNU Privacy Guard) is a free and open-source software for secure communication and data encryption. In Git, GPG is used for cryptographic signing to verify the authenticity of commits and tags. When you sign a commit or tag with your GPG key, it proves that the changes were indeed made by you and haven't been tampered with. First of all, if you want to sign anything you need to get GPG configured and your personal key installed. gpg --list-keys If you don\u2019t have a key installed, you can generate one with gpg --gen-key. gpg --gen-key Once you have a private key to sign with, you can configure Git to use it for signing things by setting the user.signingkey config setting. git config --global user.signingkey 0A46826A! Now Git will use your key by default to sign tags and commits if you want. Signing Tags To sign a tag with GPG, you can use the -s or --sign option with the git tag command. For example: git tag -s v1.0 -m \"Release version 1.0\" This creates a signed tag v1.0 with the specified message. When someone verifies this tag, they can see that it's been signed by your GPG key. Verifying Tags To verify the authenticity of a signed tag, you can use the git tag -v command followed by the tag name. For example: git tag -v v1.0 Git will check the signature of the tag against the associated GPG public key and display whether the tag is valid or not. You need the signer\u2019s public key in your keyring for this to work properly. Adding the GPG Public Key to Your Keyring If you don't have the signer's public key and you want to obtain it and save it in your GPG keyring, you can follow these steps: Obtain the Public Key The signer can provide their public key in various ways: + Send it to you via email. + Upload it to a key server (e.g., pgp.mit.edu , keys.openpgp.org ). + Provide a URL where the public key can be downloaded. Import the Public Key Once you have obtained the public key, save it to a file on your system (e.g., signer_public_key.asc ). Use the gpg --import command to import the public key into your GPG keyring: gpg --import signer_public_key.asc Verify the Key After importing the public key, you should verify its fingerprint with the signer to ensure its authenticity. The fingerprint uniquely identifies the key and can be used to verify its integrity. gpg --fingerprint [ key_id ] Trust the Key (Optional) Once you have verified the key, you may choose to trust it to establish a level of confidence in the signer's identity: gpg --edit-key [ key_id ] trust Follow the prompts to set the trust level for the key. By following these steps, you can obtain the signer's public key, import it into your GPG keyring, and establish trust in their identity if desired. This allows you to verify their signatures and communicate securely with them using GPG encryption. Signing Commits To sign commits with GPG, you can use the -S or --gpg-sign option with the git commit command. For example: git commit -S -m \"Commit message\" This signs the commit with your GPG key. When others view the commit, they can verify its authenticity using your GPG public key. To see and verify these signatures, there is also a --show-signature option to git log. git log --show-signature -1 Additionally, you can configure git log to check any signatures it finds and list them in its output with the %G? format. git log --pretty = \"format:%h %G? %aN %s\" In Git 1.8.3 and later, git merge and git pull can be told to inspect and reject when merging a commit that does not carry a trusted GPG signature with the --verify-signatures command. git merge --verify-signatures signed-branch Summary GPG (GNU Privacy Guard) is used for cryptographic signing in Git to verify the authenticity of commits and tags. You can sign tags using the git tag -s command and verify them with git tag -v . Commits can be signed using the git commit -S command. GPG signing ensures the integrity and authenticity of your Git history, providing a layer of trust and security for your repository. Signing tags and commits is great, but if you decide to use this in your normal workflow, you\u2019ll have to make sure that everyone on your team understands how to do so. This can be achieved by asking everyone working with the repository to run git config --local commit.gpgsign true to automatically have all of their commits in the repository signed by default. If you don\u2019t, you\u2019ll end up spending a lot of time helping people figure out how to rewrite their commits with signed versions. Make sure you understand GPG and the benefits of signing things before adopting this as part of your standard workflow.","title":"Signing Commits"},{"location":"More/git_sign/#gpg-introduction","text":"GPG (GNU Privacy Guard) is a free and open-source software for secure communication and data encryption. In Git, GPG is used for cryptographic signing to verify the authenticity of commits and tags. When you sign a commit or tag with your GPG key, it proves that the changes were indeed made by you and haven't been tampered with. First of all, if you want to sign anything you need to get GPG configured and your personal key installed. gpg --list-keys If you don\u2019t have a key installed, you can generate one with gpg --gen-key. gpg --gen-key Once you have a private key to sign with, you can configure Git to use it for signing things by setting the user.signingkey config setting. git config --global user.signingkey 0A46826A! Now Git will use your key by default to sign tags and commits if you want.","title":"GPG Introduction"},{"location":"More/git_sign/#signing-tags","text":"To sign a tag with GPG, you can use the -s or --sign option with the git tag command. For example: git tag -s v1.0 -m \"Release version 1.0\" This creates a signed tag v1.0 with the specified message. When someone verifies this tag, they can see that it's been signed by your GPG key.","title":"Signing Tags"},{"location":"More/git_sign/#verifying-tags","text":"To verify the authenticity of a signed tag, you can use the git tag -v command followed by the tag name. For example: git tag -v v1.0 Git will check the signature of the tag against the associated GPG public key and display whether the tag is valid or not. You need the signer\u2019s public key in your keyring for this to work properly.","title":"Verifying Tags"},{"location":"More/git_sign/#adding-the-gpg-public-key-to-your-keyring","text":"If you don't have the signer's public key and you want to obtain it and save it in your GPG keyring, you can follow these steps: Obtain the Public Key The signer can provide their public key in various ways: + Send it to you via email. + Upload it to a key server (e.g., pgp.mit.edu , keys.openpgp.org ). + Provide a URL where the public key can be downloaded. Import the Public Key Once you have obtained the public key, save it to a file on your system (e.g., signer_public_key.asc ). Use the gpg --import command to import the public key into your GPG keyring: gpg --import signer_public_key.asc Verify the Key After importing the public key, you should verify its fingerprint with the signer to ensure its authenticity. The fingerprint uniquely identifies the key and can be used to verify its integrity. gpg --fingerprint [ key_id ] Trust the Key (Optional) Once you have verified the key, you may choose to trust it to establish a level of confidence in the signer's identity: gpg --edit-key [ key_id ] trust Follow the prompts to set the trust level for the key. By following these steps, you can obtain the signer's public key, import it into your GPG keyring, and establish trust in their identity if desired. This allows you to verify their signatures and communicate securely with them using GPG encryption.","title":"Adding the GPG Public Key to Your Keyring"},{"location":"More/git_sign/#signing-commits","text":"To sign commits with GPG, you can use the -S or --gpg-sign option with the git commit command. For example: git commit -S -m \"Commit message\" This signs the commit with your GPG key. When others view the commit, they can verify its authenticity using your GPG public key. To see and verify these signatures, there is also a --show-signature option to git log. git log --show-signature -1 Additionally, you can configure git log to check any signatures it finds and list them in its output with the %G? format. git log --pretty = \"format:%h %G? %aN %s\" In Git 1.8.3 and later, git merge and git pull can be told to inspect and reject when merging a commit that does not carry a trusted GPG signature with the --verify-signatures command. git merge --verify-signatures signed-branch","title":"Signing Commits"},{"location":"More/git_sign/#summary","text":"GPG (GNU Privacy Guard) is used for cryptographic signing in Git to verify the authenticity of commits and tags. You can sign tags using the git tag -s command and verify them with git tag -v . Commits can be signed using the git commit -S command. GPG signing ensures the integrity and authenticity of your Git history, providing a layer of trust and security for your repository. Signing tags and commits is great, but if you decide to use this in your normal workflow, you\u2019ll have to make sure that everyone on your team understands how to do so. This can be achieved by asking everyone working with the repository to run git config --local commit.gpgsign true to automatically have all of their commits in the repository signed by default. If you don\u2019t, you\u2019ll end up spending a lot of time helping people figure out how to rewrite their commits with signed versions. Make sure you understand GPG and the benefits of signing things before adopting this as part of your standard workflow.","title":"Summary"},{"location":"More/git_subtree/","text":"The git subtree command is a Git tool for managing subprojects within a single repository. Unlike submodules, it embeds the subproject's history directly into the main repository, simplifying management. This is especially useful when you want tighter integration with the subproject without requiring external references like submodules. When to Use git subtree Tightly Integrated Subprojects : When the subproject is essential and frequently changes alongside the main project. Simpler Contributor Workflow : Contributors don\u2019t need to initialize submodules separately. History Integration : The full history of the subproject is stored in the main repository, making it easier to view changes. No Dependency on .gitmodules : You don\u2019t rely on a separate .gitmodules file like in submodules. Avoiding Detached HEAD Issues : Subtrees don't require additional checkout mechanisms that submodules often need. Fewer Permissions Issues : Avoid the need for separate permissions or authentication for the subproject. Key git subtree Commands with Examples Adding a Subtree git subtree add --prefix = subdir-name https://github.com/username/repo.git main --squash --prefix=subdir-name : Directory where the subproject will be added. https://github.com/username/repo.git : URL of the subproject repository. main : The branch of the subproject to add. --squash : Combines the subproject history into a single commit. Example: git subtree add --prefix = lib/awesome-tool https://github.com/example/awesome-tool.git main --squash Adds the awesome-tool repository under the lib/ directory of the main project. Pulling Updates from the Subproject git subtree pull --prefix = subdir-name https://github.com/username/repo.git branch-name --squash - Merges updates from the subproject repository into the main repository. Example: git subtree pull --prefix = lib/awesome-tool https://github.com/example/awesome-tool.git main --squash Fetches and integrates updates from the main branch of the awesome-tool subproject. Pushing Changes Back to the Subproject git subtree push --prefix = subdir-name https://github.com/username/repo.git branch-name - Pushes changes made in the subtree back to the subproject repository. Example: git subtree push --prefix = lib/awesome-tool https://github.com/example/awesome-tool.git main Updates the main branch of the awesome-tool repository with changes made in the lib/awesome-tool directory. Splitting the Subproject If you want to extract the subtree into its own repository: git subtree split --prefix = subdir-name --branch = new-branch-name --prefix=subdir-name : Directory of the subtree. --branch=new-branch-name : Name of the branch to hold the extracted history. Example: git subtree split --prefix = lib/awesome-tool --branch = split-awesome-tool Creates a new branch ( split-awesome-tool ) containing only the history of lib/awesome-tool . Alternatives to git subtree git submodule Use Case : When you want to maintain a lightweight reference to a subproject. Pros : Keeps the main repository smaller. Submodule repositories can be independently managed. Cons : Requires additional steps for contributors (e.g., git submodule update --init ). Detached HEAD issues are common. Example : git submodule add https://github.com/example/awesome-tool.git lib/awesome-tool Manual Merging Use Case : For occasional or ad-hoc integration of external projects. Pros : No special tools or commands required. Cons : No history integration. Tedious for frequent updates. Example : Copy files manually and commit them with a message like \"Update from upstream.\" git merge with a Remote Use Case : For integrating changes from a related project without splitting it into a subtree. Pros : Simple and straightforward. Cons : Does not separate the subproject clearly. Example : git remote add upstream https://github.com/example/awesome-tool.git git fetch upstream git merge upstream/main Comparison of Subtree vs. Submodule Feature Subtree Submodule History Full history of subproject No history of subproject Ease of Use Easier for contributors Requires additional setup Integration Fully integrated Lightweight reference Repository Size Larger due to full history Smaller Decoupling Tightly coupled Loosely coupled When to Use git subtree Integrated Projects : For repositories where the subproject is an integral part of the main repository. Frequent Updates : When you frequently update the subproject and prefer a simpler workflow for contributors. No External Dependency : If you want all history and changes in a single repository. By using git subtree , you achieve a balance between full integration and flexibility for managing subprojects. It is an excellent choice for projects where simplicity and full history integration are priorities.","title":"Subtree"},{"location":"More/git_subtree/#when-to-use-git-subtree","text":"Tightly Integrated Subprojects : When the subproject is essential and frequently changes alongside the main project. Simpler Contributor Workflow : Contributors don\u2019t need to initialize submodules separately. History Integration : The full history of the subproject is stored in the main repository, making it easier to view changes. No Dependency on .gitmodules : You don\u2019t rely on a separate .gitmodules file like in submodules. Avoiding Detached HEAD Issues : Subtrees don't require additional checkout mechanisms that submodules often need. Fewer Permissions Issues : Avoid the need for separate permissions or authentication for the subproject.","title":"When to Use git subtree"},{"location":"More/git_subtree/#key-git-subtree-commands-with-examples","text":"","title":"Key git subtree Commands with Examples"},{"location":"More/git_subtree/#adding-a-subtree","text":"git subtree add --prefix = subdir-name https://github.com/username/repo.git main --squash --prefix=subdir-name : Directory where the subproject will be added. https://github.com/username/repo.git : URL of the subproject repository. main : The branch of the subproject to add. --squash : Combines the subproject history into a single commit. Example: git subtree add --prefix = lib/awesome-tool https://github.com/example/awesome-tool.git main --squash Adds the awesome-tool repository under the lib/ directory of the main project.","title":"Adding a Subtree"},{"location":"More/git_subtree/#pulling-updates-from-the-subproject","text":"git subtree pull --prefix = subdir-name https://github.com/username/repo.git branch-name --squash - Merges updates from the subproject repository into the main repository. Example: git subtree pull --prefix = lib/awesome-tool https://github.com/example/awesome-tool.git main --squash Fetches and integrates updates from the main branch of the awesome-tool subproject.","title":"Pulling Updates from the Subproject"},{"location":"More/git_subtree/#pushing-changes-back-to-the-subproject","text":"git subtree push --prefix = subdir-name https://github.com/username/repo.git branch-name - Pushes changes made in the subtree back to the subproject repository. Example: git subtree push --prefix = lib/awesome-tool https://github.com/example/awesome-tool.git main Updates the main branch of the awesome-tool repository with changes made in the lib/awesome-tool directory.","title":"Pushing Changes Back to the Subproject"},{"location":"More/git_subtree/#splitting-the-subproject","text":"If you want to extract the subtree into its own repository: git subtree split --prefix = subdir-name --branch = new-branch-name --prefix=subdir-name : Directory of the subtree. --branch=new-branch-name : Name of the branch to hold the extracted history. Example: git subtree split --prefix = lib/awesome-tool --branch = split-awesome-tool Creates a new branch ( split-awesome-tool ) containing only the history of lib/awesome-tool .","title":"Splitting the Subproject"},{"location":"More/git_subtree/#alternatives-to-git-subtree","text":"","title":"Alternatives to git subtree"},{"location":"More/git_subtree/#git-submodule","text":"Use Case : When you want to maintain a lightweight reference to a subproject. Pros : Keeps the main repository smaller. Submodule repositories can be independently managed. Cons : Requires additional steps for contributors (e.g., git submodule update --init ). Detached HEAD issues are common. Example : git submodule add https://github.com/example/awesome-tool.git lib/awesome-tool","title":"git submodule"},{"location":"More/git_subtree/#manual-merging","text":"Use Case : For occasional or ad-hoc integration of external projects. Pros : No special tools or commands required. Cons : No history integration. Tedious for frequent updates. Example : Copy files manually and commit them with a message like \"Update from upstream.\"","title":"Manual Merging"},{"location":"More/git_subtree/#git-merge-with-a-remote","text":"Use Case : For integrating changes from a related project without splitting it into a subtree. Pros : Simple and straightforward. Cons : Does not separate the subproject clearly. Example : git remote add upstream https://github.com/example/awesome-tool.git git fetch upstream git merge upstream/main","title":"git merge with a Remote"},{"location":"More/git_subtree/#comparison-of-subtree-vs-submodule","text":"Feature Subtree Submodule History Full history of subproject No history of subproject Ease of Use Easier for contributors Requires additional setup Integration Fully integrated Lightweight reference Repository Size Larger due to full history Smaller Decoupling Tightly coupled Loosely coupled","title":"Comparison of Subtree vs. Submodule"},{"location":"More/git_subtree/#when-to-use-git-subtree_1","text":"Integrated Projects : For repositories where the subproject is an integral part of the main repository. Frequent Updates : When you frequently update the subproject and prefer a simpler workflow for contributors. No External Dependency : If you want all history and changes in a single repository. By using git subtree , you achieve a balance between full integration and flexibility for managing subprojects. It is an excellent choice for projects where simplicity and full history integration are priorities.","title":"When to Use git subtree"},{"location":"More/git_worktree/","text":"git worktree is a powerful feature in Git that allows you to work on multiple branches simultaneously by creating additional working directories (worktrees) linked to the same Git repository. Each worktree is a separate, fully-fledged working copy of the repository, with its own branch and file state, but sharing the same .git history and object database. This can be incredibly useful for tasks like: Working on different branches at the same time without the overhead of cloning the repository again. Performing code reviews, testing, or building features in parallel. Avoiding the need to stash or commit uncommitted work when switching between branches. How it works: The main working directory is still managed as usual, but each additional worktree allows you to check out a different branch or commit without affecting the main directory or other worktrees. The .git directory is shared across all worktrees, meaning the version history is common to all of them, but each worktree can operate independently regarding the current branch and working directory. Key Commands for Git Worktree 1. Create a new worktree To create a new worktree for a specific branch or commit: git worktree add <path> <branch> <path> : The directory where the new worktree will be created. <branch> : The branch to be checked out in the new worktree (or a new branch can be created if it doesn\u2019t exist). Example: git worktree add ../feature-branch feature This creates a new worktree in the directory ../feature-branch and checks out the branch feature . Now, you can work on this branch without interfering with your current working directory. 2. List existing worktrees To list all the worktrees associated with the current repository, use: git worktree list Example Output: /path/to/repo 123abc [main] /path/to/repo/feature-branch 456def [feature] This command shows where your worktrees are located and which branch each one is on. 3. Remove a worktree Once you're done with a worktree and no longer need it, you can remove it with: git worktree remove <path> This command will remove the specified worktree directory. The branch still exists in the repository, but the worktree itself is cleaned up. Example: git worktree remove ../feature-branch After running this command, the ../feature-branch directory is deleted, but the feature branch remains in the repository. 4. Prune worktrees If a worktree is deleted manually (outside of Git), Git may still have references to it. You can clean up those references using: git worktree prune This command removes any worktree records that no longer exist on disk. Use Cases for Git Worktree Simultaneous Work on Multiple Branches: If you're working on a feature branch but need to quickly switch to another branch (e.g., for a hotfix), instead of committing or stashing your current work, you can create a new worktree for the hotfix branch. This allows you to continue working on the feature branch while addressing the hotfix. Example: git worktree add ../hotfix-branch hotfix This creates a separate directory for the hotfix branch without disturbing your ongoing feature development. Testing or Reviewing Code in Parallel: You can use worktrees to test or review code from different branches without switching your main working directory. This is particularly useful if you want to test a branch but keep your primary working directory focused on another task. Example: git worktree add ../test-branch test Building or Running CI/CD in Isolated Environments: Worktrees are useful in Continuous Integration (CI) or Continuous Deployment (CD) pipelines when multiple branches or configurations need to be tested or built simultaneously. Instead of switching between branches in the same directory, you can create isolated worktrees for each task. Comparison with git clone Feature git clone git worktree Creates a separate Git repository Yes No Independent .git directory Yes No (shared) Disk usage High Low (objects and history shared) Can switch between branches No (independent repo) Yes (same repository) Easy cleanup Moderate Easy (with git worktree remove ) Key Points to Remember Shared History: All worktrees share the same Git history and objects, so they don\u2019t take up much additional disk space. Simultaneous Work: You can work on multiple branches at the same time without needing to commit or stash uncommitted changes. Avoid Cloning: Unlike git clone , git worktree doesn't create an entirely new Git repository. It's lightweight and uses the same object store as the main repository. Example Workflow Suppose you're working on a feature branch but need to quickly address a bug on the main branch. Instead of stashing your work or committing half-done changes, you can use git worktree to create a new working directory for the main branch. git worktree add ../main-branch main Work on the bug fix in ../main-branch , and once done, commit and push the changes. Return to your original directory, where your feature branch remains untouched and ready to continue development. By using worktrees, you can manage multiple tasks in parallel, avoid interrupting your flow, and work efficiently on different branches.","title":"Worktree"},{"location":"More/git_worktree/#how-it-works","text":"The main working directory is still managed as usual, but each additional worktree allows you to check out a different branch or commit without affecting the main directory or other worktrees. The .git directory is shared across all worktrees, meaning the version history is common to all of them, but each worktree can operate independently regarding the current branch and working directory.","title":"How it works:"},{"location":"More/git_worktree/#key-commands-for-git-worktree","text":"","title":"Key Commands for Git Worktree"},{"location":"More/git_worktree/#1-create-a-new-worktree","text":"To create a new worktree for a specific branch or commit: git worktree add <path> <branch> <path> : The directory where the new worktree will be created. <branch> : The branch to be checked out in the new worktree (or a new branch can be created if it doesn\u2019t exist). Example: git worktree add ../feature-branch feature This creates a new worktree in the directory ../feature-branch and checks out the branch feature . Now, you can work on this branch without interfering with your current working directory.","title":"1. Create a new worktree"},{"location":"More/git_worktree/#2-list-existing-worktrees","text":"To list all the worktrees associated with the current repository, use: git worktree list Example Output: /path/to/repo 123abc [main] /path/to/repo/feature-branch 456def [feature] This command shows where your worktrees are located and which branch each one is on.","title":"2. List existing worktrees"},{"location":"More/git_worktree/#3-remove-a-worktree","text":"Once you're done with a worktree and no longer need it, you can remove it with: git worktree remove <path> This command will remove the specified worktree directory. The branch still exists in the repository, but the worktree itself is cleaned up. Example: git worktree remove ../feature-branch After running this command, the ../feature-branch directory is deleted, but the feature branch remains in the repository.","title":"3. Remove a worktree"},{"location":"More/git_worktree/#4-prune-worktrees","text":"If a worktree is deleted manually (outside of Git), Git may still have references to it. You can clean up those references using: git worktree prune This command removes any worktree records that no longer exist on disk.","title":"4. Prune worktrees"},{"location":"More/git_worktree/#use-cases-for-git-worktree","text":"Simultaneous Work on Multiple Branches: If you're working on a feature branch but need to quickly switch to another branch (e.g., for a hotfix), instead of committing or stashing your current work, you can create a new worktree for the hotfix branch. This allows you to continue working on the feature branch while addressing the hotfix. Example: git worktree add ../hotfix-branch hotfix This creates a separate directory for the hotfix branch without disturbing your ongoing feature development. Testing or Reviewing Code in Parallel: You can use worktrees to test or review code from different branches without switching your main working directory. This is particularly useful if you want to test a branch but keep your primary working directory focused on another task. Example: git worktree add ../test-branch test Building or Running CI/CD in Isolated Environments: Worktrees are useful in Continuous Integration (CI) or Continuous Deployment (CD) pipelines when multiple branches or configurations need to be tested or built simultaneously. Instead of switching between branches in the same directory, you can create isolated worktrees for each task.","title":"Use Cases for Git Worktree"},{"location":"More/git_worktree/#comparison-with-git-clone","text":"Feature git clone git worktree Creates a separate Git repository Yes No Independent .git directory Yes No (shared) Disk usage High Low (objects and history shared) Can switch between branches No (independent repo) Yes (same repository) Easy cleanup Moderate Easy (with git worktree remove )","title":"Comparison with git clone"},{"location":"More/git_worktree/#key-points-to-remember","text":"Shared History: All worktrees share the same Git history and objects, so they don\u2019t take up much additional disk space. Simultaneous Work: You can work on multiple branches at the same time without needing to commit or stash uncommitted changes. Avoid Cloning: Unlike git clone , git worktree doesn't create an entirely new Git repository. It's lightweight and uses the same object store as the main repository.","title":"Key Points to Remember"},{"location":"More/git_worktree/#example-workflow","text":"Suppose you're working on a feature branch but need to quickly address a bug on the main branch. Instead of stashing your work or committing half-done changes, you can use git worktree to create a new working directory for the main branch. git worktree add ../main-branch main Work on the bug fix in ../main-branch , and once done, commit and push the changes. Return to your original directory, where your feature branch remains untouched and ready to continue development. By using worktrees, you can manage multiple tasks in parallel, avoid interrupting your flow, and work efficiently on different branches.","title":"Example Workflow"},{"location":"More/plumbing/","text":"Plumbing tools in Git are low-level commands that interact directly with the Git repository's internal data structures, providing access to detailed information about commits, branches, and other objects. They are primarily used for scripting, automation, or accessing detailed repository information that may not be readily available with porcelain commands (higher-level commands). They provide direct access to the Git object database and are essential for building more complex Git workflows and tools. git rev-parse This command is used to parse Git references such as branch names, commit hashes, tags, and symbolic references into commit identifiers or other meaningful information. It can be used to retrieve the SHA-1 hash of commits, tags, and other Git objects, or to resolve symbolic references like branch names to their corresponding commit hashes. git rev-parse HEAD # Get the commit hash of the current HEAD git rev-parse main # Get the commit hash of the 'main' branch git rev-parse v1.0 # Get the commit hash of the tag 'v1.0' git reflog This command displays the commit history of the local repository's HEAD reference, showing a chronological list of all recent HEAD movements and associated commit identifiers. It's useful for recovering lost commits or understanding changes to the repository's history, especially after potentially destructive operations like rebasing or resetting. git reflog # Show the reflog for the current branch git reflog main # Show the reflog for the 'main' branch $ git reflog 734713b HEAD@{0}: commit: Fix refs handling, add gc auto, update tests d921970 HEAD@{1}: merge phedders/rdocs: Merge made by the 'recursive' strategy. 1c002dd HEAD@{2}: commit: Add some blame and merge stuff 1c36188 HEAD@{3}: rebase -i (squash): updating HEAD 95df984 HEAD@{4}: commit: # This is a combination of two commits. 1c36188 HEAD@{5}: rebase -i (squash): updating HEAD 7e05da5 HEAD@{6}: rebase -i (pick): updating HEAD Every time your branch tip is updated for any reason, Git stores that information for you in this temporary history. You can use your reflog data to refer to older commits as well. For example, if you want to see the fifth prior value of the HEAD of your repository, you can use the @{5} reference that you see in the reflog output: git show HEAD@ { 5 } You can also use this syntax to see where a branch was some specific amount of time ago. For instance, to see where your master branch was yesterday, you can type: git show HEAD@ { yesterday } That would show you where the tip of your master branch was yesterday. This technique only works for data that\u2019s still in your reflog, so you can\u2019t use it to look for commits older than a few months. To see reflog information formatted like the git log output, you can run: git log -g master It\u2019s important to note that reflog information is strictly local\u2009\u2014\u2009it\u2019s a log only of what you\u2019ve done in your repository. The references won\u2019t be the same on someone else\u2019s copy of the repository; also, right after you initially clone a repository, you\u2019ll have an empty reflog, as no activity has occurred yet in your repository. Running git show HEAD@{2.months.ago} will show you the matching commit only if you cloned the project at least two months ago\u2009\u2014\u2009if you cloned it any more recently than that, you\u2019ll see only your first local commit. Think of the reflog as Git\u2019s version of shell history Escaping braces in PowerShell When using PowerShell, braces like { and } are special characters and must be escaped. You can escape them with a backtick ` or put the commit reference in quotes: git show HEAD@ { 0 } # will NOT work git show HEAD@ ` { 0 ` } # OK git show \"HEAD@{0}\" # OK Ancestry References ^ (caret) The other main way to specify a commit is via its ancestry. If you place a ^ (caret) at the end of a reference, Git resolves it to mean the parent of that commit. You can see the previous commit by specifying HEAD^, which means \u201cthe parent of HEAD\u201d: git show HEAD^ Escaping the caret on Windows On Windows in cmd.exe, ^ is a special character and needs to be treated differently. You can either double it or put the commit reference in quotes: $ git show HEAD^ # will NOT work on Windows $ git show HEAD^^ # OK $ git show \"HEAD^\" # OK You can also specify a number after the ^ to identify which parent you want; for example, d921970^2 means \u201cthe second parent of d921970.\u201d This syntax is useful only for merge commits, which have more than one parent\u2009\u2014\u2009the first parent of a merge commit is from the branch you were on when you merged (frequently master), while the second parent of a merge commit is from the branch that was merged (say, topic). ~ (tilde) The other main ancestry specification is the ~ (tilde). This also refers to the first parent, so HEAD~ and HEAD^ are equivalent. The difference becomes apparent when you specify a number. HEAD~2 means \u201cthe first parent of the first parent,\u201d or \u201cthe grandparent\u201d\u2009\u2014\u2009it traverses the first parents the number of times you specify. git show HEAD~2 This can also be written HEAD~~, which again is the first parent of the first parent. You can also combine these syntaxes\u2009\u2014\u2009you can get the second parent of the previous reference (assuming it was a merge commit) by using HEAD~3^2, and so on. Commit Ranges This is particularly useful for managing your branches\u2009\u2014\u2009if you have a lot of branches, you can use range specifications to answer questions such as, \u201cWhat work is on this branch that I haven\u2019t yet merged into my main branch?\u201d Double Dot The most common range specification is the double-dot syntax. This basically asks Git to resolve a range of commits that are reachable from one commit but aren\u2019t reachable from another. Say you want to see what is in your experiment branch that hasn\u2019t yet been merged into your master branch. You can ask Git to show you a log of just those commits with master..experiment\u2009\u2014\u2009that means \u201call commits reachable from experiment that aren\u2019t reachable from master.\u201d git log master..experiment ty29a fe56a If, on the other hand, you want to see the opposite\u2009\u2014\u2009all commits in master that aren\u2019t in experiment\u2009\u2014\u2009you can reverse the branch names. experiment..master shows you everything in master not reachable from experiment: git log experiment..master tr54a d45a6 This is useful if you want to keep the experiment branch up to date and preview what you\u2019re about to merge. Another frequent use of this syntax is to see what you\u2019re about to push to a remote: git log origin/master..HEAD This command shows you any commits in your current branch that aren\u2019t in the master branch on your origin remote. If you run a git push and your current branch is tracking origin/master, the commits listed by git log origin/master..HEAD are the commits that will be transferred to the server. You can also leave off one side of the syntax to have Git assume HEAD. For example, you can get the same results as in the previous example by typing git log origin/master..\u2009\u2014\u2009Git substitutes HEAD if one side is missing. Multiple Points The double-dot syntax is useful as a shorthand, but perhaps you want to specify more than two branches to indicate your revision, such as seeing what commits are in any of several branches that aren\u2019t in the branch you\u2019re currently on. Git allows you to do this by using either the ^ character or --not before any reference from which you don\u2019t want to see reachable commits. Thus, the following three commands are equivalent: git log refA..refB git log ^refA refB git log refB --not refA This is nice because with this syntax you can specify more than two references in your query, which you cannot do with the double-dot syntax. For instance, if you want to see all commits that are reachable from refA or refB but not from refC, you can use either of: git log refA refB ^refC git log refA refB --not refC This makes for a very powerful revision query system that should help you figure out what is in your branches. Triple Dot The last major range-selection syntax is the triple-dot syntax, which specifies all the commits that are reachable by either of two references but not by both of them. If you want to see what is in master or experiment but not any common references, you can run: git log master...experiment Again, this gives you normal log output but shows you only the commit information for those four commits, appearing in the traditional commit date ordering. A common switch to use with the log command in this case is --left-right, which shows you which side of the range each commit is in. git log --left-right master...experiment < tr54a < d45a6 > ty29a > fe56a With these tools, you can much more easily let Git know what commit or commits you want to inspect. git cat-file This command provides various information about Git objects (commits, trees, tags, or blobs). It can be used to display the contents, type, size, or even raw data of a specific Git object. git cat-file -p HEAD # Show the contents of the commit pointed to by HEAD git cat-file -t v1.0 # Show the type of the tag 'v1.0' git hash-object This command computes the SHA-1 hash of a given file or data and optionally stores it in the Git object database. It's commonly used for hashing file contents before storing them as Git objects or verifying data integrity. git hash-object file.txt # Compute the SHA-1 hash of 'file.txt' git ls-tree This command lists the contents of a tree object (directory) in the Git object database. It can be used to view the files and subdirectories stored within a specific tree object. git ls-tree HEAD # List the contents of the commit pointed to by HEAD git update-ref This command allows you to update the references in the Git repository, such as branches or tags, directly. It's commonly used for advanced Git operations or scripting workflows that involve manipulating references. git update-ref refs/heads/main <commit> # Update the 'main' branch to point to a specific commit git commit-tree This command creates a new commit object based on the provided tree object and parent commit(s) and optionally stores it in the Git object database.It's typically used in advanced Git workflows or scripting scenarios where manual creation of commits is necessary. git commit-tree <tree> -p <parent> -m \"Commit message\" # Create a new commit object with the given tree and parent commit","title":"Plumbing Tools"},{"location":"More/plumbing/#git-rev-parse","text":"This command is used to parse Git references such as branch names, commit hashes, tags, and symbolic references into commit identifiers or other meaningful information. It can be used to retrieve the SHA-1 hash of commits, tags, and other Git objects, or to resolve symbolic references like branch names to their corresponding commit hashes. git rev-parse HEAD # Get the commit hash of the current HEAD git rev-parse main # Get the commit hash of the 'main' branch git rev-parse v1.0 # Get the commit hash of the tag 'v1.0'","title":"git rev-parse"},{"location":"More/plumbing/#git-reflog","text":"This command displays the commit history of the local repository's HEAD reference, showing a chronological list of all recent HEAD movements and associated commit identifiers. It's useful for recovering lost commits or understanding changes to the repository's history, especially after potentially destructive operations like rebasing or resetting. git reflog # Show the reflog for the current branch git reflog main # Show the reflog for the 'main' branch $ git reflog 734713b HEAD@{0}: commit: Fix refs handling, add gc auto, update tests d921970 HEAD@{1}: merge phedders/rdocs: Merge made by the 'recursive' strategy. 1c002dd HEAD@{2}: commit: Add some blame and merge stuff 1c36188 HEAD@{3}: rebase -i (squash): updating HEAD 95df984 HEAD@{4}: commit: # This is a combination of two commits. 1c36188 HEAD@{5}: rebase -i (squash): updating HEAD 7e05da5 HEAD@{6}: rebase -i (pick): updating HEAD Every time your branch tip is updated for any reason, Git stores that information for you in this temporary history. You can use your reflog data to refer to older commits as well. For example, if you want to see the fifth prior value of the HEAD of your repository, you can use the @{5} reference that you see in the reflog output: git show HEAD@ { 5 } You can also use this syntax to see where a branch was some specific amount of time ago. For instance, to see where your master branch was yesterday, you can type: git show HEAD@ { yesterday } That would show you where the tip of your master branch was yesterday. This technique only works for data that\u2019s still in your reflog, so you can\u2019t use it to look for commits older than a few months. To see reflog information formatted like the git log output, you can run: git log -g master It\u2019s important to note that reflog information is strictly local\u2009\u2014\u2009it\u2019s a log only of what you\u2019ve done in your repository. The references won\u2019t be the same on someone else\u2019s copy of the repository; also, right after you initially clone a repository, you\u2019ll have an empty reflog, as no activity has occurred yet in your repository. Running git show HEAD@{2.months.ago} will show you the matching commit only if you cloned the project at least two months ago\u2009\u2014\u2009if you cloned it any more recently than that, you\u2019ll see only your first local commit. Think of the reflog as Git\u2019s version of shell history Escaping braces in PowerShell When using PowerShell, braces like { and } are special characters and must be escaped. You can escape them with a backtick ` or put the commit reference in quotes: git show HEAD@ { 0 } # will NOT work git show HEAD@ ` { 0 ` } # OK git show \"HEAD@{0}\" # OK","title":"git reflog"},{"location":"More/plumbing/#ancestry-references","text":"","title":"Ancestry References"},{"location":"More/plumbing/#caret","text":"The other main way to specify a commit is via its ancestry. If you place a ^ (caret) at the end of a reference, Git resolves it to mean the parent of that commit. You can see the previous commit by specifying HEAD^, which means \u201cthe parent of HEAD\u201d: git show HEAD^ Escaping the caret on Windows On Windows in cmd.exe, ^ is a special character and needs to be treated differently. You can either double it or put the commit reference in quotes: $ git show HEAD^ # will NOT work on Windows $ git show HEAD^^ # OK $ git show \"HEAD^\" # OK You can also specify a number after the ^ to identify which parent you want; for example, d921970^2 means \u201cthe second parent of d921970.\u201d This syntax is useful only for merge commits, which have more than one parent\u2009\u2014\u2009the first parent of a merge commit is from the branch you were on when you merged (frequently master), while the second parent of a merge commit is from the branch that was merged (say, topic).","title":"^ (caret)"},{"location":"More/plumbing/#tilde","text":"The other main ancestry specification is the ~ (tilde). This also refers to the first parent, so HEAD~ and HEAD^ are equivalent. The difference becomes apparent when you specify a number. HEAD~2 means \u201cthe first parent of the first parent,\u201d or \u201cthe grandparent\u201d\u2009\u2014\u2009it traverses the first parents the number of times you specify. git show HEAD~2 This can also be written HEAD~~, which again is the first parent of the first parent. You can also combine these syntaxes\u2009\u2014\u2009you can get the second parent of the previous reference (assuming it was a merge commit) by using HEAD~3^2, and so on.","title":"~ (tilde)"},{"location":"More/plumbing/#commit-ranges","text":"This is particularly useful for managing your branches\u2009\u2014\u2009if you have a lot of branches, you can use range specifications to answer questions such as, \u201cWhat work is on this branch that I haven\u2019t yet merged into my main branch?\u201d","title":"Commit Ranges"},{"location":"More/plumbing/#double-dot","text":"The most common range specification is the double-dot syntax. This basically asks Git to resolve a range of commits that are reachable from one commit but aren\u2019t reachable from another. Say you want to see what is in your experiment branch that hasn\u2019t yet been merged into your master branch. You can ask Git to show you a log of just those commits with master..experiment\u2009\u2014\u2009that means \u201call commits reachable from experiment that aren\u2019t reachable from master.\u201d git log master..experiment ty29a fe56a If, on the other hand, you want to see the opposite\u2009\u2014\u2009all commits in master that aren\u2019t in experiment\u2009\u2014\u2009you can reverse the branch names. experiment..master shows you everything in master not reachable from experiment: git log experiment..master tr54a d45a6 This is useful if you want to keep the experiment branch up to date and preview what you\u2019re about to merge. Another frequent use of this syntax is to see what you\u2019re about to push to a remote: git log origin/master..HEAD This command shows you any commits in your current branch that aren\u2019t in the master branch on your origin remote. If you run a git push and your current branch is tracking origin/master, the commits listed by git log origin/master..HEAD are the commits that will be transferred to the server. You can also leave off one side of the syntax to have Git assume HEAD. For example, you can get the same results as in the previous example by typing git log origin/master..\u2009\u2014\u2009Git substitutes HEAD if one side is missing.","title":"Double Dot"},{"location":"More/plumbing/#multiple-points","text":"The double-dot syntax is useful as a shorthand, but perhaps you want to specify more than two branches to indicate your revision, such as seeing what commits are in any of several branches that aren\u2019t in the branch you\u2019re currently on. Git allows you to do this by using either the ^ character or --not before any reference from which you don\u2019t want to see reachable commits. Thus, the following three commands are equivalent: git log refA..refB git log ^refA refB git log refB --not refA This is nice because with this syntax you can specify more than two references in your query, which you cannot do with the double-dot syntax. For instance, if you want to see all commits that are reachable from refA or refB but not from refC, you can use either of: git log refA refB ^refC git log refA refB --not refC This makes for a very powerful revision query system that should help you figure out what is in your branches.","title":"Multiple Points"},{"location":"More/plumbing/#triple-dot","text":"The last major range-selection syntax is the triple-dot syntax, which specifies all the commits that are reachable by either of two references but not by both of them. If you want to see what is in master or experiment but not any common references, you can run: git log master...experiment Again, this gives you normal log output but shows you only the commit information for those four commits, appearing in the traditional commit date ordering. A common switch to use with the log command in this case is --left-right, which shows you which side of the range each commit is in. git log --left-right master...experiment < tr54a < d45a6 > ty29a > fe56a With these tools, you can much more easily let Git know what commit or commits you want to inspect.","title":"Triple Dot"},{"location":"More/plumbing/#git-cat-file","text":"This command provides various information about Git objects (commits, trees, tags, or blobs). It can be used to display the contents, type, size, or even raw data of a specific Git object. git cat-file -p HEAD # Show the contents of the commit pointed to by HEAD git cat-file -t v1.0 # Show the type of the tag 'v1.0'","title":"git cat-file"},{"location":"More/plumbing/#git-hash-object","text":"This command computes the SHA-1 hash of a given file or data and optionally stores it in the Git object database. It's commonly used for hashing file contents before storing them as Git objects or verifying data integrity. git hash-object file.txt # Compute the SHA-1 hash of 'file.txt'","title":"git hash-object"},{"location":"More/plumbing/#git-ls-tree","text":"This command lists the contents of a tree object (directory) in the Git object database. It can be used to view the files and subdirectories stored within a specific tree object. git ls-tree HEAD # List the contents of the commit pointed to by HEAD","title":"git ls-tree"},{"location":"More/plumbing/#git-update-ref","text":"This command allows you to update the references in the Git repository, such as branches or tags, directly. It's commonly used for advanced Git operations or scripting workflows that involve manipulating references. git update-ref refs/heads/main <commit> # Update the 'main' branch to point to a specific commit","title":"git update-ref"},{"location":"More/plumbing/#git-commit-tree","text":"This command creates a new commit object based on the provided tree object and parent commit(s) and optionally stores it in the Git object database.It's typically used in advanced Git workflows or scripting scenarios where manual creation of commits is necessary. git commit-tree <tree> -p <parent> -m \"Commit message\" # Create a new commit object with the given tree and parent commit","title":"git commit-tree"}]}
{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Git Refresher Whether you're a seasoned developer or a code maintainer, this repository is designed to help you enhance your Git skills and streamline your version control workflows. Basic Topics Advanced Topics Configuration Adv Aliases Adv Starting a Project Adv Staging Changes Adv Undoing Changes Adv This material is a work in progress, so your feedback is welcome. The best way to provide that feedback is to click here and create an issue in this GitHub repository .","title":"Home"},{"location":"#welcome-to-git-refresher","text":"Whether you're a seasoned developer or a code maintainer, this repository is designed to help you enhance your Git skills and streamline your version control workflows. Basic Topics Advanced Topics Configuration Adv Aliases Adv Starting a Project Adv Staging Changes Adv Undoing Changes Adv This material is a work in progress, so your feedback is welcome. The best way to provide that feedback is to click here and create an issue in this GitHub repository .","title":"Welcome to Git Refresher"},{"location":"git_refresh/","text":"Git is a distributed version control system (VCS) designed to track changes in source code during software development. It was created by Linus Torvalds in 2005 and has become the de facto standard for version control in the software development industry. Key Concepts Version Control: Git allows developers to track changes made to their codebase over time. This includes recording who made the changes, what changes were made, and when the changes occurred. Distributed System: Git is decentralized, meaning that each developer has a complete copy of the entire project history on their local machine. This allows for flexibility in development and collaboration. Branching: Git excels at branching, enabling developers to work on multiple independent features or bug fixes simultaneously. Branches can be created, merged, and deleted without affecting the main codebase until changes are ready to be integrated. Collaboration: Git facilitates collaboration among developers. Multiple contributors can work on the same project simultaneously without interfering with each other's work. Changes are merged together seamlessly. History and Accountability Git maintains a detailed history of all changes made to a project. This history provides accountability by attributing each change to a specific user, making it easy to trace the evolution of the codebase. Importance of Git Collaboration: Git enables efficient collaboration among developers working on the same project. It allows multiple team members to contribute simultaneously, track changes, and merge their work seamlessly. Versioning: Git provides a reliable versioning system, allowing developers to track changes over time. This is crucial for understanding the evolution of a project, reverting to previous states, and identifying when and by whom specific changes were made. Branching and Experimentation Git's branching model allows developers to experiment with new features or bug fixes in isolation. This promotes a more organized and controlled development process, with the ability to merge changes into the main codebase when they are ready. Fault Tolerance: The distributed nature of Git ensures that each developer has a complete copy of the repository. This redundancy minimizes the risk of data loss and provides a safety net in case of system failures. Open Source Ecosystem: Git is the foundation for many open-source projects and contributes to the collaborative nature of the software development community. Platforms like GitHub, GitLab, and Bitbucket leverage Git to host and manage repositories, fostering a rich ecosystem of shared code. In summary, Git is important because it enhances collaboration, provides effective version control, and empowers developers to work efficiently and reliably on software projects of any scale.","title":"General"},{"location":"git_refresh/#key-concepts","text":"Version Control: Git allows developers to track changes made to their codebase over time. This includes recording who made the changes, what changes were made, and when the changes occurred. Distributed System: Git is decentralized, meaning that each developer has a complete copy of the entire project history on their local machine. This allows for flexibility in development and collaboration. Branching: Git excels at branching, enabling developers to work on multiple independent features or bug fixes simultaneously. Branches can be created, merged, and deleted without affecting the main codebase until changes are ready to be integrated. Collaboration: Git facilitates collaboration among developers. Multiple contributors can work on the same project simultaneously without interfering with each other's work. Changes are merged together seamlessly. History and Accountability Git maintains a detailed history of all changes made to a project. This history provides accountability by attributing each change to a specific user, making it easy to trace the evolution of the codebase.","title":"Key Concepts"},{"location":"git_refresh/#importance-of-git","text":"Collaboration: Git enables efficient collaboration among developers working on the same project. It allows multiple team members to contribute simultaneously, track changes, and merge their work seamlessly. Versioning: Git provides a reliable versioning system, allowing developers to track changes over time. This is crucial for understanding the evolution of a project, reverting to previous states, and identifying when and by whom specific changes were made. Branching and Experimentation Git's branching model allows developers to experiment with new features or bug fixes in isolation. This promotes a more organized and controlled development process, with the ability to merge changes into the main codebase when they are ready. Fault Tolerance: The distributed nature of Git ensures that each developer has a complete copy of the repository. This redundancy minimizes the risk of data loss and provides a safety net in case of system failures. Open Source Ecosystem: Git is the foundation for many open-source projects and contributes to the collaborative nature of the software development community. Platforms like GitHub, GitLab, and Bitbucket leverage Git to host and manage repositories, fostering a rich ecosystem of shared code. In summary, Git is important because it enhances collaboration, provides effective version control, and empowers developers to work efficiently and reliably on software projects of any scale.","title":"Importance of Git"},{"location":"Advanced/git_interactivestaging/","text":"","title":"Git interactivestaging"},{"location":"Basics/git_alias/","text":"In Git In Git, aliases are shortcuts or custom commands that you can create to simplify and streamline your workflow. They can be particularly useful to reduce typing and remember complex commands. Here's a step-by-step guide on how to add useful aliases, along with some suggestions for commonly used and helpful aliases: 1. Adding Git Aliases Open your terminal and run the following command to open the global Git configuration file in your default text editor: git config --global --edit This command opens the global configuration file in your preferred text editor. If you haven't configured a text editor, Git will prompt you to choose one. 2. Adding Aliases to the Configuration File Inside the configuration file, add the following section to set up aliases: [ alias ] alias_name = actual_git_command Replace alias_name with the desired alias and actual_git_command with the Git command or series of commands you want to associate with the alias. 3. Example Aliases Here are some commonly used and helpful aliases: [ alias ] # Show a compact and colorful log lg = log --graph --pretty = format: '%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --date = relative # Show the current branch current-branch = symbolic-ref --short HEAD # Show a concise status st = status -s # Commit all changes with a message ca = !git add -A && git commit -m # Show the diff of the last commit last-commit-diff = diff HEAD^ HEAD 4. Explanation of Some Aliases lg : Displays a compact and colorful log. current-branch : Shows the current branch. st : Provides a concise status of the repository. ca : Commits all changes with a message. Usage: git ca \"Commit message\" . last-commit-diff : Shows the diff of the last commit. 5. Save and Exit Save the configuration file and exit your text editor. 6. Using Aliases After adding aliases, you can use them in the terminal like regular Git commands. For example: git lg This will execute the log alias and display a compact and colorful log. 7. Additional Tips Choose aliases that align with your workflow and make common tasks more efficient. Keep aliases short and memorable. Test your aliases in a safe environment before using them extensively. Creating and using Git aliases can significantly improve your productivity and make Git commands more convenient. Feel free to customize these aliases to suit your preferences and workflow. In Bash Setting up aliases in Bash involves editing your Bash profile file. The Bash profile file is a script that runs whenever you start a new terminal session. Here's a step-by-step guide on how to set up aliases in Bash: 1. Open Your Bash Profile Open your Bash profile file in a text editor. The Bash profile is usually one of the following files, depending on your operating system: For Linux/macOS: ~/.bashrc or ~/.bash_profile For Windows using Git Bash: ~/.bashrc If the file doesn't exist, you can create it. # For Linux/macOS nano ~/.bashrc # or use your preferred text editor # For Windows using Git Bash nano ~/.bashrc # or use your preferred text editor or using VScode # For Linux/macOS code ~/.bashrc # or use your preferred text editor # For Windows using Git Bash code ~/.bashrc # or use your preferred text editor 2. Add Your Aliases In your Bash profile, add lines for each alias you want to create. The syntax is as follows: alias alias_name = 'actual_command' Replace alias_name with the desired alias and actual_command with the actual command or series of commands you want to associate with the alias. 3. Example Aliases Here are some example aliases: # Git aliases alias gst = 'git status' alias gl = 'git log' alias gll = 'git log --oneline' alias glog = 'git log --oneline --decorate --graph' alias gamend = 'git commit --amend' alias gr = 'git remote -v' alias gb = 'git branch' alias gba = 'git branch -a' alias gd = 'git diff' alias gds = 'git diff --staged' alias gsub = 'git submodule sync; git submodule update --init --recursive' alias gsreset = 'git submodule foreach --recursive git reset --hard' # Navigation aliases alias cdproj = 'cd ~/projects' alias cddownloads = 'cd ~/Downloads' alias cddesktop = 'cd ~/Desktop' alias .. = 'cd ..' alias ... = 'cd ../..' alias .... = 'cd ../../..' # Shortcuts for common commands alias ll = 'ls -alF' alias la = 'ls -A' alias cp = 'cp -i' alias mv = 'mv -i' alias rm = 'rm -i' # \ud83e\udd18 alias yolo = 'git push --force' # useful for daily stand-up # See https://dev.to/maxpou/git-cheat-sheet-advanced-3a17 git-standup () { AUTHOR = ${ AUTHOR := \"`git config user.name`\" } since = yesterday if [[ $( date +%u ) == 1 ]] ; then since = \"2 days ago\" fi git log --color --graph --pretty = format: '%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --since \" $since \" --author = \" $AUTHOR \" } 4. Save and Exit Save your changes and exit the text editor. For Nano, press Ctrl + X , then Y to confirm saving, and Enter to exit. For other editors, follow their respective save and exit commands. 5. Reload Your Bash Profile To apply the changes without restarting your terminal, either close and reopen the terminal or use the source command: source ~/.bashrc This command reloads the Bash profile, making your new aliases immediately available. 6. Verify Your Aliases To verify that your aliases are set up correctly, you can use the alias command: alias This will display a list of all defined aliases in your current session. Now you can use your aliases in the terminal for quick and convenient access to frequently used commands. Customize the aliases to match your workflow and make your command-line experience more efficient. In Powersell In PowerShell, you can add aliases using your PowerShell profile script. The profile script is a PowerShell script that is automatically executed when you start a PowerShell session. Here's a step-by-step guide on how to add aliases in PowerShell: 1. Open Your PowerShell Profile Open your PowerShell profile script in a text editor. If you don't have a profile, you can create one. The profile script is usually located at one of the following paths: Current User, Current Host (for all users): $PROFILE.AllUsersCurrentHost Current User, Current Host (for the current user): $PROFILE.CurrentUserCurrentHost All Users, All Hosts (for all users): $PROFILE.AllUsersAllHosts Current User, All Hosts (for the current user): $PROFILE.CurrentUserAllHosts To open your profile script, you can use the following command: notepad $PROFILE This command opens the profile script in Notepad. If the file doesn't exist, PowerShell will prompt you to create it. or use VSCode to open your profile script: code $PROFILE 2. Add Your Aliases In your PowerShell profile, add lines for each alias you want to create. The syntax is as follows: function alias_name { actual_command } Replace alias_name with the desired alias and actual_command with the actual command or series of commands you want to associate with the alias. 3. Example Aliases Here are some example aliases: # Git aliases function gs { git status } function ga { git add } function gc { git commit } function gp { git push } function gl { git log - -oneline } # Navigation aliases function cdproj { Set-Location C :\\ Projects } function cddownloads { Set-Location C :\\ Users \\ YourUsername \\ Downloads } function cddesktop { Set-Location C :\\ Users \\ YourUsername \\ Desktop } # Shortcuts for common commands function ll { Get-ChildItem -Force } 4. Save and Exit Save your changes and exit the text editor. 5. Reload Your PowerShell Profile To apply the changes without restarting PowerShell, you can use the Import-Module cmdlet: Import-Module $PROFILE 6. Verify Your Aliases To verify that your aliases are set up correctly, you can use the Get-Alias cmdlet: Get-Alias This will display a list of all defined aliases in your current PowerShell session. Now you can use your aliases in the PowerShell console for quick and convenient access to frequently used commands. Customize the aliases to match your workflow and make your PowerShell experience more efficient.","title":"Aliases"},{"location":"Basics/git_alias/#in-git","text":"In Git, aliases are shortcuts or custom commands that you can create to simplify and streamline your workflow. They can be particularly useful to reduce typing and remember complex commands. Here's a step-by-step guide on how to add useful aliases, along with some suggestions for commonly used and helpful aliases:","title":"In Git"},{"location":"Basics/git_alias/#1-adding-git-aliases","text":"Open your terminal and run the following command to open the global Git configuration file in your default text editor: git config --global --edit This command opens the global configuration file in your preferred text editor. If you haven't configured a text editor, Git will prompt you to choose one.","title":"1. Adding Git Aliases"},{"location":"Basics/git_alias/#2-adding-aliases-to-the-configuration-file","text":"Inside the configuration file, add the following section to set up aliases: [ alias ] alias_name = actual_git_command Replace alias_name with the desired alias and actual_git_command with the Git command or series of commands you want to associate with the alias.","title":"2. Adding Aliases to the Configuration File"},{"location":"Basics/git_alias/#3-example-aliases","text":"Here are some commonly used and helpful aliases: [ alias ] # Show a compact and colorful log lg = log --graph --pretty = format: '%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --date = relative # Show the current branch current-branch = symbolic-ref --short HEAD # Show a concise status st = status -s # Commit all changes with a message ca = !git add -A && git commit -m # Show the diff of the last commit last-commit-diff = diff HEAD^ HEAD","title":"3. Example Aliases"},{"location":"Basics/git_alias/#4-explanation-of-some-aliases","text":"lg : Displays a compact and colorful log. current-branch : Shows the current branch. st : Provides a concise status of the repository. ca : Commits all changes with a message. Usage: git ca \"Commit message\" . last-commit-diff : Shows the diff of the last commit.","title":"4. Explanation of Some Aliases"},{"location":"Basics/git_alias/#5-save-and-exit","text":"Save the configuration file and exit your text editor.","title":"5. Save and Exit"},{"location":"Basics/git_alias/#6-using-aliases","text":"After adding aliases, you can use them in the terminal like regular Git commands. For example: git lg This will execute the log alias and display a compact and colorful log.","title":"6. Using Aliases"},{"location":"Basics/git_alias/#7-additional-tips","text":"Choose aliases that align with your workflow and make common tasks more efficient. Keep aliases short and memorable. Test your aliases in a safe environment before using them extensively. Creating and using Git aliases can significantly improve your productivity and make Git commands more convenient. Feel free to customize these aliases to suit your preferences and workflow.","title":"7. Additional Tips"},{"location":"Basics/git_alias/#in-bash","text":"Setting up aliases in Bash involves editing your Bash profile file. The Bash profile file is a script that runs whenever you start a new terminal session. Here's a step-by-step guide on how to set up aliases in Bash:","title":"In Bash"},{"location":"Basics/git_alias/#1-open-your-bash-profile","text":"Open your Bash profile file in a text editor. The Bash profile is usually one of the following files, depending on your operating system: For Linux/macOS: ~/.bashrc or ~/.bash_profile For Windows using Git Bash: ~/.bashrc If the file doesn't exist, you can create it. # For Linux/macOS nano ~/.bashrc # or use your preferred text editor # For Windows using Git Bash nano ~/.bashrc # or use your preferred text editor or using VScode # For Linux/macOS code ~/.bashrc # or use your preferred text editor # For Windows using Git Bash code ~/.bashrc # or use your preferred text editor","title":"1. Open Your Bash Profile"},{"location":"Basics/git_alias/#2-add-your-aliases","text":"In your Bash profile, add lines for each alias you want to create. The syntax is as follows: alias alias_name = 'actual_command' Replace alias_name with the desired alias and actual_command with the actual command or series of commands you want to associate with the alias.","title":"2. Add Your Aliases"},{"location":"Basics/git_alias/#3-example-aliases_1","text":"Here are some example aliases: # Git aliases alias gst = 'git status' alias gl = 'git log' alias gll = 'git log --oneline' alias glog = 'git log --oneline --decorate --graph' alias gamend = 'git commit --amend' alias gr = 'git remote -v' alias gb = 'git branch' alias gba = 'git branch -a' alias gd = 'git diff' alias gds = 'git diff --staged' alias gsub = 'git submodule sync; git submodule update --init --recursive' alias gsreset = 'git submodule foreach --recursive git reset --hard' # Navigation aliases alias cdproj = 'cd ~/projects' alias cddownloads = 'cd ~/Downloads' alias cddesktop = 'cd ~/Desktop' alias .. = 'cd ..' alias ... = 'cd ../..' alias .... = 'cd ../../..' # Shortcuts for common commands alias ll = 'ls -alF' alias la = 'ls -A' alias cp = 'cp -i' alias mv = 'mv -i' alias rm = 'rm -i' # \ud83e\udd18 alias yolo = 'git push --force' # useful for daily stand-up # See https://dev.to/maxpou/git-cheat-sheet-advanced-3a17 git-standup () { AUTHOR = ${ AUTHOR := \"`git config user.name`\" } since = yesterday if [[ $( date +%u ) == 1 ]] ; then since = \"2 days ago\" fi git log --color --graph --pretty = format: '%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --since \" $since \" --author = \" $AUTHOR \" }","title":"3. Example Aliases"},{"location":"Basics/git_alias/#4-save-and-exit","text":"Save your changes and exit the text editor. For Nano, press Ctrl + X , then Y to confirm saving, and Enter to exit. For other editors, follow their respective save and exit commands.","title":"4. Save and Exit"},{"location":"Basics/git_alias/#5-reload-your-bash-profile","text":"To apply the changes without restarting your terminal, either close and reopen the terminal or use the source command: source ~/.bashrc This command reloads the Bash profile, making your new aliases immediately available.","title":"5. Reload Your Bash Profile"},{"location":"Basics/git_alias/#6-verify-your-aliases","text":"To verify that your aliases are set up correctly, you can use the alias command: alias This will display a list of all defined aliases in your current session. Now you can use your aliases in the terminal for quick and convenient access to frequently used commands. Customize the aliases to match your workflow and make your command-line experience more efficient.","title":"6. Verify Your Aliases"},{"location":"Basics/git_alias/#in-powersell","text":"In PowerShell, you can add aliases using your PowerShell profile script. The profile script is a PowerShell script that is automatically executed when you start a PowerShell session. Here's a step-by-step guide on how to add aliases in PowerShell:","title":"In Powersell"},{"location":"Basics/git_alias/#1-open-your-powershell-profile","text":"Open your PowerShell profile script in a text editor. If you don't have a profile, you can create one. The profile script is usually located at one of the following paths: Current User, Current Host (for all users): $PROFILE.AllUsersCurrentHost Current User, Current Host (for the current user): $PROFILE.CurrentUserCurrentHost All Users, All Hosts (for all users): $PROFILE.AllUsersAllHosts Current User, All Hosts (for the current user): $PROFILE.CurrentUserAllHosts To open your profile script, you can use the following command: notepad $PROFILE This command opens the profile script in Notepad. If the file doesn't exist, PowerShell will prompt you to create it. or use VSCode to open your profile script: code $PROFILE","title":"1. Open Your PowerShell Profile"},{"location":"Basics/git_alias/#2-add-your-aliases_1","text":"In your PowerShell profile, add lines for each alias you want to create. The syntax is as follows: function alias_name { actual_command } Replace alias_name with the desired alias and actual_command with the actual command or series of commands you want to associate with the alias.","title":"2. Add Your Aliases"},{"location":"Basics/git_alias/#3-example-aliases_2","text":"Here are some example aliases: # Git aliases function gs { git status } function ga { git add } function gc { git commit } function gp { git push } function gl { git log - -oneline } # Navigation aliases function cdproj { Set-Location C :\\ Projects } function cddownloads { Set-Location C :\\ Users \\ YourUsername \\ Downloads } function cddesktop { Set-Location C :\\ Users \\ YourUsername \\ Desktop } # Shortcuts for common commands function ll { Get-ChildItem -Force }","title":"3. Example Aliases"},{"location":"Basics/git_alias/#4-save-and-exit_1","text":"Save your changes and exit the text editor.","title":"4. Save and Exit"},{"location":"Basics/git_alias/#5-reload-your-powershell-profile","text":"To apply the changes without restarting PowerShell, you can use the Import-Module cmdlet: Import-Module $PROFILE","title":"5. Reload Your PowerShell Profile"},{"location":"Basics/git_alias/#6-verify-your-aliases_1","text":"To verify that your aliases are set up correctly, you can use the Get-Alias cmdlet: Get-Alias This will display a list of all defined aliases in your current PowerShell session. Now you can use your aliases in the PowerShell console for quick and convenient access to frequently used commands. Customize the aliases to match your workflow and make your PowerShell experience more efficient.","title":"6. Verify Your Aliases"},{"location":"Basics/git_branch/","text":"Branching in Git is a powerful feature that allows developers to diverge from the main line of development (usually referred to as the master branch) and work on separate, isolated lines of development. Each branch represents an independent line of development, enabling multiple features, fixes, or experiments to be worked on simultaneously without interfering with each other. Branching can be a crucial part of software development, as it allows teams to work collaboratively on different features or fixes simultaneously while maintaining a clear and organized codebase. Isolating work in branches, changing context, and integrating changes into the main line of development can help streamline the development process and improve collaboration. Main Branches Master Branch: By convention, the master branch is often used to represent the main line of development. It typically contains stable, production-ready code. Main Branch (Post-Git 2.28): Some projects have adopted renaming the default branch from master to main . The main branch serves the same purpose as the master branch, but the naming convention aims to promote more inclusive language. Creating Branches Creating a New Branch: To create a new branch, use the git branch <branch-name> command. Optionally, you can switch to the new branch immediately with git checkout -b <branch-name> . git branch feature-branch Switching Branches: To switch between branches, use the git checkout <branch-name> command. git checkout feature-branch Viewing Branches Listing Branches: To list all branches in the repository, use the git branch command. git branch An asterisk ( * ) in the output indicates that the branch you are currently on is the currently active branch. The git branch -a command is used to list all branches in a Git repository, including both local branches and remote branches. git branch -a git branch : This is the Git command used to manage branches in a repository. -a (or --all ): This option tells Git to list both local branches and remote branches. When you run git branch -a , Git will list all branches in the repository, including: Local Branches: Branches that exist only in your local repository. Remote Branches: Branches that exist on the remote repository (e.g., on GitHub, GitLab). Remote Tracking Branches: Local representations of remote branches, used for tracking changes from the remote repository. The output typically looks like this: * main feature-branch remotes/origin/HEAD -> origin/main remotes/origin/main remotes/origin/feature-branch The branches listed without the remotes/ prefix are local branches. The branches listed with the remotes/ prefix are remote branches. origin is the default name for the remote repository, but you may see other names if you have multiple remotes configured. Use Cases Checking the status of local and remote branches. Identifying available branches for merging, rebasing, or switching. Tracking changes from remote branches and syncing local branches accordingly. By using git branch -a , you can get a comprehensive overview of all branches in your Git repository, allowing you to manage and navigate through branches effectively. Merging Branches Merge: To merge changes from one branch into another, use the git merge <branch-name> command. git merge feature-branch Merge the specified branch\u2019s history into the current one. Deleting Branches Delete: To delete a branch, use the git branch -d <branch-name> command. git branch -d feature-branch Branching Strategies Feature Branching: Create a separate branch for each new feature or task. This isolates changes related to specific features, making them easier to manage and review. Release Branching: Create branches for each release to stabilize the codebase before deployment. Hotfix Branching: Create branches to fix critical issues in production code quickly. Remote Branches Pushing a Branch: To push a local branch to a remote repository, use the git push <remote-name> <branch-name> command. git push origin feature-branch Tracking Remote Branches: After pushing a branch to the remote repository, it can be tracked. This means Git remembers the relationship between the local branch and its corresponding remote branch. git checkout -b feature-branch origin/feature-branch Branching Best Practices Use Descriptive Names: Choose meaningful names for branches to indicate their purpose or associated feature. Keep Branches Short-Lived: Merge branches into the main line of development once their purpose is served to avoid branch clutter. Regularly Update Branches: Keep branches up-to-date with changes in the main line of development by frequently merging or rebasing. Review Branches: Encourage code review and collaboration by reviewing changes made in feature branches before merging them.","title":"Branching"},{"location":"Basics/git_branch/#main-branches","text":"Master Branch: By convention, the master branch is often used to represent the main line of development. It typically contains stable, production-ready code. Main Branch (Post-Git 2.28): Some projects have adopted renaming the default branch from master to main . The main branch serves the same purpose as the master branch, but the naming convention aims to promote more inclusive language.","title":"Main Branches"},{"location":"Basics/git_branch/#creating-branches","text":"Creating a New Branch: To create a new branch, use the git branch <branch-name> command. Optionally, you can switch to the new branch immediately with git checkout -b <branch-name> . git branch feature-branch Switching Branches: To switch between branches, use the git checkout <branch-name> command. git checkout feature-branch","title":"Creating Branches"},{"location":"Basics/git_branch/#viewing-branches","text":"Listing Branches: To list all branches in the repository, use the git branch command. git branch An asterisk ( * ) in the output indicates that the branch you are currently on is the currently active branch. The git branch -a command is used to list all branches in a Git repository, including both local branches and remote branches. git branch -a git branch : This is the Git command used to manage branches in a repository. -a (or --all ): This option tells Git to list both local branches and remote branches. When you run git branch -a , Git will list all branches in the repository, including: Local Branches: Branches that exist only in your local repository. Remote Branches: Branches that exist on the remote repository (e.g., on GitHub, GitLab). Remote Tracking Branches: Local representations of remote branches, used for tracking changes from the remote repository. The output typically looks like this: * main feature-branch remotes/origin/HEAD -> origin/main remotes/origin/main remotes/origin/feature-branch The branches listed without the remotes/ prefix are local branches. The branches listed with the remotes/ prefix are remote branches. origin is the default name for the remote repository, but you may see other names if you have multiple remotes configured.","title":"Viewing Branches"},{"location":"Basics/git_branch/#use-cases","text":"Checking the status of local and remote branches. Identifying available branches for merging, rebasing, or switching. Tracking changes from remote branches and syncing local branches accordingly. By using git branch -a , you can get a comprehensive overview of all branches in your Git repository, allowing you to manage and navigate through branches effectively.","title":"Use Cases"},{"location":"Basics/git_branch/#merging-branches","text":"Merge: To merge changes from one branch into another, use the git merge <branch-name> command. git merge feature-branch Merge the specified branch\u2019s history into the current one.","title":"Merging Branches"},{"location":"Basics/git_branch/#deleting-branches","text":"Delete: To delete a branch, use the git branch -d <branch-name> command. git branch -d feature-branch","title":"Deleting Branches"},{"location":"Basics/git_branch/#branching-strategies","text":"Feature Branching: Create a separate branch for each new feature or task. This isolates changes related to specific features, making them easier to manage and review. Release Branching: Create branches for each release to stabilize the codebase before deployment. Hotfix Branching: Create branches to fix critical issues in production code quickly.","title":"Branching Strategies"},{"location":"Basics/git_branch/#remote-branches","text":"Pushing a Branch: To push a local branch to a remote repository, use the git push <remote-name> <branch-name> command. git push origin feature-branch Tracking Remote Branches: After pushing a branch to the remote repository, it can be tracked. This means Git remembers the relationship between the local branch and its corresponding remote branch. git checkout -b feature-branch origin/feature-branch","title":"Remote Branches"},{"location":"Basics/git_branch/#branching-best-practices","text":"Use Descriptive Names: Choose meaningful names for branches to indicate their purpose or associated feature. Keep Branches Short-Lived: Merge branches into the main line of development once their purpose is served to avoid branch clutter. Regularly Update Branches: Keep branches up-to-date with changes in the main line of development by frequently merging or rebasing. Review Branches: Encourage code review and collaboration by reviewing changes made in feature branches before merging them.","title":"Branching Best Practices"},{"location":"Basics/git_configuration/","text":"After installing Git, the next step is to configure it with your user information. This ensures that your commits are associated with the correct identity. Follow these steps to configure Git with your user information used across all local repositories: 1. Open a Terminal/Command Prompt Windows: Git Bash, Command Prompt, or PowerShell. macOS/Linux: Terminal. 2. Set Your Username Run the following command, replacing \"Your Name\" with your actual name: git config --global user.name \"firstname Lastname\" 3. Set Your Email Address Run the following command, replacing \"your.email@example.com\" with your actual email address: git config --global user.email \"your.email@example.com\" 4. Configure Line Endings To prevent line ending issues when collaborating across different platforms, set your preferred line ending configuration. For Unix-style line endings (LF), run: git config --global core.autocrlf input For Windows-style line endings (CRLF), run: git config --global core.autocrlf true 5. Configure Text Editor (Optional) Set your preferred text editor for Git. For example, to use VSCode: git config --global core.editor \"code --wait\" 6. Enable Color Output Improve readability by enabling color output in the Git command line: git config --global color.ui auto This setting adds color to various Git outputs, making it easier to distinguish between different types of information.To view your Git configuration, run: 7. Check Configuration To view your Git configuration, run: git config --list Ensure that your name, email, and other settings are correctly displayed. 8. Verify Configuration Run the following commands to verify your configuration: git config user.name git config user.email These commands should display the values you've just set. Additional Tips Credential Caching To avoid entering your credentials repeatedly, you can set up credential caching. On Windows, Git Credential Manager is often used. On macOS/Linux, you can use the credential helper provided by Git: git config --global credential.helper cache SSH Key If you prefer using SSH for authentication, generate an SSH key and associate it with your GitHub account. Your Git configuration is now set up. You can start using Git with your personalized settings for version control and collaboration.","title":"Configuring Git"},{"location":"Basics/git_configuration/#1-open-a-terminalcommand-prompt","text":"Windows: Git Bash, Command Prompt, or PowerShell. macOS/Linux: Terminal.","title":"1. Open a Terminal/Command Prompt"},{"location":"Basics/git_configuration/#2-set-your-username","text":"Run the following command, replacing \"Your Name\" with your actual name: git config --global user.name \"firstname Lastname\"","title":"2. Set Your Username"},{"location":"Basics/git_configuration/#3-set-your-email-address","text":"Run the following command, replacing \"your.email@example.com\" with your actual email address: git config --global user.email \"your.email@example.com\"","title":"3. Set Your Email Address"},{"location":"Basics/git_configuration/#4-configure-line-endings","text":"To prevent line ending issues when collaborating across different platforms, set your preferred line ending configuration. For Unix-style line endings (LF), run: git config --global core.autocrlf input For Windows-style line endings (CRLF), run: git config --global core.autocrlf true","title":"4. Configure Line Endings"},{"location":"Basics/git_configuration/#5-configure-text-editor-optional","text":"Set your preferred text editor for Git. For example, to use VSCode: git config --global core.editor \"code --wait\"","title":"5. Configure Text Editor (Optional)"},{"location":"Basics/git_configuration/#6-enable-color-output","text":"Improve readability by enabling color output in the Git command line: git config --global color.ui auto This setting adds color to various Git outputs, making it easier to distinguish between different types of information.To view your Git configuration, run:","title":"6. Enable Color Output"},{"location":"Basics/git_configuration/#7-check-configuration","text":"To view your Git configuration, run: git config --list Ensure that your name, email, and other settings are correctly displayed.","title":"7. Check Configuration"},{"location":"Basics/git_configuration/#8-verify-configuration","text":"Run the following commands to verify your configuration: git config user.name git config user.email These commands should display the values you've just set.","title":"8. Verify Configuration"},{"location":"Basics/git_configuration/#additional-tips","text":"Credential Caching To avoid entering your credentials repeatedly, you can set up credential caching. On Windows, Git Credential Manager is often used. On macOS/Linux, you can use the credential helper provided by Git: git config --global credential.helper cache SSH Key If you prefer using SSH for authentication, generate an SSH key and associate it with your GitHub account. Your Git configuration is now set up. You can start using Git with your personalized settings for version control and collaboration.","title":"Additional Tips"},{"location":"Basics/git_inspect/","text":"In Git, several commands allow inspection and comparison of changes, commits, branches, and repository states. git status Shows the status of the working directory and staging area. git status Quickly check which files are modified, staged, or untracked. git diff Displays the differences between changes in the working directory and the staging area. git diff Review modifications before staging them or to see changes that haven't been staged yet. git diff {commit} {commit} Shows the differences between two commits. git diff abc123 def456 Compare the changes between specific commits. git diff {branch1} {branch2} Shows the differences between two branches. git diff main feature-branch Compare changes between different branches. git log Displays the commit history. git log Review the commit history, including commit messages, authors, dates, and commit hashes. git log --graph --oneline Shows a compact view of the commit history with a graph. git log --graph --oneline Visualize the branching and merging history of the repository. git log {file} Displays the commit history for a specific file. git log file.txt Review the commit history for a particular file, including changes made to it over time. git log branchB..branchA Shows the commits on branchA that are not on branchB. git log branchB..branchA Identify the commits unique to one branch compared to another, useful for understanding divergent development paths. git log --follow [file] Shows the commits that changed the specified file, even across renames. git log --follow file.txt Track the history of changes for a specific file, even if it was renamed in subsequent commits. git show {commit} Displays the details of a specific commit. git show abc123 View the changes introduced by a commit and its metadata. git branch Lists all local branches. git branch Check the available branches and see the current branch. git branch -a Lists all local and remote branches. git branch -a View all branches, including those from remote repositories. These Git commands for inspection and comparison are invaluable for understanding the state of the repository, tracking changes, reviewing history, and identifying differences between branches or commits. Incorporating these commands into your Git workflow can enhance your ability to manage and collaborate on projects effectively.","title":"Inspect & Compare"},{"location":"Basics/git_inspect/#git-status","text":"Shows the status of the working directory and staging area. git status Quickly check which files are modified, staged, or untracked.","title":"git status"},{"location":"Basics/git_inspect/#git-diff","text":"Displays the differences between changes in the working directory and the staging area. git diff Review modifications before staging them or to see changes that haven't been staged yet.","title":"git diff"},{"location":"Basics/git_inspect/#git-diff-commit-commit","text":"Shows the differences between two commits. git diff abc123 def456 Compare the changes between specific commits.","title":"git diff {commit} {commit}"},{"location":"Basics/git_inspect/#git-diff-branch1-branch2","text":"Shows the differences between two branches. git diff main feature-branch Compare changes between different branches.","title":"git diff {branch1} {branch2}"},{"location":"Basics/git_inspect/#git-log","text":"Displays the commit history. git log Review the commit history, including commit messages, authors, dates, and commit hashes.","title":"git log"},{"location":"Basics/git_inspect/#git-log-graph-oneline","text":"Shows a compact view of the commit history with a graph. git log --graph --oneline Visualize the branching and merging history of the repository.","title":"git log --graph --oneline"},{"location":"Basics/git_inspect/#git-log-file","text":"Displays the commit history for a specific file. git log file.txt Review the commit history for a particular file, including changes made to it over time.","title":"git log {file}"},{"location":"Basics/git_inspect/#git-log-branchbbrancha","text":"Shows the commits on branchA that are not on branchB. git log branchB..branchA Identify the commits unique to one branch compared to another, useful for understanding divergent development paths.","title":"git log branchB..branchA"},{"location":"Basics/git_inspect/#git-log-follow-file","text":"Shows the commits that changed the specified file, even across renames. git log --follow file.txt Track the history of changes for a specific file, even if it was renamed in subsequent commits.","title":"git log --follow [file]"},{"location":"Basics/git_inspect/#git-show-commit","text":"Displays the details of a specific commit. git show abc123 View the changes introduced by a commit and its metadata.","title":"git show {commit}"},{"location":"Basics/git_inspect/#git-branch","text":"Lists all local branches. git branch Check the available branches and see the current branch.","title":"git branch"},{"location":"Basics/git_inspect/#git-branch-a","text":"Lists all local and remote branches. git branch -a View all branches, including those from remote repositories. These Git commands for inspection and comparison are invaluable for understanding the state of the repository, tracking changes, reviewing history, and identifying differences between branches or commits. Incorporating these commands into your Git workflow can enhance your ability to manage and collaborate on projects effectively.","title":"git branch -a"},{"location":"Basics/git_install/","text":"Git is a powerful version control system that helps you manage and track changes in your codebase. Here's a simple guide on how to install Git on your machine: Windows Download Git: Visit the official Git website at https://git-scm.com/download/win. Run Installer: Once the download is complete, run the installer and follow the on-screen instructions. Make sure to leave all default settings unless you have specific preferences. Adjusting your PATH environment: Choose the default option to \"Use Git from Git Bash only\" to avoid potential conflicts with other software. Select \"Use the OpenSSL library\" for secure connections. Choosing the Terminal Emulator: You can use Git Bash as your terminal emulator, providing a Unix-like environment on Windows. Alternatively, you can choose to use the Windows Command Prompt or PowerShell. Configuring Line Endings: Select \"Checkout as-is, commit Unix-style line endings\" unless you have a specific reason to choose otherwise. Completing the Installation: Click \"Install\" to complete the installation process. macOS Install Homebrew: Open Terminal and run the following command to install Homebrew, a package manager for macOS: /bin/bash -c \" $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh ) \" 2. Install Git: Once Homebrew is installed, run the following command to install Git: brew install git Linux Ubuntu/Debian sudo apt update sudo apt install git-all Fedora sudo dnf install git Arch Linux sudo pacman -S git Verify Installation Regardless of your operating system, after installation, open a terminal and run: git --version This should display the installed Git version, confirming a successful installation. Now that Git is installed, you're ready to start using version control for your projects!","title":"Installing Git"},{"location":"Basics/git_install/#windows","text":"Download Git: Visit the official Git website at https://git-scm.com/download/win. Run Installer: Once the download is complete, run the installer and follow the on-screen instructions. Make sure to leave all default settings unless you have specific preferences. Adjusting your PATH environment: Choose the default option to \"Use Git from Git Bash only\" to avoid potential conflicts with other software. Select \"Use the OpenSSL library\" for secure connections. Choosing the Terminal Emulator: You can use Git Bash as your terminal emulator, providing a Unix-like environment on Windows. Alternatively, you can choose to use the Windows Command Prompt or PowerShell. Configuring Line Endings: Select \"Checkout as-is, commit Unix-style line endings\" unless you have a specific reason to choose otherwise. Completing the Installation: Click \"Install\" to complete the installation process.","title":"Windows"},{"location":"Basics/git_install/#macos","text":"Install Homebrew: Open Terminal and run the following command to install Homebrew, a package manager for macOS: /bin/bash -c \" $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh ) \" 2. Install Git: Once Homebrew is installed, run the following command to install Git: brew install git","title":"macOS"},{"location":"Basics/git_install/#linux","text":"","title":"Linux"},{"location":"Basics/git_install/#ubuntudebian","text":"sudo apt update sudo apt install git-all","title":"Ubuntu/Debian"},{"location":"Basics/git_install/#fedora","text":"sudo dnf install git","title":"Fedora"},{"location":"Basics/git_install/#arch-linux","text":"sudo pacman -S git","title":"Arch Linux"},{"location":"Basics/git_install/#verify-installation","text":"Regardless of your operating system, after installation, open a terminal and run: git --version This should display the installed Git version, confirming a successful installation. Now that Git is installed, you're ready to start using version control for your projects!","title":"Verify Installation"},{"location":"Basics/git_remotes/","text":"SHARE & UPDATE Retrieving updates from another repository and updating local repos. Working with remotes in Git involves collaborating with repositories hosted on remote servers. Adding a Remote git remote add <remote-name> <remote-url> git remote add origin https://github.com/user/repo.git Adds a remote repository with a given name and URL. Viewing Remote Information git remote -v Displays the URLs of the remote repositories. Fetching Changes from a Remote git fetch <remote-name> git fetch origin Fetches changes from all branches in the remote repository but does not merge them into the local branch. git fetch <remote-name> <branch-name> git fetch origin main Fetches changes from the main branch in the remote repository and merges them into the local branch. Pulling Changes from a Remote git pull <remote-name> <branch-name> git pull origin main Fetches changes from the remote repository and merges them into the local branch. Pushing Changes to a Remote git push <remote-name> <branch-name> git push origin main Pushes local commits to the remote repository. Creating a Branch in a Remote Repository git push <remote-name> <local-branch-name>:<remote-branch-name> git push origin feature-branch:feature-branch Creates a new branch in the remote repository based on the local branch. Cloning a Repository git clone <remote-url> git clone https://github.com/user/repo.git Creates a local copy of a remote repository. Renaming a Remote git remote rename <old-name> <new-name> git remote rename origin upstream Renames an existing remote. Removing a Remote git remote remove <remote-name> git remote remove origin Removes a remote from the list of remotes. Inspecting Remote Branches git branch -r Lists remote branches. The git remote show command is used to display information about a specific remote repository. It provides details such as the URL of the remote repository, the branches it tracks, and additional information about the remote branches. git remote show <remote-name> git remote show origin The output of git remote show <remote-name> typically includes the following information: Remote URL: The URL of the remote repository. Fetch URL: The URL used by git fetch to fetch from the remote repository. This may differ from the remote URL if the repository supports fetching from a different location. Push URL: The URL used by git push to push to the remote repository. This may differ from the remote URL if the repository supports pushing to a different location. Remote branches: Lists the branches present in the remote repository. Local branch configured for git pull : Indicates the local branch that git pull will merge into. Local refs configured for git push : Indicates the local branch that git push will push to. Tracking information for each branch: Shows information about the local branch's relationship with the remote branches. This includes the branch name, the remote branch it tracks, whether it is up to date, and the number of commits behind or ahead. * remote origin Fetch URL: https://github.com/user/repo.git Push URL: https://github.com/user/repo.git HEAD branch: main Remote branches: main tracked feature tracked Local branch configured for 'git pull': main merges with remote main Local refs configured for 'git push': main pushes to main (up to date) feature pushes to feature (local out of date) The git remote show command is useful for inspecting the configuration and status of a remote repository. It helps in understanding how local branches are synchronized with remote branches. The output provides valuable information for managing and coordinating work with remote repositories. Using git remote show can provide insights into the state of your remote repository, aiding in decision-making when performing operations such as fetching, pulling, or pushing changes.","title":"Remotes"},{"location":"Basics/git_remotes/#adding-a-remote","text":"git remote add <remote-name> <remote-url> git remote add origin https://github.com/user/repo.git Adds a remote repository with a given name and URL.","title":"Adding a Remote"},{"location":"Basics/git_remotes/#viewing-remote-information","text":"git remote -v Displays the URLs of the remote repositories.","title":"Viewing Remote Information"},{"location":"Basics/git_remotes/#fetching-changes-from-a-remote","text":"git fetch <remote-name> git fetch origin Fetches changes from all branches in the remote repository but does not merge them into the local branch. git fetch <remote-name> <branch-name> git fetch origin main Fetches changes from the main branch in the remote repository and merges them into the local branch.","title":"Fetching Changes from a Remote"},{"location":"Basics/git_remotes/#pulling-changes-from-a-remote","text":"git pull <remote-name> <branch-name> git pull origin main Fetches changes from the remote repository and merges them into the local branch.","title":"Pulling Changes from a Remote"},{"location":"Basics/git_remotes/#pushing-changes-to-a-remote","text":"git push <remote-name> <branch-name> git push origin main Pushes local commits to the remote repository.","title":"Pushing Changes to a Remote"},{"location":"Basics/git_remotes/#creating-a-branch-in-a-remote-repository","text":"git push <remote-name> <local-branch-name>:<remote-branch-name> git push origin feature-branch:feature-branch Creates a new branch in the remote repository based on the local branch.","title":"Creating a Branch in a Remote Repository"},{"location":"Basics/git_remotes/#cloning-a-repository","text":"git clone <remote-url> git clone https://github.com/user/repo.git Creates a local copy of a remote repository.","title":"Cloning a Repository"},{"location":"Basics/git_remotes/#renaming-a-remote","text":"git remote rename <old-name> <new-name> git remote rename origin upstream Renames an existing remote.","title":"Renaming a Remote"},{"location":"Basics/git_remotes/#removing-a-remote","text":"git remote remove <remote-name> git remote remove origin Removes a remote from the list of remotes.","title":"Removing a Remote"},{"location":"Basics/git_remotes/#inspecting-remote-branches","text":"git branch -r Lists remote branches. The git remote show command is used to display information about a specific remote repository. It provides details such as the URL of the remote repository, the branches it tracks, and additional information about the remote branches. git remote show <remote-name> git remote show origin The output of git remote show <remote-name> typically includes the following information: Remote URL: The URL of the remote repository. Fetch URL: The URL used by git fetch to fetch from the remote repository. This may differ from the remote URL if the repository supports fetching from a different location. Push URL: The URL used by git push to push to the remote repository. This may differ from the remote URL if the repository supports pushing to a different location. Remote branches: Lists the branches present in the remote repository. Local branch configured for git pull : Indicates the local branch that git pull will merge into. Local refs configured for git push : Indicates the local branch that git push will push to. Tracking information for each branch: Shows information about the local branch's relationship with the remote branches. This includes the branch name, the remote branch it tracks, whether it is up to date, and the number of commits behind or ahead. * remote origin Fetch URL: https://github.com/user/repo.git Push URL: https://github.com/user/repo.git HEAD branch: main Remote branches: main tracked feature tracked Local branch configured for 'git pull': main merges with remote main Local refs configured for 'git push': main pushes to main (up to date) feature pushes to feature (local out of date) The git remote show command is useful for inspecting the configuration and status of a remote repository. It helps in understanding how local branches are synchronized with remote branches. The output provides valuable information for managing and coordinating work with remote repositories. Using git remote show can provide insights into the state of your remote repository, aiding in decision-making when performing operations such as fetching, pulling, or pushing changes.","title":"Inspecting Remote Branches"},{"location":"Basics/git_stage/","text":"Working with snapshots and the Git staging area. For the basic workflow of staging content and committing it to your history, there are only a few basic commands. Command Example git status bash git status git add bash git add myfile.txt git reset bash git reset myfile.txt git diff bash git diff git commit bash git commit -m \"Add new feature\" git status Shows the status of your working directory, indicating which files are modified, untracked, and staged for the next commit. git status This command provides a detailed summary of the changes in your working directory. Files listed under \"Changes not staged for commit\" are modified but not staged, and files under \"Changes to be committed\" are staged for the next commit. git add Adds changes in the specified file to the staging area, preparing them for the next commit. # Create or modify a file echo \"Hello, Git!\" > myfile.txt # Stage the changes git add myfile.txt This sequence of commands creates or modifies myfile.txt and stages the changes for the next commit. Use git add . to stage all changes in the working directory. git reset Unstages changes in the specified file, reverting it to the state in the last commit, while retaining the changes in the working directory. # Unstage the changes in myfile.txt git reset myfile.txt This command removes myfile.txt from the staging area, but the changes made to the file remain in the working directory. git diff The git diff command is used when you want to see differences between any two trees. This could be the difference between your working environment and your staging area (git diff by itself), between your staging area and your last commit (git diff --staged), or between two commits (git diff master branchB). # Make changes to myfile.txt echo \"Updated content\" >> myfile.txt # View the differences git diff This command displays the unstaged changes in myfile.txt since the last commit. git diff --staged Shows the differences between the staging area and the last commit (changes that are staged but not yet committed). # Stage the changes in myfile.txt git add myfile.txt # View the differences in the staging area git diff --staged This command displays the changes that are currently staged for the next commit. git difftool The git difftool command simply launches an external tool to show you the difference between two trees in case you want to use something other than the built in git diff command. git commit Commits the changes that are staged in the snapshot, with a descriptive commit message. # Commit the changes with a message git commit -m \"Add new feature\" This command creates a new commit with the staged changes and the specified commit message. Combine git add and git commit in one step using git commit -am \"[descriptive message]\" to stage and commit changes. Committing Specific Files # Stage changes in specific files git add file1.txt file2.txt # Commit the changes with a message git commit -m \"Fix issues in file1.txt and file2.txt\" Here, only specific files ( file1.txt and file2.txt ) are staged and then committed with a message describing the fix. Amending the Last Commit # Make additional changes echo \"Additional content\" >> myfile.txt # Amend the last commit with new changes git add myfile.txt git commit --amend -m \"Update myfile.txt with additional content\" This example adds new content to myfile.txt and then amends the last commit with the additional changes. Interactive Commit # Interactively stage changes git add -i # Follow the interactive prompts to stage changes and commit Running git add -i opens an interactive mode where you can choose which changes to stage, unstage, or commit. This provides a more granular control over the commit process. Committing with Multiple Messages # Stage changes in files git add file1.txt file2.txt # Commit changes with multiple messages git commit -m \"Fix issues in file1.txt\" -m \"Add new feature in file2.txt\" You can use the -m option multiple times to provide multiple commit messages. Each -m adds a new paragraph to the commit message. Committing with a Future Date # Stage changes git add . # Commit with a future date git commit --date = \"2023-01-01T12:00:00\" -m \"Commit with a future date\" This example commits changes with a specified future date using the --date option. Committing Only Tracked Changes # Stage changes in tracked files git add -u # Commit only tracked changes git commit -m \"Commit tracked changes\" The git add -u command stages only tracked files, and then a commit is made with a message indicating the commit of tracked changes. Tracking Path Changes Versioning file removes and path changes Command Example git rm bash git rm file.txt git mv bash git mv oldfile.txt newfile.txt git clean bash git clean -ffd git log bash git log --stat -M git rm Removes files from both your working directory and the Git repository. It stages the removal of the specified files, and you need to commit to apply the changes. # Remove a file from the working directory and stage the removal git rm file.txt # Commit the removal git commit -m \"Remove file.txt\" This sequence removes file.txt from both the working directory and the Git repository, and the removal is committed. git mv Renames or moves files in both your working directory and the Git repository. Similar to git rm , it stages the rename/move, and you need to commit to apply the changes. # Rename a file and stage the change git mv oldfile.txt newfile.txt # Commit the rename git commit -m \"Rename oldfile.txt to newfile.txt\" This example renames oldfile.txt to newfile.txt , stages the change, and commits the rename. With git mv , you can also use it to move files to a different directory, like git mv file.txt new_directory/ . Use -r with git rm and git mv to handle removals or moves recursively in directories. git clean Removes untracked files from your working directory. It's useful for cleaning up untracked files that haven't been staged or committed. # List untracked files that will be removed (dry run) git clean -n # Remove untracked files git clean -f The first command ( git clean -n ) is a dry run that shows you what files would be removed. The second command ( git clean -f ) actually removes the untracked files. git clean has additional options, such as -i for an interactive mode where you can choose which files to clean. git log --stat -M This command is used to display the commit history along with statistics about the changes introduced in each commit, including information about file modifications, additions, and deletions. The -M option is particularly used to detect file renames. Let's break down the components of this command: git log : Displays the commit logs. --stat : Includes additional statistics at the end of each commit entry, providing a summary of changes. -M : Enables Git's rename detection, which identifies file renames between commits. git log --stat -M This command will output a detailed log that includes commit information and statistics. The statistics section shows the number of lines added and removed for each file affected by the commit. Additionally, if a file has been renamed, Git will provide information about the rename. Here is a simplified example of what the output might look like: commit abcd1234 (HEAD) Author: John Doe <john.doe@example.com> Date: Tue Jan 18 12:00:00 2024 +0000 Updated README.md README.md | 10 +++++----- 1 file changed, 5 insertions(+), 5 deletions(-) In this example: commit abcd1234 : The unique identifier of the commit. Author : The author of the commit. Date : The date and time of the commit. Updated README.md : The commit message. The statistics section ( README.md | 10 +++++----- ) indicates that in the file README.md , 10 lines were added, and 5 lines were removed. This section provides a quick overview of the changes made in each commit. The -M option enhances this by detecting file renames. If a file has been renamed, Git will track the rename and display the old and new filenames. The -M option can take an optional value to set a similarity index for rename detection. For example, -M90% would consider files as renamed if 90% of their content is similar. Using -M can be especially useful when you want to track the history of a file that has been renamed over time.","title":"Snapshotting"},{"location":"Basics/git_stage/#working-with-snapshots-and-the-git-staging-area","text":"For the basic workflow of staging content and committing it to your history, there are only a few basic commands. Command Example git status bash git status git add bash git add myfile.txt git reset bash git reset myfile.txt git diff bash git diff git commit bash git commit -m \"Add new feature\"","title":"Working with snapshots and the Git staging area."},{"location":"Basics/git_stage/#git-status","text":"Shows the status of your working directory, indicating which files are modified, untracked, and staged for the next commit. git status This command provides a detailed summary of the changes in your working directory. Files listed under \"Changes not staged for commit\" are modified but not staged, and files under \"Changes to be committed\" are staged for the next commit.","title":"git status"},{"location":"Basics/git_stage/#git-add","text":"Adds changes in the specified file to the staging area, preparing them for the next commit. # Create or modify a file echo \"Hello, Git!\" > myfile.txt # Stage the changes git add myfile.txt This sequence of commands creates or modifies myfile.txt and stages the changes for the next commit. Use git add . to stage all changes in the working directory.","title":"git add"},{"location":"Basics/git_stage/#git-reset","text":"Unstages changes in the specified file, reverting it to the state in the last commit, while retaining the changes in the working directory. # Unstage the changes in myfile.txt git reset myfile.txt This command removes myfile.txt from the staging area, but the changes made to the file remain in the working directory.","title":"git reset"},{"location":"Basics/git_stage/#git-diff","text":"The git diff command is used when you want to see differences between any two trees. This could be the difference between your working environment and your staging area (git diff by itself), between your staging area and your last commit (git diff --staged), or between two commits (git diff master branchB). # Make changes to myfile.txt echo \"Updated content\" >> myfile.txt # View the differences git diff This command displays the unstaged changes in myfile.txt since the last commit.","title":"git diff"},{"location":"Basics/git_stage/#git-diff-staged","text":"Shows the differences between the staging area and the last commit (changes that are staged but not yet committed). # Stage the changes in myfile.txt git add myfile.txt # View the differences in the staging area git diff --staged This command displays the changes that are currently staged for the next commit.","title":"git diff --staged"},{"location":"Basics/git_stage/#git-difftool","text":"The git difftool command simply launches an external tool to show you the difference between two trees in case you want to use something other than the built in git diff command.","title":"git difftool"},{"location":"Basics/git_stage/#git-commit","text":"Commits the changes that are staged in the snapshot, with a descriptive commit message. # Commit the changes with a message git commit -m \"Add new feature\" This command creates a new commit with the staged changes and the specified commit message. Combine git add and git commit in one step using git commit -am \"[descriptive message]\" to stage and commit changes.","title":"git commit"},{"location":"Basics/git_stage/#committing-specific-files","text":"# Stage changes in specific files git add file1.txt file2.txt # Commit the changes with a message git commit -m \"Fix issues in file1.txt and file2.txt\" Here, only specific files ( file1.txt and file2.txt ) are staged and then committed with a message describing the fix.","title":"Committing Specific Files"},{"location":"Basics/git_stage/#amending-the-last-commit","text":"# Make additional changes echo \"Additional content\" >> myfile.txt # Amend the last commit with new changes git add myfile.txt git commit --amend -m \"Update myfile.txt with additional content\" This example adds new content to myfile.txt and then amends the last commit with the additional changes.","title":"Amending the Last Commit"},{"location":"Basics/git_stage/#interactive-commit","text":"# Interactively stage changes git add -i # Follow the interactive prompts to stage changes and commit Running git add -i opens an interactive mode where you can choose which changes to stage, unstage, or commit. This provides a more granular control over the commit process.","title":"Interactive Commit"},{"location":"Basics/git_stage/#committing-with-multiple-messages","text":"# Stage changes in files git add file1.txt file2.txt # Commit changes with multiple messages git commit -m \"Fix issues in file1.txt\" -m \"Add new feature in file2.txt\" You can use the -m option multiple times to provide multiple commit messages. Each -m adds a new paragraph to the commit message.","title":"Committing with Multiple Messages"},{"location":"Basics/git_stage/#committing-with-a-future-date","text":"# Stage changes git add . # Commit with a future date git commit --date = \"2023-01-01T12:00:00\" -m \"Commit with a future date\" This example commits changes with a specified future date using the --date option.","title":"Committing with a Future Date"},{"location":"Basics/git_stage/#committing-only-tracked-changes","text":"# Stage changes in tracked files git add -u # Commit only tracked changes git commit -m \"Commit tracked changes\" The git add -u command stages only tracked files, and then a commit is made with a message indicating the commit of tracked changes.","title":"Committing Only Tracked Changes"},{"location":"Basics/git_stage/#tracking-path-changes","text":"Versioning file removes and path changes Command Example git rm bash git rm file.txt git mv bash git mv oldfile.txt newfile.txt git clean bash git clean -ffd git log bash git log --stat -M","title":"Tracking Path Changes"},{"location":"Basics/git_stage/#git-rm","text":"Removes files from both your working directory and the Git repository. It stages the removal of the specified files, and you need to commit to apply the changes. # Remove a file from the working directory and stage the removal git rm file.txt # Commit the removal git commit -m \"Remove file.txt\" This sequence removes file.txt from both the working directory and the Git repository, and the removal is committed.","title":"git rm"},{"location":"Basics/git_stage/#git-mv","text":"Renames or moves files in both your working directory and the Git repository. Similar to git rm , it stages the rename/move, and you need to commit to apply the changes. # Rename a file and stage the change git mv oldfile.txt newfile.txt # Commit the rename git commit -m \"Rename oldfile.txt to newfile.txt\" This example renames oldfile.txt to newfile.txt , stages the change, and commits the rename. With git mv , you can also use it to move files to a different directory, like git mv file.txt new_directory/ . Use -r with git rm and git mv to handle removals or moves recursively in directories.","title":"git mv"},{"location":"Basics/git_stage/#git-clean","text":"Removes untracked files from your working directory. It's useful for cleaning up untracked files that haven't been staged or committed. # List untracked files that will be removed (dry run) git clean -n # Remove untracked files git clean -f The first command ( git clean -n ) is a dry run that shows you what files would be removed. The second command ( git clean -f ) actually removes the untracked files. git clean has additional options, such as -i for an interactive mode where you can choose which files to clean.","title":"git clean"},{"location":"Basics/git_stage/#git-log-stat-m","text":"This command is used to display the commit history along with statistics about the changes introduced in each commit, including information about file modifications, additions, and deletions. The -M option is particularly used to detect file renames. Let's break down the components of this command: git log : Displays the commit logs. --stat : Includes additional statistics at the end of each commit entry, providing a summary of changes. -M : Enables Git's rename detection, which identifies file renames between commits. git log --stat -M This command will output a detailed log that includes commit information and statistics. The statistics section shows the number of lines added and removed for each file affected by the commit. Additionally, if a file has been renamed, Git will provide information about the rename. Here is a simplified example of what the output might look like: commit abcd1234 (HEAD) Author: John Doe <john.doe@example.com> Date: Tue Jan 18 12:00:00 2024 +0000 Updated README.md README.md | 10 +++++----- 1 file changed, 5 insertions(+), 5 deletions(-) In this example: commit abcd1234 : The unique identifier of the commit. Author : The author of the commit. Date : The date and time of the commit. Updated README.md : The commit message. The statistics section ( README.md | 10 +++++----- ) indicates that in the file README.md , 10 lines were added, and 5 lines were removed. This section provides a quick overview of the changes made in each commit. The -M option enhances this by detecting file renames. If a file has been renamed, Git will track the rename and display the old and new filenames. The -M option can take an optional value to set a similarity index for rename detection. For example, -M90% would consider files as renamed if 90% of their content is similar. Using -M can be especially useful when you want to track the history of a file that has been renamed over time.","title":"git log --stat -M"},{"location":"Basics/git_start/","text":"This section describes the process of initializing a Git project from scratch. Navigate to Your Project Directory Before initializing a Git repository, navigate to the directory of your existing project or create a new project folder. Open a terminal or command prompt and change into the project directory: cd path/to/your/project Initializing a Git repository involves setting up Git to manage your project's version control. It creates a hidden subfolder within your project that houses the internal data structure required for version control. Version control allows you to track changes, collaborate with others, and revert to previous states of your project. Initializing a Git repository is the first step to harnessing these benefits. Initialize the Git Repository Run the following command to initialize a Git repository in your project folder: git init After running git init , Git creates a .git directory in your project folder. This directory contains all the necessary files for version control.The .git directory is where Git stores information about your project's history, branches, configurations, and more. git init Options Initialize a New Git Repository git init Initializes a new Git repository in the current working directory. Initialize in a Specific Directory git init <directory> Initializes a new Git repository in the specified directory. Example: git init my_project git init Flags --bare git init --bare Initializes a bare Git repository. Bare repositories do not have a working directory, making them suitable for centralized repositories. --template=<tmplt_dir> git init --template = <template_directory> Initializes a new Git repository using the specified template directory. This can be useful for setting up a custom project structure. Example: git init --template = /path/to/custom/template --separate-git-dir=<git_dir> git init --separate-git-dir = <git_dir> Initializes a new Git repository and sets up a separate Git directory. This can be useful in scenarios where the working directory is on a different filesystem. Example: git init --separate-git-dir = /path/to/separate/git/dir --quiet or -q git init --quiet Suppresses all output during the initialization process. Example: git init --quiet Clone an existing Git Repository The git clone command is used to create a copy of a remote Git repository. It copies the entire repository, including the commit history, branches, and files, to your local machine. Here's a detailed explanation of the git clone command along with some commonly used flags and options: 1. git clone <repository_url> Clones a remote Git repository to your local machine in the folder that you are in. To obtain a local copy of a project, collaborate with others, or contribute to open-source projects. git clone <repository_url> Example: git clone https://github.com/example/repo.git 2. git clone --branch <branch_name> Clones a specific branch from the remote repository. To clone a specific branch instead of the default branch (usually master or main ). git clone --branch <branch_name> <repository_url> Example: git clone --branch develop https://github.com/example/repo.git 3. git clone --branch <branch_name> <repository_url> Clones a specific branch from the remote repository to a specific folder. To clone a specific branch instead of the default branch (usually master or main ) into a specific folder. git clone --branch <branch_name> <repository_url> <path/to/folder> Example: git clone --branch master git@github.com:ArceLopera/git_refresher.git mylocalrepo 4. git clone --depth <depth> Clones a specified number of commits from the remote repository, creating a shallow clone.To reduce the size of the clone by fetching only a limited commit history. git clone --depth <depth> <repository_url> Example: git clone --depth 1 https://github.com/example/repo.git 5. git clone --recursive Clones submodules along with the main repository. To clone and initialize submodules contained within the repository. git clone --recursive <repository_url> Example: git clone --recursive https://github.com/example/repo.git","title":"Starting a Project"},{"location":"Basics/git_start/#navigate-to-your-project-directory","text":"Before initializing a Git repository, navigate to the directory of your existing project or create a new project folder. Open a terminal or command prompt and change into the project directory: cd path/to/your/project Initializing a Git repository involves setting up Git to manage your project's version control. It creates a hidden subfolder within your project that houses the internal data structure required for version control. Version control allows you to track changes, collaborate with others, and revert to previous states of your project. Initializing a Git repository is the first step to harnessing these benefits.","title":"Navigate to Your Project Directory"},{"location":"Basics/git_start/#initialize-the-git-repository","text":"Run the following command to initialize a Git repository in your project folder: git init After running git init , Git creates a .git directory in your project folder. This directory contains all the necessary files for version control.The .git directory is where Git stores information about your project's history, branches, configurations, and more.","title":"Initialize the Git Repository"},{"location":"Basics/git_start/#git-init-options","text":"","title":"git init Options"},{"location":"Basics/git_start/#git-init-flags","text":"","title":"git init Flags"},{"location":"Basics/git_start/#clone-an-existing-git-repository","text":"The git clone command is used to create a copy of a remote Git repository. It copies the entire repository, including the commit history, branches, and files, to your local machine. Here's a detailed explanation of the git clone command along with some commonly used flags and options:","title":"Clone an existing Git Repository"},{"location":"Basics/git_start/#1-git-clone-repository_url","text":"Clones a remote Git repository to your local machine in the folder that you are in. To obtain a local copy of a project, collaborate with others, or contribute to open-source projects. git clone <repository_url>","title":"1. git clone &lt;repository_url&gt;"},{"location":"Basics/git_start/#2-git-clone-branch-branch_name","text":"Clones a specific branch from the remote repository. To clone a specific branch instead of the default branch (usually master or main ). git clone --branch <branch_name> <repository_url>","title":"2. git clone --branch &lt;branch_name&gt;"},{"location":"Basics/git_start/#3-git-clone-branch-branch_name-repository_url","text":"Clones a specific branch from the remote repository to a specific folder. To clone a specific branch instead of the default branch (usually master or main ) into a specific folder. git clone --branch <branch_name> <repository_url> <path/to/folder>","title":"3. git clone --branch &lt;branch_name&gt; &lt;repository_url&gt;"},{"location":"Basics/git_start/#4-git-clone-depth-depth","text":"Clones a specified number of commits from the remote repository, creating a shallow clone.To reduce the size of the clone by fetching only a limited commit history. git clone --depth <depth> <repository_url>","title":"4. git clone --depth &lt;depth&gt;"},{"location":"Basics/git_start/#5-git-clone-recursive","text":"Clones submodules along with the main repository. To clone and initialize submodules contained within the repository. git clone --recursive <repository_url>","title":"5. git clone --recursive"},{"location":"Basics/git_tagging/","text":"In Git, tagging is the process of assigning a meaningful label or marker to a specific commit in the repository's history. Tags are often used to mark significant points in the project's development, such as releases, versions, or milestones. Types of Tags There are two types of tags in Git: Lightweight Tags These are simple pointers to specific commits, similar to branches but immutable. They are created with the -l option. Annotated Tags These are stored as full objects in the Git database, containing details like the tagger's name, email, date, and a tagging message. They are created with the -a option. Creating Tags Lightweight Tags git tag <tag-name> <commit-hash> git tag v1.0.0 7c52d53 Annotated Tags git tag -a <tag-name> <commit-hash> -m \"Tagging message\" git tag -a v1.0.0 7c52d53 -m \"Version 1.0.0 release\" The -m specifies a tagging message, which is stored with the tag. If you don\u2019t specify a message for an annotated tag, Git launches your editor so you can type it in. Tagging Later : You can also tag commits after you\u2019ve moved past them. Viewing Tags To view all tags in the repository: git tag In Git, listing tags allows you to view all tags present in the repository. You can use wildcards to filter tags based on specific patterns. Here's how you can list tags in Git with examples and wildcards: Listing Tags Matching a Pattern You can use wildcards to list tags matching a specific pattern. Listing tag wildcards requires -l or --list option. The two common wildcards used are: * : Matches any sequence of characters. ? : Matches any single character. Listing Tags Starting with a Prefix To list tags starting with a specific prefix (e.g., v1 ): git tag -l 'v1*' Listing Tags with Annotated Tags Only To list only annotated tags (excluding lightweight tags): git tag -l -n Using wildcards with git tag -l allows you to filter and list tags based on specific patterns, making it easier to manage and navigate through tags in your Git repository. Pushing Tags to Remote To push a specific tag to the remote repository: git push origin <tag-name> To push all tags to the remote repository: git push origin --tags git push origin v1.0.0 git push pushes both types of tags. git push --tags will push both lightweight and annotated tags. There is currently no option to push only lightweight tags, but if you use git push --follow-tags only annotated tags will be pushed to the remote. Deleting Tags To delete a specific tag: git tag -d <tag-name> git tag -d v1.0.0 To delete a tag on the remote repository: git push origin --delete <tag-name> git push origin --delete v1.0.0 Checking out Tags To checkout a specific tag and create a detached HEAD state: git checkout <tag-name> git checkout v1.0.0 In \u201cdetached HEAD\u201d state, if you make changes and then create a commit, the tag will stay the same, but your new commit won\u2019t belong to any branch and will be unreachable, except by the exact commit hash. Thus, if you need to make changes\u2009\u2014\u2009say you\u2019re fixing a bug on an older version, for instance\u2009\u2014\u2009you will generally want to create a branch: $ git checkout -b version2 v2.0.0 #Switched to a new branch 'version2' If you do this and make a commit, your version2 branch will be slightly different than your v2.0.0 tag since it will move forward with your new changes, so do be careful. Tagging Best Practices Use semantic versioning (e.g., v1.0.0, v1.1.0) for version tags to maintain consistency. Annotate tags with meaningful messages describing the purpose or significance of the tagged commit. Push tags to the remote repository to share them with collaborators and facilitate release management. Git tagging is a powerful feature for marking important points in your project's history, making it easier to navigate and manage releases.","title":"Tagging"},{"location":"Basics/git_tagging/#types-of-tags","text":"There are two types of tags in Git: Lightweight Tags These are simple pointers to specific commits, similar to branches but immutable. They are created with the -l option. Annotated Tags These are stored as full objects in the Git database, containing details like the tagger's name, email, date, and a tagging message. They are created with the -a option.","title":"Types of Tags"},{"location":"Basics/git_tagging/#creating-tags","text":"","title":"Creating Tags"},{"location":"Basics/git_tagging/#lightweight-tags","text":"git tag <tag-name> <commit-hash> git tag v1.0.0 7c52d53","title":"Lightweight Tags"},{"location":"Basics/git_tagging/#annotated-tags","text":"git tag -a <tag-name> <commit-hash> -m \"Tagging message\" git tag -a v1.0.0 7c52d53 -m \"Version 1.0.0 release\" The -m specifies a tagging message, which is stored with the tag. If you don\u2019t specify a message for an annotated tag, Git launches your editor so you can type it in. Tagging Later : You can also tag commits after you\u2019ve moved past them.","title":"Annotated Tags"},{"location":"Basics/git_tagging/#viewing-tags","text":"To view all tags in the repository: git tag In Git, listing tags allows you to view all tags present in the repository. You can use wildcards to filter tags based on specific patterns. Here's how you can list tags in Git with examples and wildcards:","title":"Viewing Tags"},{"location":"Basics/git_tagging/#listing-tags-matching-a-pattern","text":"You can use wildcards to list tags matching a specific pattern. Listing tag wildcards requires -l or --list option. The two common wildcards used are: * : Matches any sequence of characters. ? : Matches any single character.","title":"Listing Tags Matching a Pattern"},{"location":"Basics/git_tagging/#listing-tags-starting-with-a-prefix","text":"To list tags starting with a specific prefix (e.g., v1 ): git tag -l 'v1*'","title":"Listing Tags Starting with a Prefix"},{"location":"Basics/git_tagging/#listing-tags-with-annotated-tags-only","text":"To list only annotated tags (excluding lightweight tags): git tag -l -n Using wildcards with git tag -l allows you to filter and list tags based on specific patterns, making it easier to manage and navigate through tags in your Git repository.","title":"Listing Tags with Annotated Tags Only"},{"location":"Basics/git_tagging/#pushing-tags-to-remote","text":"To push a specific tag to the remote repository: git push origin <tag-name> To push all tags to the remote repository: git push origin --tags git push origin v1.0.0 git push pushes both types of tags. git push --tags will push both lightweight and annotated tags. There is currently no option to push only lightweight tags, but if you use git push --follow-tags only annotated tags will be pushed to the remote.","title":"Pushing Tags to Remote"},{"location":"Basics/git_tagging/#deleting-tags","text":"To delete a specific tag: git tag -d <tag-name> git tag -d v1.0.0 To delete a tag on the remote repository: git push origin --delete <tag-name> git push origin --delete v1.0.0","title":"Deleting Tags"},{"location":"Basics/git_tagging/#checking-out-tags","text":"To checkout a specific tag and create a detached HEAD state: git checkout <tag-name> git checkout v1.0.0 In \u201cdetached HEAD\u201d state, if you make changes and then create a commit, the tag will stay the same, but your new commit won\u2019t belong to any branch and will be unreachable, except by the exact commit hash. Thus, if you need to make changes\u2009\u2014\u2009say you\u2019re fixing a bug on an older version, for instance\u2009\u2014\u2009you will generally want to create a branch: $ git checkout -b version2 v2.0.0 #Switched to a new branch 'version2' If you do this and make a commit, your version2 branch will be slightly different than your v2.0.0 tag since it will move forward with your new changes, so do be careful.","title":"Checking out Tags"},{"location":"Basics/git_tagging/#tagging-best-practices","text":"Use semantic versioning (e.g., v1.0.0, v1.1.0) for version tags to maintain consistency. Annotate tags with meaningful messages describing the purpose or significance of the tagged commit. Push tags to the remote repository to share them with collaborators and facilitate release management. Git tagging is a powerful feature for marking important points in your project's history, making it easier to navigate and manage releases.","title":"Tagging Best Practices"},{"location":"Basics/git_undoingthings/","text":"Undoing changes in Git involves various commands and strategies, depending on the nature of the changes and the stage at which they are. Here is a comprehensive guide on common Git undo commands and strategies: Summary table of common Git undo commands and strategies: Action Command Description Undoing Uncommitted Changes git checkout -- file.txt Discard changes in a specific file, reverting it to the state in the last commit. git reset --hard Discard all uncommitted changes, reverting the working directory to the state of the last commit. Undoing Staged Changes git reset file.txt Unstage changes in a specific file, moving them back to the working directory. Undoing Commits git reset --soft HEAD^ Undo the last commit, keeping changes staged in the working directory. git reset --mixed HEAD^ Undo the last commit, unstaging changes but keeping them in the working directory. git reset --hard HEAD^ Undo the last commit, discarding changes both in the commit and the working directory. git commit --amend Amend the last commit by adding new changes or modifying the commit message. Reverting Commits git revert <commit-hash> Create a new commit that undoes changes introduced by a specific commit. Undoing Remote Changes git push --force origin <branch-name> Force push local changes to a remote branch (use with caution, as it rewrites remote history). Resetting to a Specific Commit git reset --hard <commit-hash> Reset the branch to a specific commit, discarding all changes after that commit. Cleaning Untracked Files git clean -fd Remove untracked files and directories from the working directory. Interactively Reverting or Editing git rebase -i <commit-hash> Open an interactive rebase session, allowing you to edit, squash, or drop commits. Restoring Files git restore file.txt Restore the specified file to the state in the last commit (introduced in Git 2.23). Rewriting history git rebase main Apply any commits of the current branch ahead of the specified one. Please note that some commands, like force push and hard reset, should be used with caution, especially when collaborating with others, as they can alter Git history. Always be mindful of the consequences and potential impacts on collaborators before executing these commands. 1. Undoing Uncommitted Changes in the Working Directory Discard Changes in a File git checkout -- file.txt This command discards changes in the specified file, reverting it to the state in the last commit. It\u2019s important to understand that git checkout -- <file> is a dangerous command. Any local changes you made to that file are gone\u2009\u2014\u2009Git just replaced that file with the last staged or committed version. Don\u2019t ever use this command unless you absolutely know that you don\u2019t want those unsaved local changes. Discard All Changes git reset --hard This command discards all uncommitted changes in the working directory, reverting it to the state of the last commit. 2. Undoing Staged Changes Unstage Changes git reset file.txt This command unstages changes in the specified file, moving them back to the working directory. 3. Undoing Commits Undo the Last Commit (soft reset) git reset --soft HEAD^ This command undoes the last commit, keeping the changes staged in the working directory. Undo the Last Commit (mixed reset, default) git reset --mixed HEAD^ This command undoes the last commit, unstaging the changes but keeping them in the working directory. Undo the Last Commit (hard reset) git reset --hard HEAD^ This command undoes the last commit, discarding the changes both in the commit and the working directory. Amend the Last Commit git commit --amend This command allows you to amend the last commit by adding new changes or modifying the commit message. 4. Reverting Commits Revert a Commit git revert <commit-hash> This command creates a new commit that undoes the changes introduced by a specific commit. 5. Undoing Remote Changes Force Push to Remote (use with caution) git push --force origin <branch-name> Use this command to force push local changes to a remote branch. Be cautious as it rewrites the remote history. 6. Resetting to a Specific Commit Reset to a Specific Commit git reset --hard <commit-hash> This command resets the branch to a specific commit, discarding all changes after that commit. 7. Cleaning Untracked Files Remove Untracked Files and Directories git clean -fd This command removes untracked files and directories from the working directory. 8. Interactively Reverting or Editing Commits Interactive Rebase git rebase -i <commit-hash> This command opens an interactive rebase session, allowing you to edit, squash, or drop commits. The git rebase -i HEAD~6 command initiates an interactive rebase for the last six commits starting from the current HEAD . This allows you to modify, reorder, squash, or drop commits interactively before applying them onto a new base commit. Let's break down the components of this command: git rebase : The main command for reorganizing or combining commits. -i : Stands for \"interactive,\" which opens an interactive rebase session. HEAD~6 : Specifies the commit range to rebase. In this case, it's the last six commits from the current HEAD . git rebase -i HEAD~6 This command opens a text editor with a list of the last six commits in your default branch. The list might look something like this: pick abc123 Commit message 1 pick def456 Commit message 2 pick 789ghi Commit message 3 pick jkl012 Commit message 4 pick mno345 Commit message 5 pick pqr678 Commit message 6 In the interactive rebase editor, you can choose actions for each commit: pick : Keep the commit as is. reword : Change the commit message. edit : Pause for amending the commit. squash or fixup : Combine the commit with the previous one. drop : Remove the commit. For example, to squash the last three commits into a single commit, you can modify the file to look like this: pick abc123 Commit message 1 pick def456 Commit message 2 squash 789ghi Commit message 3 squash jkl012 Commit message 4 squash mno345 Commit message 5 pick pqr678 Commit message 6 After saving and closing the file, Git will prompt you to modify the commit message for the new squashed commit. Interactive rebasing allows you to create a cleaner and more organized commit history. Use edit to pause at a specific commit and make changes (e.g., amend, add files, or reword the commit message). Always make sure to review and understand the changes you're making during an interactive rebase, as it rewrites commit history. Interactive rebasing is a powerful but potentially risky operation. Be cautious and ensure you have a backup or a way to recover your changes if needed. 9. Restoring Files The git restore command is a versatile command introduced in Git version 2.23. It is designed to restore parts of the working directory or discard changes in a way that is more explicit and flexible than some of the previous commands. Restore Uncommitted Changes in a File: To discard uncommitted changes in a specific file and restore it to the state in the last commit: git restore file.txt This command reverts the changes made to file.txt in the working directory, making it identical to the state of the file in the last commit. Restore Staged Changes in a File: To unstage changes in a file and move them back to the working directory: git restore --staged file.txt This command effectively undoes the staging of changes in file.txt and puts them back into the working directory. It is similar to git reset file.txt , but git restore is more explicit in this context. Restore Specific Commit's State for a File: To restore a specific file to the state it had in a particular commit: git restore --source = <commit-hash> --staged --worktree file.txt --source=<commit-hash> : Specifies the commit from which to take the file state. --staged : Restores the file to the specified commit's state in the staging area. --worktree : Restores the file to the specified commit's state in the working directory. Restore Entire Working Directory: To discard all uncommitted changes and restore the entire working directory to the state of the last commit: git restore --source = HEAD --staged --worktree --source = HEAD --recursive --source=HEAD : Specifies the commit from which to take the file states. --staged : Restores all changes to the staging area. --worktree : Restores all changes to the working directory. --recursive : Applies the operation recursively to all files and directories. The git restore command provides a clearer and more explicit syntax for specific use cases, making it a powerful tool for managing changes in the working directory and staging area. Always use it with care, especially when dealing with commands that modify or discard changes. Comparing git reset and git restore git reset and git restore are both Git commands that deal with modifying the working directory, staging area, and commit history, but they serve slightly different purposes. Let's compare them in terms of functionality and use cases: git reset Purpose Primarily used for resetting the branch pointer, staging area, and working directory to a specific commit. Can be used to undo commits, unstage changes, and discard changes in the working directory. Key Options --soft : Keeps changes in the working directory and staging area. --mixed (default): Unstages changes but keeps them in the working directory. --hard : Discards changes in the working directory, staging area, and the commit itself. Examples Undo the last commit and keep changes in the working directory: git reset --soft HEAD^ Unstage changes and keep them in the working directory: git reset file.txt git restore Purpose Introduced in Git 2.23 as a more explicit command for restoring parts of the working directory. Designed for restoring files, either discarding changes or moving them between the working directory and staging area. Key Options --source=<commit> : Specifies the commit from which to take the file state. --staged : Restores the file to the specified commit's state in the staging area. --worktree : Restores the file to the specified commit's state in the working directory. Examples Discard uncommitted changes in a file: git restore file.txt Unstage changes in a file and move them back to the working directory: git restore --staged file.txt Use Cases: git reset is often used for branch-related operations and has more options for handling staged and unstaged changes. git restore is tailored specifically for restoring parts of the working directory and is focused on clarity. git reset can be used to amend or undo commits, while git restore focuses more on file-level restoration. Ultimately, the choice between git reset and git restore depends on the specific use case and the level of clarity you seek in your Git commands. 10. Rewriting history In Git, rewriting branches, updating commits, and clearing history are common tasks that allow you to modify the commit history of a repository. These actions can be useful for cleaning up history, organizing commits, or incorporating changes from other branches. Here's an explanation, including the provided commands and additional relevant ones: 1. git rebase [branch]: Apply any commits of the current branch ahead of the specified one. git rebase main Incorporate changes from another branch ( main in this example) into the current branch, moving your commits to the tip of the specified branch. 2. git reset --hard [commit]: Clear the staging area and rewrite the working tree from the specified commit. git reset --hard abc123 Reset the current branch to the specified commit ( abc123 in this example), discarding any changes and resetting both the working directory and the staging area to match the state of the specified commit. 3. git commit --amend: Modify the last commit by combining staged changes with the previous commit. git commit --amend Edit the commit message or add more changes to the previous commit before finalizing it. 4. git rebase -i [commit]: Interactively rebase commits starting from the specified commit. git rebase -i abc123 Reword, squash, edit, or reorder commits interactively to clean up the commit history. 5. git filter-branch: Rewrite branches to remove unwanted data, such as sensitive information or large files. git filter-branch --tree-filter 'rm -f passwords.txt' HEAD Filter branch content by applying a specified command to each commit, useful for history rewriting tasks. 6. git cherry-pick [commit]: Apply the changes introduced by the specified commit to the current branch. git cherry-pick abc123 Selectively pick specific commits from one branch and apply them to another branch. Rewriting branches, updating commits, and clearing history in Git are powerful capabilities that should be used with caution, especially in collaborative environments. These commands enable you to maintain a clean and organized history, improving project maintainability and readability. However, always ensure that you understand the consequences of these actions before applying them, as they can alter the commit history irreversibly. 7. git checkout -f : When switching branches, proceed even if the index or the working tree differs from HEAD, and even if there are untracked files in the way. This command is used to forcefully switch branches, discarding any local changes or untracked files that may prevent the branch switch. git checkout -f feature-branch - Note: Be cautious when using this command, as it will discard any local changes without warning. 8. git clean -ffd : Erase all untracked files and directories in the working directory. This command is used to clean up the working directory by removing any untracked files or directories that are not under version control. git clean -ffd - Note: The -f option is used to force the clean operation, and the -d option is used to include untracked directories. These commands are useful for cleaning up a Git repository before starting fresh or resolving conflicts that prevent branch switching. However, they should be used with caution, as they can permanently delete local changes and untracked files. It's essential to understand the implications of using these commands and ensure that any necessary changes or files are backed up before proceeding.","title":"Undoing Things"},{"location":"Basics/git_undoingthings/#1-undoing-uncommitted-changes-in-the-working-directory","text":"Discard Changes in a File git checkout -- file.txt This command discards changes in the specified file, reverting it to the state in the last commit. It\u2019s important to understand that git checkout -- <file> is a dangerous command. Any local changes you made to that file are gone\u2009\u2014\u2009Git just replaced that file with the last staged or committed version. Don\u2019t ever use this command unless you absolutely know that you don\u2019t want those unsaved local changes. Discard All Changes git reset --hard This command discards all uncommitted changes in the working directory, reverting it to the state of the last commit.","title":"1. Undoing Uncommitted Changes in the Working Directory"},{"location":"Basics/git_undoingthings/#2-undoing-staged-changes","text":"Unstage Changes git reset file.txt This command unstages changes in the specified file, moving them back to the working directory.","title":"2. Undoing Staged Changes"},{"location":"Basics/git_undoingthings/#3-undoing-commits","text":"Undo the Last Commit (soft reset) git reset --soft HEAD^ This command undoes the last commit, keeping the changes staged in the working directory. Undo the Last Commit (mixed reset, default) git reset --mixed HEAD^ This command undoes the last commit, unstaging the changes but keeping them in the working directory. Undo the Last Commit (hard reset) git reset --hard HEAD^ This command undoes the last commit, discarding the changes both in the commit and the working directory. Amend the Last Commit git commit --amend This command allows you to amend the last commit by adding new changes or modifying the commit message.","title":"3. Undoing Commits"},{"location":"Basics/git_undoingthings/#4-reverting-commits","text":"Revert a Commit git revert <commit-hash> This command creates a new commit that undoes the changes introduced by a specific commit.","title":"4. Reverting Commits"},{"location":"Basics/git_undoingthings/#5-undoing-remote-changes","text":"Force Push to Remote (use with caution) git push --force origin <branch-name> Use this command to force push local changes to a remote branch. Be cautious as it rewrites the remote history.","title":"5. Undoing Remote Changes"},{"location":"Basics/git_undoingthings/#6-resetting-to-a-specific-commit","text":"Reset to a Specific Commit git reset --hard <commit-hash> This command resets the branch to a specific commit, discarding all changes after that commit.","title":"6. Resetting to a Specific Commit"},{"location":"Basics/git_undoingthings/#7-cleaning-untracked-files","text":"Remove Untracked Files and Directories git clean -fd This command removes untracked files and directories from the working directory.","title":"7. Cleaning Untracked Files"},{"location":"Basics/git_undoingthings/#8-interactively-reverting-or-editing-commits","text":"Interactive Rebase git rebase -i <commit-hash> This command opens an interactive rebase session, allowing you to edit, squash, or drop commits. The git rebase -i HEAD~6 command initiates an interactive rebase for the last six commits starting from the current HEAD . This allows you to modify, reorder, squash, or drop commits interactively before applying them onto a new base commit. Let's break down the components of this command: git rebase : The main command for reorganizing or combining commits. -i : Stands for \"interactive,\" which opens an interactive rebase session. HEAD~6 : Specifies the commit range to rebase. In this case, it's the last six commits from the current HEAD . git rebase -i HEAD~6 This command opens a text editor with a list of the last six commits in your default branch. The list might look something like this: pick abc123 Commit message 1 pick def456 Commit message 2 pick 789ghi Commit message 3 pick jkl012 Commit message 4 pick mno345 Commit message 5 pick pqr678 Commit message 6 In the interactive rebase editor, you can choose actions for each commit: pick : Keep the commit as is. reword : Change the commit message. edit : Pause for amending the commit. squash or fixup : Combine the commit with the previous one. drop : Remove the commit. For example, to squash the last three commits into a single commit, you can modify the file to look like this: pick abc123 Commit message 1 pick def456 Commit message 2 squash 789ghi Commit message 3 squash jkl012 Commit message 4 squash mno345 Commit message 5 pick pqr678 Commit message 6 After saving and closing the file, Git will prompt you to modify the commit message for the new squashed commit. Interactive rebasing allows you to create a cleaner and more organized commit history. Use edit to pause at a specific commit and make changes (e.g., amend, add files, or reword the commit message). Always make sure to review and understand the changes you're making during an interactive rebase, as it rewrites commit history. Interactive rebasing is a powerful but potentially risky operation. Be cautious and ensure you have a backup or a way to recover your changes if needed.","title":"8. Interactively Reverting or Editing Commits"},{"location":"Basics/git_undoingthings/#9-restoring-files","text":"The git restore command is a versatile command introduced in Git version 2.23. It is designed to restore parts of the working directory or discard changes in a way that is more explicit and flexible than some of the previous commands. Restore Uncommitted Changes in a File: To discard uncommitted changes in a specific file and restore it to the state in the last commit: git restore file.txt This command reverts the changes made to file.txt in the working directory, making it identical to the state of the file in the last commit. Restore Staged Changes in a File: To unstage changes in a file and move them back to the working directory: git restore --staged file.txt This command effectively undoes the staging of changes in file.txt and puts them back into the working directory. It is similar to git reset file.txt , but git restore is more explicit in this context. Restore Specific Commit's State for a File: To restore a specific file to the state it had in a particular commit: git restore --source = <commit-hash> --staged --worktree file.txt --source=<commit-hash> : Specifies the commit from which to take the file state. --staged : Restores the file to the specified commit's state in the staging area. --worktree : Restores the file to the specified commit's state in the working directory. Restore Entire Working Directory: To discard all uncommitted changes and restore the entire working directory to the state of the last commit: git restore --source = HEAD --staged --worktree --source = HEAD --recursive --source=HEAD : Specifies the commit from which to take the file states. --staged : Restores all changes to the staging area. --worktree : Restores all changes to the working directory. --recursive : Applies the operation recursively to all files and directories. The git restore command provides a clearer and more explicit syntax for specific use cases, making it a powerful tool for managing changes in the working directory and staging area. Always use it with care, especially when dealing with commands that modify or discard changes. Comparing git reset and git restore git reset and git restore are both Git commands that deal with modifying the working directory, staging area, and commit history, but they serve slightly different purposes. Let's compare them in terms of functionality and use cases: git reset Purpose Primarily used for resetting the branch pointer, staging area, and working directory to a specific commit. Can be used to undo commits, unstage changes, and discard changes in the working directory. Key Options --soft : Keeps changes in the working directory and staging area. --mixed (default): Unstages changes but keeps them in the working directory. --hard : Discards changes in the working directory, staging area, and the commit itself. Examples Undo the last commit and keep changes in the working directory: git reset --soft HEAD^ Unstage changes and keep them in the working directory: git reset file.txt git restore Purpose Introduced in Git 2.23 as a more explicit command for restoring parts of the working directory. Designed for restoring files, either discarding changes or moving them between the working directory and staging area. Key Options --source=<commit> : Specifies the commit from which to take the file state. --staged : Restores the file to the specified commit's state in the staging area. --worktree : Restores the file to the specified commit's state in the working directory. Examples Discard uncommitted changes in a file: git restore file.txt Unstage changes in a file and move them back to the working directory: git restore --staged file.txt Use Cases: git reset is often used for branch-related operations and has more options for handling staged and unstaged changes. git restore is tailored specifically for restoring parts of the working directory and is focused on clarity. git reset can be used to amend or undo commits, while git restore focuses more on file-level restoration. Ultimately, the choice between git reset and git restore depends on the specific use case and the level of clarity you seek in your Git commands.","title":"9. Restoring Files"},{"location":"Basics/git_undoingthings/#10-rewriting-history","text":"In Git, rewriting branches, updating commits, and clearing history are common tasks that allow you to modify the commit history of a repository. These actions can be useful for cleaning up history, organizing commits, or incorporating changes from other branches. Here's an explanation, including the provided commands and additional relevant ones:","title":"10. Rewriting history"},{"location":"Basics/git_undoingthings/#1-git-rebase-branch","text":"Apply any commits of the current branch ahead of the specified one. git rebase main Incorporate changes from another branch ( main in this example) into the current branch, moving your commits to the tip of the specified branch.","title":"1. git rebase [branch]:"},{"location":"Basics/git_undoingthings/#2-git-reset-hard-commit","text":"Clear the staging area and rewrite the working tree from the specified commit. git reset --hard abc123 Reset the current branch to the specified commit ( abc123 in this example), discarding any changes and resetting both the working directory and the staging area to match the state of the specified commit.","title":"2. git reset --hard [commit]:"},{"location":"Basics/git_undoingthings/#3-git-commit-amend","text":"Modify the last commit by combining staged changes with the previous commit. git commit --amend Edit the commit message or add more changes to the previous commit before finalizing it.","title":"3. git commit --amend:"},{"location":"Basics/git_undoingthings/#4-git-rebase-i-commit","text":"Interactively rebase commits starting from the specified commit. git rebase -i abc123 Reword, squash, edit, or reorder commits interactively to clean up the commit history.","title":"4. git rebase -i [commit]:"},{"location":"Basics/git_undoingthings/#5-git-filter-branch","text":"Rewrite branches to remove unwanted data, such as sensitive information or large files. git filter-branch --tree-filter 'rm -f passwords.txt' HEAD Filter branch content by applying a specified command to each commit, useful for history rewriting tasks.","title":"5. git filter-branch:"},{"location":"Basics/git_undoingthings/#6-git-cherry-pick-commit","text":"Apply the changes introduced by the specified commit to the current branch. git cherry-pick abc123 Selectively pick specific commits from one branch and apply them to another branch. Rewriting branches, updating commits, and clearing history in Git are powerful capabilities that should be used with caution, especially in collaborative environments. These commands enable you to maintain a clean and organized history, improving project maintainability and readability. However, always ensure that you understand the consequences of these actions before applying them, as they can alter the commit history irreversibly.","title":"6. git cherry-pick [commit]:"},{"location":"Basics/git_undoingthings/#7-git-checkout-f","text":"When switching branches, proceed even if the index or the working tree differs from HEAD, and even if there are untracked files in the way. This command is used to forcefully switch branches, discarding any local changes or untracked files that may prevent the branch switch. git checkout -f feature-branch - Note: Be cautious when using this command, as it will discard any local changes without warning.","title":"7. git checkout -f:"},{"location":"Basics/git_undoingthings/#8-git-clean-ffd","text":"Erase all untracked files and directories in the working directory. This command is used to clean up the working directory by removing any untracked files or directories that are not under version control. git clean -ffd - Note: The -f option is used to force the clean operation, and the -d option is used to include untracked directories. These commands are useful for cleaning up a Git repository before starting fresh or resolving conflicts that prevent branch switching. However, they should be used with caution, as they can permanently delete local changes and untracked files. It's essential to understand the implications of using these commands and ensure that any necessary changes or files are backed up before proceeding.","title":"8. git clean -ffd:"}]}
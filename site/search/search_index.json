{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Git Refresher Whether you're a seasoned developer or a code maintainer, this repository is designed to help you enhance your Git skills and streamline your version control workflows. Basic Topics Advanced Topics Github Topics Configuration Aliases SSH Keys Starting a Project Tagging Staging Changes Branches Undoing Changes Patching Remotes Ignoring Files Inspect & Compare Temporary Commits This material is a work in progress, so your feedback is welcome. The best way to provide that feedback is to click here and create an issue in this GitHub repository .","title":"Home"},{"location":"#welcome-to-git-refresher","text":"Whether you're a seasoned developer or a code maintainer, this repository is designed to help you enhance your Git skills and streamline your version control workflows. Basic Topics Advanced Topics Github Topics Configuration Aliases SSH Keys Starting a Project Tagging Staging Changes Branches Undoing Changes Patching Remotes Ignoring Files Inspect & Compare Temporary Commits This material is a work in progress, so your feedback is welcome. The best way to provide that feedback is to click here and create an issue in this GitHub repository .","title":"Welcome to Git Refresher"},{"location":"git_refresh/","text":"Git is a distributed version control system (VCS) designed to track changes in source code during software development. It was created by Linus Torvalds in 2005 and has become the de facto standard for version control in the software development industry. Key Concepts Version Control: Git allows developers to track changes made to their codebase over time. This includes recording who made the changes, what changes were made, and when the changes occurred. Distributed System: Git is decentralized, meaning that each developer has a complete copy of the entire project history on their local machine. This allows for flexibility in development and collaboration. Branching: Git excels at branching, enabling developers to work on multiple independent features or bug fixes simultaneously. Branches can be created, merged, and deleted without affecting the main codebase until changes are ready to be integrated. Collaboration: Git facilitates collaboration among developers. Multiple contributors can work on the same project simultaneously without interfering with each other's work. Changes are merged together seamlessly. History and Accountability Git maintains a detailed history of all changes made to a project. This history provides accountability by attributing each change to a specific user, making it easy to trace the evolution of the codebase. Importance of Git Collaboration: Git enables efficient collaboration among developers working on the same project. It allows multiple team members to contribute simultaneously, track changes, and merge their work seamlessly. Versioning: Git provides a reliable versioning system, allowing developers to track changes over time. This is crucial for understanding the evolution of a project, reverting to previous states, and identifying when and by whom specific changes were made. Branching and Experimentation Git's branching model allows developers to experiment with new features or bug fixes in isolation. This promotes a more organized and controlled development process, with the ability to merge changes into the main codebase when they are ready. Fault Tolerance: The distributed nature of Git ensures that each developer has a complete copy of the repository. This redundancy minimizes the risk of data loss and provides a safety net in case of system failures. Open Source Ecosystem: Git is the foundation for many open-source projects and contributes to the collaborative nature of the software development community. Platforms like GitHub, GitLab, and Bitbucket leverage Git to host and manage repositories, fostering a rich ecosystem of shared code. In summary, Git is important because it enhances collaboration, provides effective version control, and empowers developers to work efficiently and reliably on software projects of any scale.","title":"Git"},{"location":"git_refresh/#key-concepts","text":"Version Control: Git allows developers to track changes made to their codebase over time. This includes recording who made the changes, what changes were made, and when the changes occurred. Distributed System: Git is decentralized, meaning that each developer has a complete copy of the entire project history on their local machine. This allows for flexibility in development and collaboration. Branching: Git excels at branching, enabling developers to work on multiple independent features or bug fixes simultaneously. Branches can be created, merged, and deleted without affecting the main codebase until changes are ready to be integrated. Collaboration: Git facilitates collaboration among developers. Multiple contributors can work on the same project simultaneously without interfering with each other's work. Changes are merged together seamlessly. History and Accountability Git maintains a detailed history of all changes made to a project. This history provides accountability by attributing each change to a specific user, making it easy to trace the evolution of the codebase.","title":"Key Concepts"},{"location":"git_refresh/#importance-of-git","text":"Collaboration: Git enables efficient collaboration among developers working on the same project. It allows multiple team members to contribute simultaneously, track changes, and merge their work seamlessly. Versioning: Git provides a reliable versioning system, allowing developers to track changes over time. This is crucial for understanding the evolution of a project, reverting to previous states, and identifying when and by whom specific changes were made. Branching and Experimentation Git's branching model allows developers to experiment with new features or bug fixes in isolation. This promotes a more organized and controlled development process, with the ability to merge changes into the main codebase when they are ready. Fault Tolerance: The distributed nature of Git ensures that each developer has a complete copy of the repository. This redundancy minimizes the risk of data loss and provides a safety net in case of system failures. Open Source Ecosystem: Git is the foundation for many open-source projects and contributes to the collaborative nature of the software development community. Platforms like GitHub, GitLab, and Bitbucket leverage Git to host and manage repositories, fostering a rich ecosystem of shared code. In summary, Git is important because it enhances collaboration, provides effective version control, and empowers developers to work efficiently and reliably on software projects of any scale.","title":"Importance of Git"},{"location":"Advanced/git_alias/","text":"In Git In Git, aliases are shortcuts or custom commands that you can create to simplify and streamline your workflow. They can be particularly useful to reduce typing and remember complex commands. Here's a step-by-step guide on how to add useful aliases, along with some suggestions for commonly used and helpful aliases: 1. Adding Git Aliases Open your terminal and run the following command to open the global Git configuration file in your default text editor: git config --global --edit This command opens the global configuration file in your preferred text editor. If you haven't configured a text editor, Git will prompt you to choose one. 2. Adding Aliases to the Configuration File Inside the configuration file, add the following section to set up aliases: [ alias ] alias_name = actual_git_command Replace alias_name with the desired alias and actual_git_command with the Git command or series of commands you want to associate with the alias. 3. Example Aliases Here are some commonly used and helpful aliases: [ alias ] # Show a compact and colorful log lg = log --graph --pretty = format: '%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --date = relative # Show the current branch current-branch = symbolic-ref --short HEAD # Show a concise status st = status -s # Commit all changes with a message ca = !git add -A && git commit -m # Show the diff of the last commit last-commit-diff = diff HEAD^ HEAD 4. Explanation of Some Aliases lg : Displays a compact and colorful log. current-branch : Shows the current branch. st : Provides a concise status of the repository. ca : Commits all changes with a message. Usage: git ca \"Commit message\" . last-commit-diff : Shows the diff of the last commit. 5. Save and Exit Save the configuration file and exit your text editor. 6. Using Aliases After adding aliases, you can use them in the terminal like regular Git commands. For example: git lg This will execute the log alias and display a compact and colorful log. 7. Additional Tips Choose aliases that align with your workflow and make common tasks more efficient. Keep aliases short and memorable. Test your aliases in a safe environment before using them extensively. Creating and using Git aliases can significantly improve your productivity and make Git commands more convenient. Feel free to customize these aliases to suit your preferences and workflow. In Bash Setting up aliases in Bash involves editing your Bash profile file. The Bash profile file is a script that runs whenever you start a new terminal session. Here's a step-by-step guide on how to set up aliases in Bash: 1. Open Your Bash Profile Open your Bash profile file in a text editor. The Bash profile is usually one of the following files, depending on your operating system: For Linux/macOS: ~/.bashrc or ~/.bash_profile For Windows using Git Bash: ~/.bashrc If the file doesn't exist, you can create it. # For Linux/macOS nano ~/.bashrc # or use your preferred text editor # For Windows using Git Bash nano ~/.bashrc # or use your preferred text editor or using VScode # For Linux/macOS code ~/.bashrc # or use your preferred text editor # For Windows using Git Bash code ~/.bashrc # or use your preferred text editor 2. Add Your Aliases In your Bash profile, add lines for each alias you want to create. The syntax is as follows: alias alias_name = 'actual_command' Replace alias_name with the desired alias and actual_command with the actual command or series of commands you want to associate with the alias. 3. Example Aliases Here are some example aliases: # Git aliases alias gst = 'git status' alias gl = 'git log' alias gll = 'git log --oneline' alias glog = 'git log --oneline --decorate --graph' alias gamend = 'git commit --amend' alias gr = 'git remote -v' alias gb = 'git branch' alias gba = 'git branch -a' alias gd = 'git diff' alias gds = 'git diff --staged' alias gsub = 'git submodule sync; git submodule update --init --recursive' alias gsreset = 'git submodule foreach --recursive git reset --hard' # Navigation aliases alias cdproj = 'cd ~/projects' alias cddownloads = 'cd ~/Downloads' alias cddesktop = 'cd ~/Desktop' alias .. = 'cd ..' alias ... = 'cd ../..' alias .... = 'cd ../../..' # Shortcuts for common commands alias ll = 'ls -alF' alias la = 'ls -A' alias cp = 'cp -i' alias mv = 'mv -i' alias rm = 'rm -i' # \ud83e\udd18 alias yolo = 'git push --force' # useful for daily stand-up # See https://dev.to/maxpou/git-cheat-sheet-advanced-3a17 git-standup () { AUTHOR = ${ AUTHOR := \"`git config user.name`\" } since = yesterday if [[ $( date +%u ) == 1 ]] ; then since = \"2 days ago\" fi git log --color --graph --pretty = format: '%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --since \" $since \" --author = \" $AUTHOR \" } 4. Save and Exit Save your changes and exit the text editor. For Nano, press Ctrl + X , then Y to confirm saving, and Enter to exit. For other editors, follow their respective save and exit commands. 5. Reload Your Bash Profile To apply the changes without restarting your terminal, either close and reopen the terminal or use the source command: source ~/.bashrc This command reloads the Bash profile, making your new aliases immediately available. 6. Verify Your Aliases To verify that your aliases are set up correctly, you can use the alias command: alias This will display a list of all defined aliases in your current session. Now you can use your aliases in the terminal for quick and convenient access to frequently used commands. Customize the aliases to match your workflow and make your command-line experience more efficient. In Powersell In PowerShell, you can add aliases using your PowerShell profile script. The profile script is a PowerShell script that is automatically executed when you start a PowerShell session. Here's a step-by-step guide on how to add aliases in PowerShell: 1. Open Your PowerShell Profile Open your PowerShell profile script in a text editor. If you don't have a profile, you can create one. The profile script is usually located at one of the following paths: Current User, Current Host (for all users): $PROFILE.AllUsersCurrentHost Current User, Current Host (for the current user): $PROFILE.CurrentUserCurrentHost All Users, All Hosts (for all users): $PROFILE.AllUsersAllHosts Current User, All Hosts (for the current user): $PROFILE.CurrentUserAllHosts To open your profile script, you can use the following command: notepad $PROFILE This command opens the profile script in Notepad. If the file doesn't exist, PowerShell will prompt you to create it. or use VSCode to open your profile script: code $PROFILE 2. Add Your Aliases In your PowerShell profile, add lines for each alias you want to create. The syntax is as follows: function alias_name { actual_command } Replace alias_name with the desired alias and actual_command with the actual command or series of commands you want to associate with the alias. 3. Example Aliases Here are some example aliases: # Git aliases function gs { git status } function ga { git add } function gc { git commit } function gp { git push } function gl { git log - -oneline } # Navigation aliases function cdproj { Set-Location C :\\ Projects } function cddownloads { Set-Location C :\\ Users \\ YourUsername \\ Downloads } function cddesktop { Set-Location C :\\ Users \\ YourUsername \\ Desktop } # Shortcuts for common commands function ll { Get-ChildItem -Force } 4. Save and Exit Save your changes and exit the text editor. 5. Reload Your PowerShell Profile To apply the changes without restarting PowerShell, you can use the Import-Module cmdlet: Import-Module $PROFILE 6. Verify Your Aliases To verify that your aliases are set up correctly, you can use the Get-Alias cmdlet: Get-Alias This will display a list of all defined aliases in your current PowerShell session. Now you can use your aliases in the PowerShell console for quick and convenient access to frequently used commands. Customize the aliases to match your workflow and make your PowerShell experience more efficient.","title":"Aliases"},{"location":"Advanced/git_alias/#in-git","text":"In Git, aliases are shortcuts or custom commands that you can create to simplify and streamline your workflow. They can be particularly useful to reduce typing and remember complex commands. Here's a step-by-step guide on how to add useful aliases, along with some suggestions for commonly used and helpful aliases:","title":"In Git"},{"location":"Advanced/git_alias/#1-adding-git-aliases","text":"Open your terminal and run the following command to open the global Git configuration file in your default text editor: git config --global --edit This command opens the global configuration file in your preferred text editor. If you haven't configured a text editor, Git will prompt you to choose one.","title":"1. Adding Git Aliases"},{"location":"Advanced/git_alias/#2-adding-aliases-to-the-configuration-file","text":"Inside the configuration file, add the following section to set up aliases: [ alias ] alias_name = actual_git_command Replace alias_name with the desired alias and actual_git_command with the Git command or series of commands you want to associate with the alias.","title":"2. Adding Aliases to the Configuration File"},{"location":"Advanced/git_alias/#3-example-aliases","text":"Here are some commonly used and helpful aliases: [ alias ] # Show a compact and colorful log lg = log --graph --pretty = format: '%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --date = relative # Show the current branch current-branch = symbolic-ref --short HEAD # Show a concise status st = status -s # Commit all changes with a message ca = !git add -A && git commit -m # Show the diff of the last commit last-commit-diff = diff HEAD^ HEAD","title":"3. Example Aliases"},{"location":"Advanced/git_alias/#4-explanation-of-some-aliases","text":"lg : Displays a compact and colorful log. current-branch : Shows the current branch. st : Provides a concise status of the repository. ca : Commits all changes with a message. Usage: git ca \"Commit message\" . last-commit-diff : Shows the diff of the last commit.","title":"4. Explanation of Some Aliases"},{"location":"Advanced/git_alias/#5-save-and-exit","text":"Save the configuration file and exit your text editor.","title":"5. Save and Exit"},{"location":"Advanced/git_alias/#6-using-aliases","text":"After adding aliases, you can use them in the terminal like regular Git commands. For example: git lg This will execute the log alias and display a compact and colorful log.","title":"6. Using Aliases"},{"location":"Advanced/git_alias/#7-additional-tips","text":"Choose aliases that align with your workflow and make common tasks more efficient. Keep aliases short and memorable. Test your aliases in a safe environment before using them extensively. Creating and using Git aliases can significantly improve your productivity and make Git commands more convenient. Feel free to customize these aliases to suit your preferences and workflow.","title":"7. Additional Tips"},{"location":"Advanced/git_alias/#in-bash","text":"Setting up aliases in Bash involves editing your Bash profile file. The Bash profile file is a script that runs whenever you start a new terminal session. Here's a step-by-step guide on how to set up aliases in Bash:","title":"In Bash"},{"location":"Advanced/git_alias/#1-open-your-bash-profile","text":"Open your Bash profile file in a text editor. The Bash profile is usually one of the following files, depending on your operating system: For Linux/macOS: ~/.bashrc or ~/.bash_profile For Windows using Git Bash: ~/.bashrc If the file doesn't exist, you can create it. # For Linux/macOS nano ~/.bashrc # or use your preferred text editor # For Windows using Git Bash nano ~/.bashrc # or use your preferred text editor or using VScode # For Linux/macOS code ~/.bashrc # or use your preferred text editor # For Windows using Git Bash code ~/.bashrc # or use your preferred text editor","title":"1. Open Your Bash Profile"},{"location":"Advanced/git_alias/#2-add-your-aliases","text":"In your Bash profile, add lines for each alias you want to create. The syntax is as follows: alias alias_name = 'actual_command' Replace alias_name with the desired alias and actual_command with the actual command or series of commands you want to associate with the alias.","title":"2. Add Your Aliases"},{"location":"Advanced/git_alias/#3-example-aliases_1","text":"Here are some example aliases: # Git aliases alias gst = 'git status' alias gl = 'git log' alias gll = 'git log --oneline' alias glog = 'git log --oneline --decorate --graph' alias gamend = 'git commit --amend' alias gr = 'git remote -v' alias gb = 'git branch' alias gba = 'git branch -a' alias gd = 'git diff' alias gds = 'git diff --staged' alias gsub = 'git submodule sync; git submodule update --init --recursive' alias gsreset = 'git submodule foreach --recursive git reset --hard' # Navigation aliases alias cdproj = 'cd ~/projects' alias cddownloads = 'cd ~/Downloads' alias cddesktop = 'cd ~/Desktop' alias .. = 'cd ..' alias ... = 'cd ../..' alias .... = 'cd ../../..' # Shortcuts for common commands alias ll = 'ls -alF' alias la = 'ls -A' alias cp = 'cp -i' alias mv = 'mv -i' alias rm = 'rm -i' # \ud83e\udd18 alias yolo = 'git push --force' # useful for daily stand-up # See https://dev.to/maxpou/git-cheat-sheet-advanced-3a17 git-standup () { AUTHOR = ${ AUTHOR := \"`git config user.name`\" } since = yesterday if [[ $( date +%u ) == 1 ]] ; then since = \"2 days ago\" fi git log --color --graph --pretty = format: '%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --since \" $since \" --author = \" $AUTHOR \" }","title":"3. Example Aliases"},{"location":"Advanced/git_alias/#4-save-and-exit","text":"Save your changes and exit the text editor. For Nano, press Ctrl + X , then Y to confirm saving, and Enter to exit. For other editors, follow their respective save and exit commands.","title":"4. Save and Exit"},{"location":"Advanced/git_alias/#5-reload-your-bash-profile","text":"To apply the changes without restarting your terminal, either close and reopen the terminal or use the source command: source ~/.bashrc This command reloads the Bash profile, making your new aliases immediately available.","title":"5. Reload Your Bash Profile"},{"location":"Advanced/git_alias/#6-verify-your-aliases","text":"To verify that your aliases are set up correctly, you can use the alias command: alias This will display a list of all defined aliases in your current session. Now you can use your aliases in the terminal for quick and convenient access to frequently used commands. Customize the aliases to match your workflow and make your command-line experience more efficient.","title":"6. Verify Your Aliases"},{"location":"Advanced/git_alias/#in-powersell","text":"In PowerShell, you can add aliases using your PowerShell profile script. The profile script is a PowerShell script that is automatically executed when you start a PowerShell session. Here's a step-by-step guide on how to add aliases in PowerShell:","title":"In Powersell"},{"location":"Advanced/git_alias/#1-open-your-powershell-profile","text":"Open your PowerShell profile script in a text editor. If you don't have a profile, you can create one. The profile script is usually located at one of the following paths: Current User, Current Host (for all users): $PROFILE.AllUsersCurrentHost Current User, Current Host (for the current user): $PROFILE.CurrentUserCurrentHost All Users, All Hosts (for all users): $PROFILE.AllUsersAllHosts Current User, All Hosts (for the current user): $PROFILE.CurrentUserAllHosts To open your profile script, you can use the following command: notepad $PROFILE This command opens the profile script in Notepad. If the file doesn't exist, PowerShell will prompt you to create it. or use VSCode to open your profile script: code $PROFILE","title":"1. Open Your PowerShell Profile"},{"location":"Advanced/git_alias/#2-add-your-aliases_1","text":"In your PowerShell profile, add lines for each alias you want to create. The syntax is as follows: function alias_name { actual_command } Replace alias_name with the desired alias and actual_command with the actual command or series of commands you want to associate with the alias.","title":"2. Add Your Aliases"},{"location":"Advanced/git_alias/#3-example-aliases_2","text":"Here are some example aliases: # Git aliases function gs { git status } function ga { git add } function gc { git commit } function gp { git push } function gl { git log - -oneline } # Navigation aliases function cdproj { Set-Location C :\\ Projects } function cddownloads { Set-Location C :\\ Users \\ YourUsername \\ Downloads } function cddesktop { Set-Location C :\\ Users \\ YourUsername \\ Desktop } # Shortcuts for common commands function ll { Get-ChildItem -Force }","title":"3. Example Aliases"},{"location":"Advanced/git_alias/#4-save-and-exit_1","text":"Save your changes and exit the text editor.","title":"4. Save and Exit"},{"location":"Advanced/git_alias/#5-reload-your-powershell-profile","text":"To apply the changes without restarting PowerShell, you can use the Import-Module cmdlet: Import-Module $PROFILE","title":"5. Reload Your PowerShell Profile"},{"location":"Advanced/git_alias/#6-verify-your-aliases_1","text":"To verify that your aliases are set up correctly, you can use the Get-Alias cmdlet: Get-Alias This will display a list of all defined aliases in your current PowerShell session. Now you can use your aliases in the PowerShell console for quick and convenient access to frequently used commands. Customize the aliases to match your workflow and make your PowerShell experience more efficient.","title":"6. Verify Your Aliases"},{"location":"Advanced/git_branch/","text":"Branching in Git is a powerful feature that allows developers to diverge from the main line of development (usually referred to as the master branch) and work on separate, isolated lines of development. Each branch represents an independent line of development, enabling multiple features, fixes, or experiments to be worked on simultaneously without interfering with each other. Branching can be a crucial part of software development, as it allows teams to work collaboratively on different features or fixes simultaneously while maintaining a clear and organized codebase. Isolating work in branches, changing context, and integrating changes into the main line of development can help streamline the development process and improve collaboration. Main Branches Master Branch: By convention, the master branch is often used to represent the main line of development. It typically contains stable, production-ready code. Main Branch (Post-Git 2.28): Some projects have adopted renaming the default branch from master to main . The main branch serves the same purpose as the master branch, but the naming convention aims to promote more inclusive language. Creating Branches Creating a New Branch: To create a new branch, use the git branch <branch-name> command. Optionally, you can switch to the new branch immediately with git checkout -b <branch-name> or git switch -c <branch-name> . git branch feature-branch Switching Branches: To switch between branches, use the git checkout <branch-name> command or git switch <branch-name> . 1. git checkout git checkout feature-branch 2. git switch Introduced in Git version 2.23, git switch is specifically designed for branch switching. It offers a more intuitive and safer way to switch branches compared to git checkout . git switch <branch-name> Both git switch and git checkout are used for switching branches in Git. git switch is specifically designed for branch switching and offers a safer and more intuitive experience compared to git checkout . While git checkout remains a versatile command for various Git operations, git switch is recommended for branch switching to promote consistency and safety in your workflow. git checkout is a multi-purpose tool, capable of switching branches, discarding changes, and even creating new branches. Conversely, git switch is more specialized, focusing solely on switching and creating branches. Viewing Branches Listing Branches: To list all branches in the repository, use the git branch command. git branch An asterisk ( * ) in the output indicates that the branch you are currently on is the currently active branch. The git branch -a command is used to list all branches in a Git repository, including both local branches and remote branches. git branch -a git branch : This is the Git command used to manage branches in a repository. -a (or --all ): This option tells Git to list both local branches and remote branches. When you run git branch -a , Git will list all branches in the repository, including: Local Branches: Branches that exist only in your local repository. Remote Branches: Branches that exist on the remote repository (e.g., on GitHub, GitLab). Remote Tracking Branches: Local representations of remote branches, used for tracking changes from the remote repository. The output typically looks like this: * main feature-branch remotes/origin/HEAD -> origin/main remotes/origin/main remotes/origin/feature-branch The branches listed without the remotes/ prefix are local branches. The branches listed with the remotes/ prefix are remote branches. origin is the default name for the remote repository, but you may see other names if you have multiple remotes configured. Use Cases Checking the status of local and remote branches. Identifying available branches for merging, rebasing, or switching. Tracking changes from remote branches and syncing local branches accordingly. By using git branch -a , you can get a comprehensive overview of all branches in your Git repository, allowing you to manage and navigate through branches effectively. Merging Branches Merge: To merge changes from one branch into another, use the git merge <branch-name> command. git merge feature-branch Merge the specified branch\u2019s history into the current one. Deleting Branches Delete: To delete a branch, use the git branch -d <branch-name> command. git branch -d feature-branch Branching Strategies Git encourages workflows that branch and merge often, even multiple times in a day. Understanding and mastering this feature gives you a powerful and unique tool and can entirely change the way that you develop. The way Git branches is incredibly lightweight, making branching operations nearly instantaneous, and switching back and forth between branches generally just as fast. Feature Branching: Create a separate branch for each new feature or task. This isolates changes related to specific features, making them easier to manage and review. Release Branching: Create branches for each release to stabilize the codebase before deployment. Hotfix Branching: Create branches to fix critical issues in production code quickly. Remote Branches Pushing a Branch: To push a local branch to a remote repository, use the git push <remote-name> <branch-name> command. git push origin feature-branch Tracking Remote Branches: After pushing a branch to the remote repository, it can be tracked. This means Git remembers the relationship between the local branch and its corresponding remote branch. git checkout -b feature-branch origin/feature-branch The git branch --set-upstream-to command is used to set up the tracking relationship between a local branch and a remote branch. This command tells Git which remote branch the local branch should track, allowing you to push and pull changes to and from the correct remote branch without specifying it each time. git branch --set-upstream-to = <remote>/<branch> <remote> : The name of the remote repository. <branch> : The name of the remote branch. git branch --set-upstream-to = origin/main This command sets the tracking relationship for the current branch to the specified remote branch ( main in this example) in the origin remote repository. After running this command, Git knows that when you push or pull changes from the current branch, it should interact with the main branch in the origin remote repository. Syncing Changes After setting up tracking, you can simply use git push and git pull without specifying the remote branch, as Git already knows where to push and pull changes from. This command can also be used in combination with git push -u or git push --set-upstream to set up tracking and push changes to the remote branch in one step. Branching Best Practices Use Descriptive Names: Choose meaningful names for branches to indicate their purpose or associated feature. Keep Branches Short-Lived: Merge branches into the main line of development once their purpose is served to avoid branch clutter. Regularly Update Branches: Keep branches up-to-date with changes in the main line of development by frequently merging or rebasing. Review Branches: Encourage code review and collaboration by reviewing changes made in feature branches before merging them.","title":"Branching"},{"location":"Advanced/git_branch/#main-branches","text":"Master Branch: By convention, the master branch is often used to represent the main line of development. It typically contains stable, production-ready code. Main Branch (Post-Git 2.28): Some projects have adopted renaming the default branch from master to main . The main branch serves the same purpose as the master branch, but the naming convention aims to promote more inclusive language.","title":"Main Branches"},{"location":"Advanced/git_branch/#creating-branches","text":"Creating a New Branch: To create a new branch, use the git branch <branch-name> command. Optionally, you can switch to the new branch immediately with git checkout -b <branch-name> or git switch -c <branch-name> . git branch feature-branch Switching Branches: To switch between branches, use the git checkout <branch-name> command or git switch <branch-name> .","title":"Creating Branches"},{"location":"Advanced/git_branch/#1-git-checkout","text":"git checkout feature-branch","title":"1. git checkout"},{"location":"Advanced/git_branch/#2-git-switch","text":"Introduced in Git version 2.23, git switch is specifically designed for branch switching. It offers a more intuitive and safer way to switch branches compared to git checkout . git switch <branch-name> Both git switch and git checkout are used for switching branches in Git. git switch is specifically designed for branch switching and offers a safer and more intuitive experience compared to git checkout . While git checkout remains a versatile command for various Git operations, git switch is recommended for branch switching to promote consistency and safety in your workflow. git checkout is a multi-purpose tool, capable of switching branches, discarding changes, and even creating new branches. Conversely, git switch is more specialized, focusing solely on switching and creating branches.","title":"2. git switch"},{"location":"Advanced/git_branch/#viewing-branches","text":"Listing Branches: To list all branches in the repository, use the git branch command. git branch An asterisk ( * ) in the output indicates that the branch you are currently on is the currently active branch. The git branch -a command is used to list all branches in a Git repository, including both local branches and remote branches. git branch -a git branch : This is the Git command used to manage branches in a repository. -a (or --all ): This option tells Git to list both local branches and remote branches. When you run git branch -a , Git will list all branches in the repository, including: Local Branches: Branches that exist only in your local repository. Remote Branches: Branches that exist on the remote repository (e.g., on GitHub, GitLab). Remote Tracking Branches: Local representations of remote branches, used for tracking changes from the remote repository. The output typically looks like this: * main feature-branch remotes/origin/HEAD -> origin/main remotes/origin/main remotes/origin/feature-branch The branches listed without the remotes/ prefix are local branches. The branches listed with the remotes/ prefix are remote branches. origin is the default name for the remote repository, but you may see other names if you have multiple remotes configured.","title":"Viewing Branches"},{"location":"Advanced/git_branch/#use-cases","text":"Checking the status of local and remote branches. Identifying available branches for merging, rebasing, or switching. Tracking changes from remote branches and syncing local branches accordingly. By using git branch -a , you can get a comprehensive overview of all branches in your Git repository, allowing you to manage and navigate through branches effectively.","title":"Use Cases"},{"location":"Advanced/git_branch/#merging-branches","text":"Merge: To merge changes from one branch into another, use the git merge <branch-name> command. git merge feature-branch Merge the specified branch\u2019s history into the current one.","title":"Merging Branches"},{"location":"Advanced/git_branch/#deleting-branches","text":"Delete: To delete a branch, use the git branch -d <branch-name> command. git branch -d feature-branch","title":"Deleting Branches"},{"location":"Advanced/git_branch/#branching-strategies","text":"Git encourages workflows that branch and merge often, even multiple times in a day. Understanding and mastering this feature gives you a powerful and unique tool and can entirely change the way that you develop. The way Git branches is incredibly lightweight, making branching operations nearly instantaneous, and switching back and forth between branches generally just as fast. Feature Branching: Create a separate branch for each new feature or task. This isolates changes related to specific features, making them easier to manage and review. Release Branching: Create branches for each release to stabilize the codebase before deployment. Hotfix Branching: Create branches to fix critical issues in production code quickly.","title":"Branching Strategies"},{"location":"Advanced/git_branch/#remote-branches","text":"Pushing a Branch: To push a local branch to a remote repository, use the git push <remote-name> <branch-name> command. git push origin feature-branch Tracking Remote Branches: After pushing a branch to the remote repository, it can be tracked. This means Git remembers the relationship between the local branch and its corresponding remote branch. git checkout -b feature-branch origin/feature-branch The git branch --set-upstream-to command is used to set up the tracking relationship between a local branch and a remote branch. This command tells Git which remote branch the local branch should track, allowing you to push and pull changes to and from the correct remote branch without specifying it each time. git branch --set-upstream-to = <remote>/<branch> <remote> : The name of the remote repository. <branch> : The name of the remote branch. git branch --set-upstream-to = origin/main This command sets the tracking relationship for the current branch to the specified remote branch ( main in this example) in the origin remote repository. After running this command, Git knows that when you push or pull changes from the current branch, it should interact with the main branch in the origin remote repository. Syncing Changes After setting up tracking, you can simply use git push and git pull without specifying the remote branch, as Git already knows where to push and pull changes from. This command can also be used in combination with git push -u or git push --set-upstream to set up tracking and push changes to the remote branch in one step.","title":"Remote Branches"},{"location":"Advanced/git_branch/#branching-best-practices","text":"Use Descriptive Names: Choose meaningful names for branches to indicate their purpose or associated feature. Keep Branches Short-Lived: Merge branches into the main line of development once their purpose is served to avoid branch clutter. Regularly Update Branches: Keep branches up-to-date with changes in the main line of development by frequently merging or rebasing. Review Branches: Encourage code review and collaboration by reviewing changes made in feature branches before merging them.","title":"Branching Best Practices"},{"location":"Advanced/git_checkout/","text":"git checkout is a fundamental Git command used for switching branches, restoring files from previous commits, creating new branches, and more. It has been a core part of Git since its inception and remains widely used. However, Git has introduced newer commands like git switch and git restore that offer similar functionality and improved features. Features of git checkout Switching Branches git checkout <branch> Allows you to switch between branches in your repository. Creating New Branches git checkout -b <new-branch> Creates a new branch and switches to it in one step. Restoring Files git checkout <commit> -- <file> Restores a specific file from a previous commit to the working directory. Discarding Local Changes git checkout -- <file> Discards local changes made to a specific file and restores it to the state from the last commit. Checking Out Files from Other Branches git checkout <branch> -- <file> Checks out a specific file from another branch into the current branch's working directory. Comparison with Newer Commands Previous command New command Explanation git checkout <branch> git switch <branch> Both commands are used to switch branches. The new command git switch offers a clearer syntax for this task. git checkout N/A (use git status ) The git checkout command without arguments is often used to check the status of the repository. git checkout -b <new_branch> [<start_point>] git switch -c <new-branch> [<start-point>] Both commands are used to create and switch to a new branch. The new command git switch -c offers a clearer syntax for branch creation. git checkout -B <new_branch> [<start_point>] git switch -C <new-branch> [<start-point>] Both commands are used to forcibly create and switch to a new branch. The new command git switch -C offers a clearer syntax for this task. git checkout --orphan <new_branch> git switch --orphan <new-branch> Both commands are used to create a new orphan branch. git checkout --orphan <new_branch> <start_point> N/A (use git switch <start-point> then git switch --orphan <new-branch> ) There is no direct equivalent for this operation. You can achieve similar behavior by first switching to the start point and then creating the orphan branch. git checkout [--detach] <commit> git switch --detach <commit> Both commands are used to checkout a specific commit in a detached HEAD state. git checkout --detach [<branch>] git switch --detach [<branch>] Both commands are used to detach the HEAD from the current or specified branch. git checkout [--] <pathspec>\u2026 git restore [--] <pathspec>\u2026 Both commands are used to restore files in the working directory. The new command git restore provides a clearer syntax for this operation. git checkout --pathspec-from-file=<file> git restore --pathspec-from-file=<file> Both commands are used to restore files specified in a file. The new command git restore provides a clearer syntax for this operation. git checkout <tree-ish> [--] <pathspec>\u2026 git restore -s <tree> [--] <pathspec>\u2026 Both commands are used to restore files from a specific tree. The new command git restore provides a clearer syntax for this operation. git checkout <tree-ish> --pathspec-from-file=<file> git restore -s <tree> --pathspec-from-file=<file> Both commands are used to restore files specified in a file from a specific tree. The new command git restore provides a clearer syntax for this operation. git checkout -p [<tree-ish>] [--] [<pathspec>\u2026] git restore -p [-s <tree>] [--] [<pathspec>\u2026] Both commands are used to interactively restore changes from a specific tree. The new command git restore provides a clearer syntax for this operation. As shown by this comparison, some prior usages can be converted to the new commands by simply replacing the old command name (checkout) with the new one (switch, restore), whereas others require additional adjustment. Notable changes include: The -b/-B options for creating a new branch before switching are renamed to -c/-C. They also have long option variants (--create/--force-create), unlike before. --detach (or -d) is now always required when switching to a detached head, where it was previously optional for commits but required for branches. The source tree for restoring is now given by the -s (or --source) option, rather than being an inline argument. Switching using --force (or -f) now fails if there are unmerged entries, rather than ignoring them. --force has also been renamed to --discard-changes, with --force being kept as an alias. git switch Provides a clearer and more intuitive syntax specifically for switching branches. git restore Offers dedicated options for restoring files and discarding changes, providing a more explicit and versatile interface for these operations. Use Cases Simple Branch Switching For basic branch switching operations, git checkout remains a straightforward and commonly used command. File-Level Operations When performing file-level operations like restoring files from commits or discarding local changes, git checkout provides a concise syntax. Advanced Branch Management For more advanced branch management tasks or when using newer Git features, git switch and git restore may offer advantages in terms of clarity and functionality. git checkout is a versatile Git command with various features for branch switching, file restoration, and more. While newer commands like git switch and git restore offer some improvements and specialized functionality, git checkout remains a fundamental and widely used command in Git workflows. Depending on the specific task at hand and personal preference, you may choose to use git checkout or explore the capabilities of newer Git commands for branch and file management.","title":"Checkout"},{"location":"Advanced/git_checkout/#features-of-git-checkout","text":"Switching Branches git checkout <branch> Allows you to switch between branches in your repository. Creating New Branches git checkout -b <new-branch> Creates a new branch and switches to it in one step. Restoring Files git checkout <commit> -- <file> Restores a specific file from a previous commit to the working directory. Discarding Local Changes git checkout -- <file> Discards local changes made to a specific file and restores it to the state from the last commit. Checking Out Files from Other Branches git checkout <branch> -- <file> Checks out a specific file from another branch into the current branch's working directory.","title":"Features of git checkout"},{"location":"Advanced/git_checkout/#comparison-with-newer-commands","text":"Previous command New command Explanation git checkout <branch> git switch <branch> Both commands are used to switch branches. The new command git switch offers a clearer syntax for this task. git checkout N/A (use git status ) The git checkout command without arguments is often used to check the status of the repository. git checkout -b <new_branch> [<start_point>] git switch -c <new-branch> [<start-point>] Both commands are used to create and switch to a new branch. The new command git switch -c offers a clearer syntax for branch creation. git checkout -B <new_branch> [<start_point>] git switch -C <new-branch> [<start-point>] Both commands are used to forcibly create and switch to a new branch. The new command git switch -C offers a clearer syntax for this task. git checkout --orphan <new_branch> git switch --orphan <new-branch> Both commands are used to create a new orphan branch. git checkout --orphan <new_branch> <start_point> N/A (use git switch <start-point> then git switch --orphan <new-branch> ) There is no direct equivalent for this operation. You can achieve similar behavior by first switching to the start point and then creating the orphan branch. git checkout [--detach] <commit> git switch --detach <commit> Both commands are used to checkout a specific commit in a detached HEAD state. git checkout --detach [<branch>] git switch --detach [<branch>] Both commands are used to detach the HEAD from the current or specified branch. git checkout [--] <pathspec>\u2026 git restore [--] <pathspec>\u2026 Both commands are used to restore files in the working directory. The new command git restore provides a clearer syntax for this operation. git checkout --pathspec-from-file=<file> git restore --pathspec-from-file=<file> Both commands are used to restore files specified in a file. The new command git restore provides a clearer syntax for this operation. git checkout <tree-ish> [--] <pathspec>\u2026 git restore -s <tree> [--] <pathspec>\u2026 Both commands are used to restore files from a specific tree. The new command git restore provides a clearer syntax for this operation. git checkout <tree-ish> --pathspec-from-file=<file> git restore -s <tree> --pathspec-from-file=<file> Both commands are used to restore files specified in a file from a specific tree. The new command git restore provides a clearer syntax for this operation. git checkout -p [<tree-ish>] [--] [<pathspec>\u2026] git restore -p [-s <tree>] [--] [<pathspec>\u2026] Both commands are used to interactively restore changes from a specific tree. The new command git restore provides a clearer syntax for this operation. As shown by this comparison, some prior usages can be converted to the new commands by simply replacing the old command name (checkout) with the new one (switch, restore), whereas others require additional adjustment. Notable changes include: The -b/-B options for creating a new branch before switching are renamed to -c/-C. They also have long option variants (--create/--force-create), unlike before. --detach (or -d) is now always required when switching to a detached head, where it was previously optional for commits but required for branches. The source tree for restoring is now given by the -s (or --source) option, rather than being an inline argument. Switching using --force (or -f) now fails if there are unmerged entries, rather than ignoring them. --force has also been renamed to --discard-changes, with --force being kept as an alias.","title":"Comparison with Newer Commands"},{"location":"Advanced/git_checkout/#git-switch","text":"Provides a clearer and more intuitive syntax specifically for switching branches.","title":"git switch"},{"location":"Advanced/git_checkout/#git-restore","text":"Offers dedicated options for restoring files and discarding changes, providing a more explicit and versatile interface for these operations.","title":"git restore"},{"location":"Advanced/git_checkout/#use-cases","text":"Simple Branch Switching For basic branch switching operations, git checkout remains a straightforward and commonly used command. File-Level Operations When performing file-level operations like restoring files from commits or discarding local changes, git checkout provides a concise syntax. Advanced Branch Management For more advanced branch management tasks or when using newer Git features, git switch and git restore may offer advantages in terms of clarity and functionality. git checkout is a versatile Git command with various features for branch switching, file restoration, and more. While newer commands like git switch and git restore offer some improvements and specialized functionality, git checkout remains a fundamental and widely used command in Git workflows. Depending on the specific task at hand and personal preference, you may choose to use git checkout or explore the capabilities of newer Git commands for branch and file management.","title":"Use Cases"},{"location":"Advanced/git_cherry/","text":"git cherry-pick is a powerful Git command used to apply individual commits from one branch to another. It allows you to select specific commits and apply them to the current branch, effectively incorporating changes from one branch into another. Syntax git cherry-pick <commit> <commit> : The commit hash or reference of the commit you want to cherry-pick. Options -e or --edit : Allows you to edit the commit message before committing the cherry-picked commit. -n or --no-commit : Applies the changes from the commit but does not create a new commit automatically. Useful for cherry-picking multiple commits together. -x or --signoff : Adds a \"Signed-off-by\" line to the commit message, indicating authorship. -m parent-number or --mainline parent-number : Specifies the parent number when cherry-picking a merge commit. Default is 1 (first parent). -s or --strategy <strategy> : Specifies the merge strategy to use when resolving conflicts. Options include recursive (default), resolve , ours , theirs , etc. Examples 1. Cherry-picking a Single Commit git cherry-pick abc123 This command applies the changes from the commit with the hash abc123 to the current branch. 2. Cherry-picking a Range of Commits git cherry-pick abc123..def456 This command applies the changes from all commits in the range abc123 to def456 to the current branch. 3. Cherry-picking with Edit git cherry-pick -e abc123 This command applies the changes from the commit abc123 to the current branch and allows you to edit the commit message before committing. 4. Cherry-picking without Committing git cherry-pick -n abc123 This command applies the changes from the commit abc123 to the current branch but does not create a new commit automatically. You can then manually commit the changes using git commit . 5. Cherry-picking with Merge Strategy git cherry-pick -s -X theirs abc123 This command applies the changes from the commit abc123 to the current branch and resolves conflicts by favoring the changes from the cherry-picked commit ( theirs strategy). Use Cases Porting Fixes: Cherry-pick commits containing bug fixes or feature enhancements from one branch to another, such as from a development branch to a stable release branch. Reverting Changes: Use cherry-pick to revert specific changes made in one branch from another branch without reverting the entire commit. Selectively Applying Changes: Apply only certain changes from a commit instead of the entire commit by using git cherry-pick -n followed by manual modifications. git cherry-pick is a versatile command that allows you to apply specific commits from one branch to another. By understanding its options and usage examples, you can effectively incorporate changes from one branch into another, facilitating collaboration and code management in your Git workflow.","title":"CherryPicking"},{"location":"Advanced/git_cherry/#syntax","text":"git cherry-pick <commit> <commit> : The commit hash or reference of the commit you want to cherry-pick.","title":"Syntax"},{"location":"Advanced/git_cherry/#options","text":"-e or --edit : Allows you to edit the commit message before committing the cherry-picked commit. -n or --no-commit : Applies the changes from the commit but does not create a new commit automatically. Useful for cherry-picking multiple commits together. -x or --signoff : Adds a \"Signed-off-by\" line to the commit message, indicating authorship. -m parent-number or --mainline parent-number : Specifies the parent number when cherry-picking a merge commit. Default is 1 (first parent). -s or --strategy <strategy> : Specifies the merge strategy to use when resolving conflicts. Options include recursive (default), resolve , ours , theirs , etc.","title":"Options"},{"location":"Advanced/git_cherry/#examples","text":"","title":"Examples"},{"location":"Advanced/git_cherry/#1-cherry-picking-a-single-commit","text":"git cherry-pick abc123 This command applies the changes from the commit with the hash abc123 to the current branch.","title":"1. Cherry-picking a Single Commit"},{"location":"Advanced/git_cherry/#2-cherry-picking-a-range-of-commits","text":"git cherry-pick abc123..def456 This command applies the changes from all commits in the range abc123 to def456 to the current branch.","title":"2. Cherry-picking a Range of Commits"},{"location":"Advanced/git_cherry/#3-cherry-picking-with-edit","text":"git cherry-pick -e abc123 This command applies the changes from the commit abc123 to the current branch and allows you to edit the commit message before committing.","title":"3. Cherry-picking with Edit"},{"location":"Advanced/git_cherry/#4-cherry-picking-without-committing","text":"git cherry-pick -n abc123 This command applies the changes from the commit abc123 to the current branch but does not create a new commit automatically. You can then manually commit the changes using git commit .","title":"4. Cherry-picking without Committing"},{"location":"Advanced/git_cherry/#5-cherry-picking-with-merge-strategy","text":"git cherry-pick -s -X theirs abc123 This command applies the changes from the commit abc123 to the current branch and resolves conflicts by favoring the changes from the cherry-picked commit ( theirs strategy).","title":"5. Cherry-picking with Merge Strategy"},{"location":"Advanced/git_cherry/#use-cases","text":"Porting Fixes: Cherry-pick commits containing bug fixes or feature enhancements from one branch to another, such as from a development branch to a stable release branch. Reverting Changes: Use cherry-pick to revert specific changes made in one branch from another branch without reverting the entire commit. Selectively Applying Changes: Apply only certain changes from a commit instead of the entire commit by using git cherry-pick -n followed by manual modifications. git cherry-pick is a versatile command that allows you to apply specific commits from one branch to another. By understanding its options and usage examples, you can effectively incorporate changes from one branch into another, facilitating collaboration and code management in your Git workflow.","title":"Use Cases"},{"location":"Advanced/git_ignore/","text":"In Git, you can ignore files using patterns by creating or modifying a special file called .gitignore . This file contains a list of file patterns that Git should ignore when tracking changes in your repository. Creating or Modifying .gitignore Specify files or directories that Git should ignore. The .gitignore file should be located at the root of your Git repository. Common File Patterns Wildcard ( * ): Matches zero or more characters. Directory ( / ): Denotes a directory. Negation ( ! ): Excludes files or directories that match the pattern. The rules for the patterns you can put in the .gitignore file are as follows: Blank lines or lines starting with # are ignored. Standard glob patterns work, and will be applied recursively throughout the entire working tree. You can start patterns with a forward slash (/) to avoid recursivity. You can end patterns with a forward slash (/) to specify a directory. You can negate a pattern by starting it with an exclamation point (!). Glob patterns are like simplified regular expressions that shells use. An asterisk ( ) matches zero or more characters; [abc] matches any character inside the brackets (in this case a, b, or c); a question mark (?) matches a single character; and brackets enclosing characters separated by a hyphen ([0-9]) matches any character between them (in this case 0 through 9). You can also use two asterisks to match nested directories; a/ */z would match a/z, a/b/z, a/b/c/z, and so on. a. Ignore Specific Files # Ignore log files *.log # Ignore build artifacts /build/ b. Ignore Files in a Directory # Ignore all files in the temp directory temp/* # But track one specific file in temp !temp/important.txt c. Ignore Files with a Specific Extension # Ignore all .pdf files *.pdf d. Ignore Files in Subdirectories # Ignore all .class files in any directory **/*.class e. More examples # ignore all .a files *.a # but do track lib.a, even though you're ignoring .a files above !lib.a # only ignore the TODO file in the current directory, not subdir/TODO /TODO # ignore all files in any directory named build build/ # ignore doc/notes.txt, but not doc/server/arch.txt doc/*.txt # ignore all .pdf files in the doc/ directory and any of its subdirectories doc/**/*.pdf More examples from GitHub . Applying .gitignore Changes After modifying the .gitignore file, you need to commit the changes to apply them to the repository. git add .gitignore git commit -m \"Add .gitignore to ignore specific files\" Global .gitignore You can create a global .gitignore file that applies to all repositories on your system by configuring Git to use it. The command git config --global core.excludesfile [file] is used to specify a system-wide ignore pattern file that Git will use for all local repositories on your system. git config --global core.excludesfile [ file ] Parameters: --global : This option specifies that the configuration should be applied globally, affecting all Git repositories on your system. core.excludesfile : This is the Git configuration key for specifying the location of the system-wide ignore file. [file] : This parameter specifies the path to the file containing the ignore patterns. git config --global core.excludesfile ~/.gitignore_global This command tells Git to use the specified file ( ~/.gitignore_global in this example) as the system-wide ignore pattern file. Any patterns defined in this file will be applied to all local repositories on your system, regardless of their location. Ignoring Changes in Tracked Files If you want to ignore changes in files that are already being tracked by Git, you can use the git update-index --assume-unchanged command. The git update-index --assume-unchanged command is used to tell Git to temporarily ignore changes to a tracked file. When you run this command, Git updates its index to mark the specified file ( config.ini in this example) as \"assume unchanged\". The --assume-unchanged option allows you to tell Git to treat a file as if it hasn't been changed, even if it has been modified since the last commit. git update-index --assume-unchanged <file> <file> : The path to the file you want to mark as unchanged. git update-index --assume-unchanged config.ini When you run this command, Git updates its index to mark the specified file ( config.ini in this example) as \"assume unchanged\". After marking a file as \"assume unchanged\", Git will not track changes to that file in future commits, treating it as if it hasn't been modified. This command is useful when you have local changes to a tracked file that you don't want to commit or stage for commit, such as configuration files with local settings that should not be shared with others. Use Cases Ignoring Local Changes: You can use this command to prevent accidentally committing local changes to certain files, such as configuration files with sensitive information or local overrides. Performance Optimization: By marking files as \"assume unchanged\", Git can improve performance by not having to check these files for changes when performing various operations, such as git status or git add . Caveats Manual Updates: It's important to note that this command only affects how Git treats the file in future operations. If the file is modified again in the future and you want to commit those changes, you will need to remove the \"assume unchanged\" status using git update-index --no-assume-unchanged <file> . Note This command only affects your local repository and does not affect the repository's history or other collaborators. Using git update-index --assume-unchanged can be a helpful tool for managing local changes to tracked files in your Git repository, allowing you to prevent accidental commits of sensitive or local-specific changes. Ignoring files using patterns in Git is essential for preventing certain files or directories from being tracked in your repository. By creating or modifying the .gitignore file and specifying file patterns, you can effectively manage which files Git should ignore. Understanding the common file patterns and how to apply them allows you to tailor Git's behavior to suit your project's needs while keeping the repository clean and manageable.","title":"Ignoring Files"},{"location":"Advanced/git_ignore/#creating-or-modifying-gitignore","text":"Specify files or directories that Git should ignore. The .gitignore file should be located at the root of your Git repository.","title":"Creating or Modifying .gitignore"},{"location":"Advanced/git_ignore/#common-file-patterns","text":"Wildcard ( * ): Matches zero or more characters. Directory ( / ): Denotes a directory. Negation ( ! ): Excludes files or directories that match the pattern. The rules for the patterns you can put in the .gitignore file are as follows: Blank lines or lines starting with # are ignored. Standard glob patterns work, and will be applied recursively throughout the entire working tree. You can start patterns with a forward slash (/) to avoid recursivity. You can end patterns with a forward slash (/) to specify a directory. You can negate a pattern by starting it with an exclamation point (!). Glob patterns are like simplified regular expressions that shells use. An asterisk ( ) matches zero or more characters; [abc] matches any character inside the brackets (in this case a, b, or c); a question mark (?) matches a single character; and brackets enclosing characters separated by a hyphen ([0-9]) matches any character between them (in this case 0 through 9). You can also use two asterisks to match nested directories; a/ */z would match a/z, a/b/z, a/b/c/z, and so on.","title":"Common File Patterns"},{"location":"Advanced/git_ignore/#a-ignore-specific-files","text":"# Ignore log files *.log # Ignore build artifacts /build/","title":"a. Ignore Specific Files"},{"location":"Advanced/git_ignore/#b-ignore-files-in-a-directory","text":"# Ignore all files in the temp directory temp/* # But track one specific file in temp !temp/important.txt","title":"b. Ignore Files in a Directory"},{"location":"Advanced/git_ignore/#c-ignore-files-with-a-specific-extension","text":"# Ignore all .pdf files *.pdf","title":"c. Ignore Files with a Specific Extension"},{"location":"Advanced/git_ignore/#d-ignore-files-in-subdirectories","text":"# Ignore all .class files in any directory **/*.class","title":"d. Ignore Files in Subdirectories"},{"location":"Advanced/git_ignore/#e-more-examples","text":"# ignore all .a files *.a # but do track lib.a, even though you're ignoring .a files above !lib.a # only ignore the TODO file in the current directory, not subdir/TODO /TODO # ignore all files in any directory named build build/ # ignore doc/notes.txt, but not doc/server/arch.txt doc/*.txt # ignore all .pdf files in the doc/ directory and any of its subdirectories doc/**/*.pdf More examples from GitHub .","title":"e. More examples"},{"location":"Advanced/git_ignore/#applying-gitignore-changes","text":"After modifying the .gitignore file, you need to commit the changes to apply them to the repository. git add .gitignore git commit -m \"Add .gitignore to ignore specific files\"","title":"Applying .gitignore Changes"},{"location":"Advanced/git_ignore/#global-gitignore","text":"You can create a global .gitignore file that applies to all repositories on your system by configuring Git to use it. The command git config --global core.excludesfile [file] is used to specify a system-wide ignore pattern file that Git will use for all local repositories on your system. git config --global core.excludesfile [ file ] Parameters: --global : This option specifies that the configuration should be applied globally, affecting all Git repositories on your system. core.excludesfile : This is the Git configuration key for specifying the location of the system-wide ignore file. [file] : This parameter specifies the path to the file containing the ignore patterns. git config --global core.excludesfile ~/.gitignore_global This command tells Git to use the specified file ( ~/.gitignore_global in this example) as the system-wide ignore pattern file. Any patterns defined in this file will be applied to all local repositories on your system, regardless of their location.","title":"Global .gitignore"},{"location":"Advanced/git_ignore/#ignoring-changes-in-tracked-files","text":"If you want to ignore changes in files that are already being tracked by Git, you can use the git update-index --assume-unchanged command. The git update-index --assume-unchanged command is used to tell Git to temporarily ignore changes to a tracked file. When you run this command, Git updates its index to mark the specified file ( config.ini in this example) as \"assume unchanged\". The --assume-unchanged option allows you to tell Git to treat a file as if it hasn't been changed, even if it has been modified since the last commit. git update-index --assume-unchanged <file> <file> : The path to the file you want to mark as unchanged. git update-index --assume-unchanged config.ini When you run this command, Git updates its index to mark the specified file ( config.ini in this example) as \"assume unchanged\". After marking a file as \"assume unchanged\", Git will not track changes to that file in future commits, treating it as if it hasn't been modified. This command is useful when you have local changes to a tracked file that you don't want to commit or stage for commit, such as configuration files with local settings that should not be shared with others.","title":"Ignoring Changes in Tracked Files"},{"location":"Advanced/git_interactivestaging/","text":"Interactive staging , also known as interactive mode or interactive patching, is a feature in Git that allows you to selectively stage changes from your working directory for a commit, offering more control over the staging process. It's particularly useful when you have made several changes in a single file or across multiple files and want to stage them selectively instead of committing all changes at once. 1. Start Interactive Staging To start interactive staging, use the git add -i or git add --interactive command followed by the name of the file or directory you want to stage changes from. git add -i myfile.txt 2. Select Staging Mode Git will prompt you to choose the staging mode. Common options include: status : Interactively stage changes from the current status of the repository. patch : Interactively stage changes file by file, allowing you to review and select changes within each file. update : Interactively stage changes from tracked files that have been modified or deleted. Choose the appropriate mode by entering its corresponding number or letter. 3. Review and Select Changes Once in interactive staging mode, Git will display a list of changes to review. For each change, Git will prompt you with options to stage, skip, or split the change into smaller parts. y : Stage the change. n : Skip the change. s : Split the change into smaller parts for finer-grained staging. q : Quit interactive staging. Choose the appropriate action for each change by entering its corresponding key. 4. Stage Changes After reviewing and selecting changes, Git will stage the changes according to your selections. You can then proceed to commit the staged changes using git commit . Example: Let's say you have made changes to myfile.txt and want to interactively stage them: git add -i myfile.txt Git will prompt you to choose the staging mode: staged unstaged path 1: unchanged +4/-2 myfile.txt *** Commands *** 1: status 2: update 3: revert 4: add untracked 5: patch 6: diff 7: quit 8: help What now> You can then enter 5 to choose the patch mode. Git will display the changes within myfile.txt and prompt you with options to stage, skip, or split each change. Sure, let's dive deeper into each staging mode with additional examples: Interactive Staging with status Mode In this mode, Git displays the changes in the current status of the repository and allows you to interactively stage them. git add -i Git will prompt you to choose the staging mode. Enter 1 for status . staged unstaged path 1: unchanged +4/-2 myfile.txt 2: unchanged +2/-1 anotherfile.txt *** Commands *** 1: status 2: update 3: revert 4: add untracked 5: patch 6: diff 7: quit 8: help What now> You can then choose individual files to stage by entering their corresponding numbers. Interactive Staging with update Mode: In this mode, Git displays changes from tracked files that have been modified or deleted and allows you to interactively stage them. git add -i Git will prompt you to choose the staging mode. Enter 2 for update . staged unstaged path 1: unchanged +4/-2 myfile.txt 2: unchanged +2/-1 anotherfile.txt *** Commands *** 1: status 2: update 3: revert 4: add untracked 5: patch 6: diff 7: quit 8: help What now> You can then select individual changes to stage by entering their corresponding numbers. Interactive Staging with patch Mode: In this mode, Git displays changes within each file and allows you to interactively stage them. git add -i Git will prompt you to choose the staging mode. Enter 5 for patch . staged unstaged path 1: unchanged +4/-2 myfile.txt 2: unchanged +2/-1 anotherfile.txt *** Commands *** 1: status 2: update 3: revert 4: add untracked 5: patch 6: diff 7: quit 8: help What now> You can then choose a file to review and interactively stage changes within it. Summary: Interactive staging modes in Git provide granular control over the staging process, allowing you to review and selectively stage changes from your working directory. By using different staging modes, you can stage changes based on the current status of the repository, modifications to tracked files, or changes within specific files. This level of control helps ensure that only relevant changes are included in your commits, leading to cleaner and more organized version control. By using interactive staging, you can commit changes more precisely, avoiding accidental commits of unrelated changes and ensuring cleaner commit histories. This feature is particularly useful when dealing with complex changes or when you want to review changes before committing them to the repository.","title":"Interactive Staging"},{"location":"Advanced/git_interactivestaging/#1-start-interactive-staging","text":"To start interactive staging, use the git add -i or git add --interactive command followed by the name of the file or directory you want to stage changes from. git add -i myfile.txt","title":"1. Start Interactive Staging"},{"location":"Advanced/git_interactivestaging/#2-select-staging-mode","text":"Git will prompt you to choose the staging mode. Common options include: status : Interactively stage changes from the current status of the repository. patch : Interactively stage changes file by file, allowing you to review and select changes within each file. update : Interactively stage changes from tracked files that have been modified or deleted. Choose the appropriate mode by entering its corresponding number or letter.","title":"2. Select Staging Mode"},{"location":"Advanced/git_interactivestaging/#3-review-and-select-changes","text":"Once in interactive staging mode, Git will display a list of changes to review. For each change, Git will prompt you with options to stage, skip, or split the change into smaller parts. y : Stage the change. n : Skip the change. s : Split the change into smaller parts for finer-grained staging. q : Quit interactive staging. Choose the appropriate action for each change by entering its corresponding key.","title":"3. Review and Select Changes"},{"location":"Advanced/git_interactivestaging/#4-stage-changes","text":"After reviewing and selecting changes, Git will stage the changes according to your selections. You can then proceed to commit the staged changes using git commit .","title":"4. Stage Changes"},{"location":"Advanced/git_interactivestaging/#example","text":"Let's say you have made changes to myfile.txt and want to interactively stage them: git add -i myfile.txt Git will prompt you to choose the staging mode: staged unstaged path 1: unchanged +4/-2 myfile.txt *** Commands *** 1: status 2: update 3: revert 4: add untracked 5: patch 6: diff 7: quit 8: help What now> You can then enter 5 to choose the patch mode. Git will display the changes within myfile.txt and prompt you with options to stage, skip, or split each change. Sure, let's dive deeper into each staging mode with additional examples:","title":"Example:"},{"location":"Advanced/git_interactivestaging/#interactive-staging-with-status-mode","text":"In this mode, Git displays the changes in the current status of the repository and allows you to interactively stage them. git add -i Git will prompt you to choose the staging mode. Enter 1 for status . staged unstaged path 1: unchanged +4/-2 myfile.txt 2: unchanged +2/-1 anotherfile.txt *** Commands *** 1: status 2: update 3: revert 4: add untracked 5: patch 6: diff 7: quit 8: help What now> You can then choose individual files to stage by entering their corresponding numbers.","title":"Interactive Staging with status Mode"},{"location":"Advanced/git_interactivestaging/#interactive-staging-with-update-mode","text":"In this mode, Git displays changes from tracked files that have been modified or deleted and allows you to interactively stage them. git add -i Git will prompt you to choose the staging mode. Enter 2 for update . staged unstaged path 1: unchanged +4/-2 myfile.txt 2: unchanged +2/-1 anotherfile.txt *** Commands *** 1: status 2: update 3: revert 4: add untracked 5: patch 6: diff 7: quit 8: help What now> You can then select individual changes to stage by entering their corresponding numbers.","title":"Interactive Staging with update Mode:"},{"location":"Advanced/git_interactivestaging/#interactive-staging-with-patch-mode","text":"In this mode, Git displays changes within each file and allows you to interactively stage them. git add -i Git will prompt you to choose the staging mode. Enter 5 for patch . staged unstaged path 1: unchanged +4/-2 myfile.txt 2: unchanged +2/-1 anotherfile.txt *** Commands *** 1: status 2: update 3: revert 4: add untracked 5: patch 6: diff 7: quit 8: help What now> You can then choose a file to review and interactively stage changes within it.","title":"Interactive Staging with patch Mode:"},{"location":"Advanced/git_interactivestaging/#summary","text":"Interactive staging modes in Git provide granular control over the staging process, allowing you to review and selectively stage changes from your working directory. By using different staging modes, you can stage changes based on the current status of the repository, modifications to tracked files, or changes within specific files. This level of control helps ensure that only relevant changes are included in your commits, leading to cleaner and more organized version control. By using interactive staging, you can commit changes more precisely, avoiding accidental commits of unrelated changes and ensuring cleaner commit histories. This feature is particularly useful when dealing with complex changes or when you want to review changes before committing them to the repository.","title":"Summary:"},{"location":"Advanced/git_patches/","text":"Creating patches in Git involves generating files that represent the changes introduced by one or more commits. These patches can then be shared with others or applied to different repositories. Using git format-patch The git format-patch command generates patch files for one or more commits, formatting them in the \"mbox\" format by default. git format-patch <start-commit>..<end-commit> git format-patch HEAD~3..HEAD - This command generates patch files for the last three commits from the current HEAD commit. Creating Patches for Specific Commits You can specify individual commits to create patches for by providing their commit hashes. git format-patch <commit-hash> git format-patch abc123 - This command generates a patch file for the commit with the hash abc123 . Specifying Output Directory You can specify the output directory for the generated patch files using the -o or --output-directory option. git format-patch -o <output-directory> <start-commit>..<end-commit> git format-patch -o patches/ HEAD~3..HEAD This command generates patch files for the last three commits and saves them in the patches/ directory. Including Commit Message in Patch You can include the commit message as part of the patch file by using the --stdout option. git format-patch --stdout <commit-hash> git format-patch --stdout abc123 > patch_file.patch This command generates a patch file for the commit with the hash abc123 and includes the commit message in the output. Generating Patch for Unpushed Commits To create patches for unpushed commits, you can specify the branch name along with the git format-patch command. git format-patch origin/<branch-name> git format-patch origin/main This command generates patch files for the commits that are present in the local branch but not in the remote main branch. Inspecting and Applying Patch Files Once the patch files are generated, you can inspect them using any text editor or view the changes using the git apply --stat command. git apply --stat <patch-file> This command displays statistics about the changes introduced by the patch file. The command git apply patchtext.patch is used to apply a patch file to the current working directory. git apply <patch-file> git apply : This Git command is used to apply a patch file to the current working directory. patchtext.patch : This is the name of the patch file you want to apply. The patch file contains the changes that you want to apply to your repository. How It Works Ensure Correct Context: The patch file must be generated in a compatible format with the changes relative to the repository's current state. Navigate to Repository: First, navigate to the directory of the Git repository where you want to apply the changes. Checkout Target Branch/Commit: Ensure that you are on the correct branch or commit where you want the changes to be applied. This step ensures that the changes are applied to the correct codebase. Run git apply : Execute the git apply command followed by the name of the patch file you want to apply. Review Changes: After applying the patch, review the changes to ensure they were applied correctly. You can use git diff to inspect the differences before and after applying the patch. Stage and Commit (if necessary): If the changes are satisfactory, stage and commit them to finalize the application of the patch. Considerations Patch Compatibility: Ensure that the patch file is compatible with the version of the codebase you are applying it to. Mismatches in context or format can lead to errors or unintended consequences. Review Changes: Always review the changes introduced by the patch to verify correctness and avoid introducing bugs or conflicts. Backup: Consider creating a backup or working on a separate branch before applying patches, especially if the changes are significant or experimental. Using git apply provides a straightforward way to apply patches to a Git repository, allowing you to integrate changes from external sources or collaborators efficiently. Sharing Patch Files You can share the generated patch files with others through email, file sharing services, or version control systems. Generating patches in Git using git format-patch provides a convenient way to share changes between repositories or with collaborators. By following these steps and examples, you can create patch files for specific commits or ranges of commits and distribute them efficiently.","title":"Patching"},{"location":"Advanced/git_patches/#using-git-format-patch","text":"The git format-patch command generates patch files for one or more commits, formatting them in the \"mbox\" format by default. git format-patch <start-commit>..<end-commit> git format-patch HEAD~3..HEAD - This command generates patch files for the last three commits from the current HEAD commit.","title":"Using git format-patch"},{"location":"Advanced/git_patches/#creating-patches-for-specific-commits","text":"You can specify individual commits to create patches for by providing their commit hashes. git format-patch <commit-hash> git format-patch abc123 - This command generates a patch file for the commit with the hash abc123 .","title":"Creating Patches for Specific Commits"},{"location":"Advanced/git_patches/#specifying-output-directory","text":"You can specify the output directory for the generated patch files using the -o or --output-directory option. git format-patch -o <output-directory> <start-commit>..<end-commit> git format-patch -o patches/ HEAD~3..HEAD This command generates patch files for the last three commits and saves them in the patches/ directory.","title":"Specifying Output Directory"},{"location":"Advanced/git_patches/#including-commit-message-in-patch","text":"You can include the commit message as part of the patch file by using the --stdout option. git format-patch --stdout <commit-hash> git format-patch --stdout abc123 > patch_file.patch This command generates a patch file for the commit with the hash abc123 and includes the commit message in the output.","title":"Including Commit Message in Patch"},{"location":"Advanced/git_patches/#generating-patch-for-unpushed-commits","text":"To create patches for unpushed commits, you can specify the branch name along with the git format-patch command. git format-patch origin/<branch-name> git format-patch origin/main This command generates patch files for the commits that are present in the local branch but not in the remote main branch.","title":"Generating Patch for Unpushed Commits"},{"location":"Advanced/git_patches/#inspecting-and-applying-patch-files","text":"Once the patch files are generated, you can inspect them using any text editor or view the changes using the git apply --stat command. git apply --stat <patch-file> This command displays statistics about the changes introduced by the patch file. The command git apply patchtext.patch is used to apply a patch file to the current working directory. git apply <patch-file> git apply : This Git command is used to apply a patch file to the current working directory. patchtext.patch : This is the name of the patch file you want to apply. The patch file contains the changes that you want to apply to your repository.","title":"Inspecting and Applying Patch Files"},{"location":"Advanced/git_patches/#how-it-works","text":"Ensure Correct Context: The patch file must be generated in a compatible format with the changes relative to the repository's current state. Navigate to Repository: First, navigate to the directory of the Git repository where you want to apply the changes. Checkout Target Branch/Commit: Ensure that you are on the correct branch or commit where you want the changes to be applied. This step ensures that the changes are applied to the correct codebase. Run git apply : Execute the git apply command followed by the name of the patch file you want to apply. Review Changes: After applying the patch, review the changes to ensure they were applied correctly. You can use git diff to inspect the differences before and after applying the patch. Stage and Commit (if necessary): If the changes are satisfactory, stage and commit them to finalize the application of the patch.","title":"How It Works"},{"location":"Advanced/git_patches/#considerations","text":"Patch Compatibility: Ensure that the patch file is compatible with the version of the codebase you are applying it to. Mismatches in context or format can lead to errors or unintended consequences. Review Changes: Always review the changes introduced by the patch to verify correctness and avoid introducing bugs or conflicts. Backup: Consider creating a backup or working on a separate branch before applying patches, especially if the changes are significant or experimental. Using git apply provides a straightforward way to apply patches to a Git repository, allowing you to integrate changes from external sources or collaborators efficiently.","title":"Considerations"},{"location":"Advanced/git_patches/#sharing-patch-files","text":"You can share the generated patch files with others through email, file sharing services, or version control systems. Generating patches in Git using git format-patch provides a convenient way to share changes between repositories or with collaborators. By following these steps and examples, you can create patch files for specific commits or ranges of commits and distribute them efficiently.","title":"Sharing Patch Files"},{"location":"Advanced/git_stash/","text":"In Git, temporary commits, also known as \"stashing,\" allow you to save your work temporarily without committing it to the repository. Stashing is useful when you need to switch to another task or branch but want to keep your current changes for later use. Stashing Changes git stash - This command saves your current changes in a \"stash\" without committing them to the repository. - Git removes the changes from the working directory and staging area, allowing you to switch branches or perform other operations. Listing Stashes git stash list This command lists all stashes you have saved. Each stash is identified by a unique identifier, typically a number. Applying Stashed Changes git stash apply [ <stash> ] git stash apply stash@ { 0 } This command applies the changes from the specified stash to the current working directory. If no stash is specified, Git applies the most recent stash by default. Popping Stashed Changes git stash pop [ <stash> ] git stash pop stash@ { 0 } This command applies the changes from the specified stash and removes it from the stash list. If no stash is specified, Git pops the most recent stash by default. Droping Stashed Changes The git stash drop command is used to remove stashed changes from the stash list. git stash drop [ <stash> ] - <stash> : Optional. Specifies the stash to drop. If not provided, Git drops the most recent stash by default. git stash drop stash@ { 0 } This command removes the specified stash from the stash list. If no stash is specified, Git drops the most recent stash by default. Once dropped, the changes stored in the stash are permanently deleted and cannot be recovered. Cleanup: Use git stash drop to remove unwanted or obsolete stashes from the stash list, freeing up space and decluttering your repository. Permanent Deletion: Be cautious when using git stash drop , as it permanently deletes the specified stash and its associated changes. Ensure that you no longer need the changes before dropping the stash. Clearing Stashes git stash clear This command removes all stashes from the stash list. Use with caution, as it permanently deletes all stashed changes. Use Cases Switching Tasks: Stash changes when you need to switch tasks or work on a different branch temporarily. Experimentation: Stash changes before experimenting with code changes, allowing you to revert easily if needed. Conflict Resolution: Stash changes when resolving conflicts during a merge or rebase operation. Stashing changes in Git provides a convenient way to save your work temporarily without committing it to the repository. By stashing changes, you can switch tasks, experiment with code changes, or resolve conflicts with confidence, knowing that your work is safely stored and can be easily reapplied when needed. Stashing is a valuable tool for managing your workflow effectively in Git.","title":"Temporary Commits"},{"location":"Advanced/git_stash/#stashing-changes","text":"git stash - This command saves your current changes in a \"stash\" without committing them to the repository. - Git removes the changes from the working directory and staging area, allowing you to switch branches or perform other operations.","title":"Stashing Changes"},{"location":"Advanced/git_stash/#listing-stashes","text":"git stash list This command lists all stashes you have saved. Each stash is identified by a unique identifier, typically a number.","title":"Listing Stashes"},{"location":"Advanced/git_stash/#applying-stashed-changes","text":"git stash apply [ <stash> ] git stash apply stash@ { 0 } This command applies the changes from the specified stash to the current working directory. If no stash is specified, Git applies the most recent stash by default.","title":"Applying Stashed Changes"},{"location":"Advanced/git_stash/#popping-stashed-changes","text":"git stash pop [ <stash> ] git stash pop stash@ { 0 } This command applies the changes from the specified stash and removes it from the stash list. If no stash is specified, Git pops the most recent stash by default.","title":"Popping Stashed Changes"},{"location":"Advanced/git_stash/#droping-stashed-changes","text":"The git stash drop command is used to remove stashed changes from the stash list. git stash drop [ <stash> ] - <stash> : Optional. Specifies the stash to drop. If not provided, Git drops the most recent stash by default. git stash drop stash@ { 0 } This command removes the specified stash from the stash list. If no stash is specified, Git drops the most recent stash by default. Once dropped, the changes stored in the stash are permanently deleted and cannot be recovered. Cleanup: Use git stash drop to remove unwanted or obsolete stashes from the stash list, freeing up space and decluttering your repository. Permanent Deletion: Be cautious when using git stash drop , as it permanently deletes the specified stash and its associated changes. Ensure that you no longer need the changes before dropping the stash.","title":"Droping Stashed Changes"},{"location":"Advanced/git_stash/#clearing-stashes","text":"git stash clear This command removes all stashes from the stash list. Use with caution, as it permanently deletes all stashed changes.","title":"Clearing Stashes"},{"location":"Advanced/git_stash/#use-cases","text":"Switching Tasks: Stash changes when you need to switch tasks or work on a different branch temporarily. Experimentation: Stash changes before experimenting with code changes, allowing you to revert easily if needed. Conflict Resolution: Stash changes when resolving conflicts during a merge or rebase operation. Stashing changes in Git provides a convenient way to save your work temporarily without committing it to the repository. By stashing changes, you can switch tasks, experiment with code changes, or resolve conflicts with confidence, knowing that your work is safely stored and can be easily reapplied when needed. Stashing is a valuable tool for managing your workflow effectively in Git.","title":"Use Cases"},{"location":"Advanced/git_tagging/","text":"In Git, tagging is the process of assigning a meaningful label or marker to a specific commit in the repository's history. Tags are often used to mark significant points in the project's development, such as releases, versions, or milestones. Types of Tags There are two types of tags in Git: Lightweight Tags These are simple pointers to specific commits, similar to branches but immutable. They are created with the -l option. Annotated Tags These are stored as full objects in the Git database, containing details like the tagger's name, email, date, and a tagging message. They are created with the -a option. Creating Tags Lightweight Tags git tag <tag-name> <commit-hash> git tag v1.0.0 7c52d53 Annotated Tags git tag -a <tag-name> <commit-hash> -m \"Tagging message\" git tag -a v1.0.0 7c52d53 -m \"Version 1.0.0 release\" The -m specifies a tagging message, which is stored with the tag. If you don\u2019t specify a message for an annotated tag, Git launches your editor so you can type it in. Tagging Later : You can also tag commits after you\u2019ve moved past them. Viewing Tags To view all tags in the repository: git tag In Git, listing tags allows you to view all tags present in the repository. You can use wildcards to filter tags based on specific patterns. Here's how you can list tags in Git with examples and wildcards: Listing Tags Matching a Pattern You can use wildcards to list tags matching a specific pattern. Listing tag wildcards requires -l or --list option. The two common wildcards used are: * : Matches any sequence of characters. ? : Matches any single character. Listing Tags Starting with a Prefix To list tags starting with a specific prefix (e.g., v1 ): git tag -l 'v1*' Listing Tags with Annotated Tags Only To list only annotated tags (excluding lightweight tags): git tag -l -n Using wildcards with git tag -l allows you to filter and list tags based on specific patterns, making it easier to manage and navigate through tags in your Git repository. Listing tag wildcards requires -l or --list option. Pushing Tags to Remote By default, the git push command doesn\u2019t transfer tags to remote servers. To push a specific tag to the remote repository: git push origin <tag-name> To push all tags to the remote repository: git push origin --tags git push origin v1.0.0 git push pushes both types of tags. git push --tags will push both lightweight and annotated tags. There is currently no option to push only lightweight tags, but if you use git push --follow-tags only annotated tags will be pushed to the remote. Deleting Tags To delete a specific tag: git tag -d <tag-name> git tag -d v1.0.0 To delete a tag on the remote repository: git push origin --delete <tag-name> git push origin --delete v1.0.0 Checking out Tags To checkout a specific tag and create a detached HEAD state: git checkout <tag-name> git checkout v1.0.0 In \u201cdetached HEAD\u201d state, if you make changes and then create a commit, the tag will stay the same, but your new commit won\u2019t belong to any branch and will be unreachable, except by the exact commit hash. Thus, if you need to make changes\u2009\u2014\u2009say you\u2019re fixing a bug on an older version, for instance\u2009\u2014\u2009you will generally want to create a branch: $ git checkout -b version2 v2.0.0 #Switched to a new branch 'version2' If you do this and make a commit, your version2 branch will be slightly different than your v2.0.0 tag since it will move forward with your new changes, so do be careful. Tagging Best Practices Use semantic versioning (e.g., v1.0.0, v1.1.0) for version tags to maintain consistency. Annotate tags with meaningful messages describing the purpose or significance of the tagged commit. Push tags to the remote repository to share them with collaborators and facilitate release management. Git tagging is a powerful feature for marking important points in your project's history, making it easier to navigate and manage releases.","title":"Tagging"},{"location":"Advanced/git_tagging/#types-of-tags","text":"There are two types of tags in Git: Lightweight Tags These are simple pointers to specific commits, similar to branches but immutable. They are created with the -l option. Annotated Tags These are stored as full objects in the Git database, containing details like the tagger's name, email, date, and a tagging message. They are created with the -a option.","title":"Types of Tags"},{"location":"Advanced/git_tagging/#creating-tags","text":"","title":"Creating Tags"},{"location":"Advanced/git_tagging/#lightweight-tags","text":"git tag <tag-name> <commit-hash> git tag v1.0.0 7c52d53","title":"Lightweight Tags"},{"location":"Advanced/git_tagging/#annotated-tags","text":"git tag -a <tag-name> <commit-hash> -m \"Tagging message\" git tag -a v1.0.0 7c52d53 -m \"Version 1.0.0 release\" The -m specifies a tagging message, which is stored with the tag. If you don\u2019t specify a message for an annotated tag, Git launches your editor so you can type it in. Tagging Later : You can also tag commits after you\u2019ve moved past them.","title":"Annotated Tags"},{"location":"Advanced/git_tagging/#viewing-tags","text":"To view all tags in the repository: git tag In Git, listing tags allows you to view all tags present in the repository. You can use wildcards to filter tags based on specific patterns. Here's how you can list tags in Git with examples and wildcards:","title":"Viewing Tags"},{"location":"Advanced/git_tagging/#listing-tags-matching-a-pattern","text":"You can use wildcards to list tags matching a specific pattern. Listing tag wildcards requires -l or --list option. The two common wildcards used are: * : Matches any sequence of characters. ? : Matches any single character.","title":"Listing Tags Matching a Pattern"},{"location":"Advanced/git_tagging/#listing-tags-starting-with-a-prefix","text":"To list tags starting with a specific prefix (e.g., v1 ): git tag -l 'v1*'","title":"Listing Tags Starting with a Prefix"},{"location":"Advanced/git_tagging/#listing-tags-with-annotated-tags-only","text":"To list only annotated tags (excluding lightweight tags): git tag -l -n Using wildcards with git tag -l allows you to filter and list tags based on specific patterns, making it easier to manage and navigate through tags in your Git repository. Listing tag wildcards requires -l or --list option.","title":"Listing Tags with Annotated Tags Only"},{"location":"Advanced/git_tagging/#pushing-tags-to-remote","text":"By default, the git push command doesn\u2019t transfer tags to remote servers. To push a specific tag to the remote repository: git push origin <tag-name> To push all tags to the remote repository: git push origin --tags git push origin v1.0.0 git push pushes both types of tags. git push --tags will push both lightweight and annotated tags. There is currently no option to push only lightweight tags, but if you use git push --follow-tags only annotated tags will be pushed to the remote.","title":"Pushing Tags to Remote"},{"location":"Advanced/git_tagging/#deleting-tags","text":"To delete a specific tag: git tag -d <tag-name> git tag -d v1.0.0 To delete a tag on the remote repository: git push origin --delete <tag-name> git push origin --delete v1.0.0","title":"Deleting Tags"},{"location":"Advanced/git_tagging/#checking-out-tags","text":"To checkout a specific tag and create a detached HEAD state: git checkout <tag-name> git checkout v1.0.0 In \u201cdetached HEAD\u201d state, if you make changes and then create a commit, the tag will stay the same, but your new commit won\u2019t belong to any branch and will be unreachable, except by the exact commit hash. Thus, if you need to make changes\u2009\u2014\u2009say you\u2019re fixing a bug on an older version, for instance\u2009\u2014\u2009you will generally want to create a branch: $ git checkout -b version2 v2.0.0 #Switched to a new branch 'version2' If you do this and make a commit, your version2 branch will be slightly different than your v2.0.0 tag since it will move forward with your new changes, so do be careful.","title":"Checking out Tags"},{"location":"Advanced/git_tagging/#tagging-best-practices","text":"Use semantic versioning (e.g., v1.0.0, v1.1.0) for version tags to maintain consistency. Annotate tags with meaningful messages describing the purpose or significance of the tagged commit. Push tags to the remote repository to share them with collaborators and facilitate release management. Git tagging is a powerful feature for marking important points in your project's history, making it easier to navigate and manage releases.","title":"Tagging Best Practices"},{"location":"Basics/git_configuration/","text":"After installing Git, the next step is to configure it with your user information. This ensures that your commits are associated with the correct identity. Follow these steps to configure Git with your user information used across all local repositories: 1. Open a Terminal/Command Prompt Windows: Git Bash, Command Prompt, or PowerShell. macOS/Linux: Terminal. 2. Set Your Username Run the following command, replacing \"Your Name\" with your actual name: git config --global user.name \"firstname Lastname\" 3. Set Your Email Address Run the following command, replacing \"your.email@example.com\" with your actual email address: git config --global user.email \"your.email@example.com\" 4. Configure Line Endings To prevent line ending issues when collaborating across different platforms, set your preferred line ending configuration. For Unix-style line endings (LF), run: git config --global core.autocrlf input For Windows-style line endings (CRLF), run: git config --global core.autocrlf true 5. Configure Text Editor (Optional) Set your preferred text editor for Git. For example, to use VSCode: git config --global core.editor \"code --wait\" 6. Enable Color Output Improve readability by enabling color output in the Git command line: git config --global color.ui auto This setting adds color to various Git outputs, making it easier to distinguish between different types of information.To view your Git configuration, run: 7. Check Configuration To view your Git configuration, run: git config --list Ensure that your name, email, and other settings are correctly displayed. 8. Verify Configuration Run the following commands to verify your configuration: git config user.name git config user.email These commands should display the values you've just set. Additional Tips Credential Caching To avoid entering your credentials repeatedly, you can set up credential caching. On Windows, Git Credential Manager is often used. On macOS/Linux, you can use the credential helper provided by Git: git config --global credential.helper cache SSH Key If you prefer using SSH for authentication, generate an SSH key and associate it with your GitHub account . Your Git configuration is now set up. You can start using Git with your personalized settings for version control and collaboration.","title":"Configuring Git"},{"location":"Basics/git_configuration/#1-open-a-terminalcommand-prompt","text":"Windows: Git Bash, Command Prompt, or PowerShell. macOS/Linux: Terminal.","title":"1. Open a Terminal/Command Prompt"},{"location":"Basics/git_configuration/#2-set-your-username","text":"Run the following command, replacing \"Your Name\" with your actual name: git config --global user.name \"firstname Lastname\"","title":"2. Set Your Username"},{"location":"Basics/git_configuration/#3-set-your-email-address","text":"Run the following command, replacing \"your.email@example.com\" with your actual email address: git config --global user.email \"your.email@example.com\"","title":"3. Set Your Email Address"},{"location":"Basics/git_configuration/#4-configure-line-endings","text":"To prevent line ending issues when collaborating across different platforms, set your preferred line ending configuration. For Unix-style line endings (LF), run: git config --global core.autocrlf input For Windows-style line endings (CRLF), run: git config --global core.autocrlf true","title":"4. Configure Line Endings"},{"location":"Basics/git_configuration/#5-configure-text-editor-optional","text":"Set your preferred text editor for Git. For example, to use VSCode: git config --global core.editor \"code --wait\"","title":"5. Configure Text Editor (Optional)"},{"location":"Basics/git_configuration/#6-enable-color-output","text":"Improve readability by enabling color output in the Git command line: git config --global color.ui auto This setting adds color to various Git outputs, making it easier to distinguish between different types of information.To view your Git configuration, run:","title":"6. Enable Color Output"},{"location":"Basics/git_configuration/#7-check-configuration","text":"To view your Git configuration, run: git config --list Ensure that your name, email, and other settings are correctly displayed.","title":"7. Check Configuration"},{"location":"Basics/git_configuration/#8-verify-configuration","text":"Run the following commands to verify your configuration: git config user.name git config user.email These commands should display the values you've just set.","title":"8. Verify Configuration"},{"location":"Basics/git_configuration/#additional-tips","text":"Credential Caching To avoid entering your credentials repeatedly, you can set up credential caching. On Windows, Git Credential Manager is often used. On macOS/Linux, you can use the credential helper provided by Git: git config --global credential.helper cache SSH Key If you prefer using SSH for authentication, generate an SSH key and associate it with your GitHub account . Your Git configuration is now set up. You can start using Git with your personalized settings for version control and collaboration.","title":"Additional Tips"},{"location":"Basics/git_inspect/","text":"In Git, several commands allow inspection and comparison of changes, commits, branches, and repository states. git status Shows the status of the working directory and staging area. git status Quickly check which files are modified, staged, or untracked. git diff Displays the differences between changes in the working directory and the staging area. git diff Review modifications before staging them or to see changes that haven't been staged yet. git diff {commit} {commit} Shows the differences between two commits. git diff abc123 def456 Compare the changes between specific commits. git diff {branch1} {branch2} Shows the differences between two branches. git diff main feature-branch Compare changes between different branches. git log Displays the commit history. git log Review the commit history, including commit messages, authors, dates, and commit hashes. By default, with no arguments, git log lists the commits made in that repository in reverse chronological order; that is, the most recent commits show up first git log --graph --oneline Shows a compact view of the commit history with a graph. git log --graph --oneline Visualize the branching and merging history of the repository. git log {file} Displays the commit history for a specific file. git log file.txt Review the commit history for a particular file, including changes made to it over time. git log branchB..branchA Shows the commits on branchA that are not on branchB. git log branchB..branchA Identify the commits unique to one branch compared to another, useful for understanding divergent development paths. git log --follow [file] Shows the commits that changed the specified file, even across renames. git log --follow file.txt Track the history of changes for a specific file, even if it was renamed in subsequent commits. git log --patch Shows the commit history in a unified diff format. One of the more helpful options is -p or --patch, which shows the difference (the patch output) introduced in each commit. You can also limit the number of log entries displayed, such as using -2 to show only the last two entries. git log -p -2 git log --stat Shows the commit history in a more readable format. git log --stat -M The --stat option prints below each commit entry a list of modified files, how many files were changed, and how many lines in those files were added and removed. It also puts a summary of the information at the end. This command is used to display the commit history along with statistics about the changes introduced in each commit, including information about file modifications, additions, and deletions. The -M option is particularly used to detect file renames. git log : Displays the commit logs. --stat : Includes additional statistics at the end of each commit entry, providing a summary of changes. -M : Enables Git's rename detection, which identifies file renames between commits. git log --stat -M This command will output a detailed log that includes commit information and statistics. The statistics section shows the number of lines added and removed for each file affected by the commit. Additionally, if a file has been renamed, Git will provide information about the rename. Here is a simplified example of what the output might look like: commit abcd1234 (HEAD) Author: John Doe <john.doe@example.com> Date: Tue Jan 18 12:00:00 2024 +0000 Updated README.md README.md | 10 +++++----- 1 file changed, 5 insertions(+), 5 deletions(-) In this example: commit abcd1234 : The unique identifier of the commit. Author : The author of the commit. Date : The date and time of the commit. Updated README.md : The commit message. The statistics section ( README.md | 10 +++++----- ) indicates that in the file README.md , 10 lines were added, and 5 lines were removed. This section provides a quick overview of the changes made in each commit. The -M option enhances this by detecting file renames. If a file has been renamed, Git will track the rename and display the old and new filenames. The -M option can take an optional value to set a similarity index for rename detection. For example, -M90% would consider files as renamed if 90% of their content is similar. Using -M can be especially useful when you want to track the history of a file that has been renamed over time. Limit the output of git log Option Description -<n> Show only the last n commits. --since, --after Limit the commits to those made after the specified date. --until, --before Limit the commits to those made before the specified date. --author Only show commits in which the author entry matches the specified string. --committer Only show commits in which the committer entry matches the specified string. --grep Only show commits with a commit message containing the string. -S Only show commits adding or removing code matching the string. git log --pretty = \"%h - %s\" --author = 'Junio C Hamano' --since = \"2008-10-01\" --before = \"2008-11-01\" --no-merges -- t/ This git log command is used to display a filtered and formatted list of commits from the Git repository. git log : This is the main Git command for viewing commit history. --pretty=\"%h - %s\" : The --pretty option specifies the output format for each commit. In this case, %h represents the abbreviated commit hash and %s represents the commit subject. The format string %h - %s prints the abbreviated commit hash followed by the commit subject. --author='Junio C Hamano' : The --author option filters the commits based on the author's name. Only commits authored by \"Junio C Hamano\" will be included in the output. --since=\"2008-10-01\" : The --since option specifies the start date for filtering commits. Only commits made after October 1st, 2008, will be included in the output. --before=\"2008-11-01\" : The --before option specifies the end date for filtering commits. Only commits made before November 1st, 2008, will be included in the output. --no-merges : The --no-merges option excludes merge commits from the output. Only non-merge commits will be displayed. -- t/ : This specifies the pathspec, which limits the commits to those that affect files or directories under the t/ directory. git show {commit} Displays the details of a specific commit. git show abc123 View the changes introduced by a commit and its metadata. git branch Lists all local branches. git branch Check the available branches and see the current branch. git branch -a Lists all local and remote branches. git branch -a View all branches, including those from remote repositories. These Git commands for inspection and comparison are invaluable for understanding the state of the repository, tracking changes, reviewing history, and identifying differences between branches or commits. Incorporating these commands into your Git workflow can enhance your ability to manage and collaborate on projects effectively.","title":"Inspect & Compare"},{"location":"Basics/git_inspect/#git-status","text":"Shows the status of the working directory and staging area. git status Quickly check which files are modified, staged, or untracked.","title":"git status"},{"location":"Basics/git_inspect/#git-diff","text":"Displays the differences between changes in the working directory and the staging area. git diff Review modifications before staging them or to see changes that haven't been staged yet.","title":"git diff"},{"location":"Basics/git_inspect/#git-diff-commit-commit","text":"Shows the differences between two commits. git diff abc123 def456 Compare the changes between specific commits.","title":"git diff {commit} {commit}"},{"location":"Basics/git_inspect/#git-diff-branch1-branch2","text":"Shows the differences between two branches. git diff main feature-branch Compare changes between different branches.","title":"git diff {branch1} {branch2}"},{"location":"Basics/git_inspect/#git-log","text":"Displays the commit history. git log Review the commit history, including commit messages, authors, dates, and commit hashes. By default, with no arguments, git log lists the commits made in that repository in reverse chronological order; that is, the most recent commits show up first","title":"git log"},{"location":"Basics/git_inspect/#git-log-graph-oneline","text":"Shows a compact view of the commit history with a graph. git log --graph --oneline Visualize the branching and merging history of the repository.","title":"git log --graph --oneline"},{"location":"Basics/git_inspect/#git-log-file","text":"Displays the commit history for a specific file. git log file.txt Review the commit history for a particular file, including changes made to it over time.","title":"git log {file}"},{"location":"Basics/git_inspect/#git-log-branchbbrancha","text":"Shows the commits on branchA that are not on branchB. git log branchB..branchA Identify the commits unique to one branch compared to another, useful for understanding divergent development paths.","title":"git log branchB..branchA"},{"location":"Basics/git_inspect/#git-log-follow-file","text":"Shows the commits that changed the specified file, even across renames. git log --follow file.txt Track the history of changes for a specific file, even if it was renamed in subsequent commits.","title":"git log --follow [file]"},{"location":"Basics/git_inspect/#git-log-patch","text":"Shows the commit history in a unified diff format. One of the more helpful options is -p or --patch, which shows the difference (the patch output) introduced in each commit. You can also limit the number of log entries displayed, such as using -2 to show only the last two entries. git log -p -2","title":"git log --patch"},{"location":"Basics/git_inspect/#git-log-stat","text":"Shows the commit history in a more readable format. git log --stat -M The --stat option prints below each commit entry a list of modified files, how many files were changed, and how many lines in those files were added and removed. It also puts a summary of the information at the end. This command is used to display the commit history along with statistics about the changes introduced in each commit, including information about file modifications, additions, and deletions. The -M option is particularly used to detect file renames. git log : Displays the commit logs. --stat : Includes additional statistics at the end of each commit entry, providing a summary of changes. -M : Enables Git's rename detection, which identifies file renames between commits. git log --stat -M This command will output a detailed log that includes commit information and statistics. The statistics section shows the number of lines added and removed for each file affected by the commit. Additionally, if a file has been renamed, Git will provide information about the rename. Here is a simplified example of what the output might look like: commit abcd1234 (HEAD) Author: John Doe <john.doe@example.com> Date: Tue Jan 18 12:00:00 2024 +0000 Updated README.md README.md | 10 +++++----- 1 file changed, 5 insertions(+), 5 deletions(-) In this example: commit abcd1234 : The unique identifier of the commit. Author : The author of the commit. Date : The date and time of the commit. Updated README.md : The commit message. The statistics section ( README.md | 10 +++++----- ) indicates that in the file README.md , 10 lines were added, and 5 lines were removed. This section provides a quick overview of the changes made in each commit. The -M option enhances this by detecting file renames. If a file has been renamed, Git will track the rename and display the old and new filenames. The -M option can take an optional value to set a similarity index for rename detection. For example, -M90% would consider files as renamed if 90% of their content is similar. Using -M can be especially useful when you want to track the history of a file that has been renamed over time.","title":"git log --stat"},{"location":"Basics/git_inspect/#limit-the-output-of-git-log","text":"Option Description -<n> Show only the last n commits. --since, --after Limit the commits to those made after the specified date. --until, --before Limit the commits to those made before the specified date. --author Only show commits in which the author entry matches the specified string. --committer Only show commits in which the committer entry matches the specified string. --grep Only show commits with a commit message containing the string. -S Only show commits adding or removing code matching the string. git log --pretty = \"%h - %s\" --author = 'Junio C Hamano' --since = \"2008-10-01\" --before = \"2008-11-01\" --no-merges -- t/ This git log command is used to display a filtered and formatted list of commits from the Git repository. git log : This is the main Git command for viewing commit history. --pretty=\"%h - %s\" : The --pretty option specifies the output format for each commit. In this case, %h represents the abbreviated commit hash and %s represents the commit subject. The format string %h - %s prints the abbreviated commit hash followed by the commit subject. --author='Junio C Hamano' : The --author option filters the commits based on the author's name. Only commits authored by \"Junio C Hamano\" will be included in the output. --since=\"2008-10-01\" : The --since option specifies the start date for filtering commits. Only commits made after October 1st, 2008, will be included in the output. --before=\"2008-11-01\" : The --before option specifies the end date for filtering commits. Only commits made before November 1st, 2008, will be included in the output. --no-merges : The --no-merges option excludes merge commits from the output. Only non-merge commits will be displayed. -- t/ : This specifies the pathspec, which limits the commits to those that affect files or directories under the t/ directory.","title":"Limit the output of git log"},{"location":"Basics/git_inspect/#git-show-commit","text":"Displays the details of a specific commit. git show abc123 View the changes introduced by a commit and its metadata.","title":"git show {commit}"},{"location":"Basics/git_inspect/#git-branch","text":"Lists all local branches. git branch Check the available branches and see the current branch.","title":"git branch"},{"location":"Basics/git_inspect/#git-branch-a","text":"Lists all local and remote branches. git branch -a View all branches, including those from remote repositories. These Git commands for inspection and comparison are invaluable for understanding the state of the repository, tracking changes, reviewing history, and identifying differences between branches or commits. Incorporating these commands into your Git workflow can enhance your ability to manage and collaborate on projects effectively.","title":"git branch -a"},{"location":"Basics/git_install/","text":"Git is a powerful version control system that helps you manage and track changes in your codebase. Here's a simple guide on how to install Git on your machine: Windows Download Git: Visit the official Git website at https://git-scm.com/download/win. Run Installer: Once the download is complete, run the installer and follow the on-screen instructions. Make sure to leave all default settings unless you have specific preferences. Adjusting your PATH environment: Choose the default option to \"Use Git from Git Bash only\" to avoid potential conflicts with other software. Select \"Use the OpenSSL library\" for secure connections. Choosing the Terminal Emulator: You can use Git Bash as your terminal emulator, providing a Unix-like environment on Windows. Alternatively, you can choose to use the Windows Command Prompt or PowerShell. Configuring Line Endings: Select \"Checkout as-is, commit Unix-style line endings\" unless you have a specific reason to choose otherwise. Completing the Installation: Click \"Install\" to complete the installation process. macOS Install Homebrew: Open Terminal and run the following command to install Homebrew, a package manager for macOS: /bin/bash -c \" $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh ) \" 2. Install Git: Once Homebrew is installed, run the following command to install Git: brew install git Linux Ubuntu/Debian sudo apt update sudo apt install git-all Fedora sudo dnf install git Arch Linux sudo pacman -S git Verify Installation Regardless of your operating system, after installation, open a terminal and run: git --version This should display the installed Git version, confirming a successful installation. Now that Git is installed, you're ready to start using version control for your projects!","title":"Installing Git"},{"location":"Basics/git_install/#windows","text":"Download Git: Visit the official Git website at https://git-scm.com/download/win. Run Installer: Once the download is complete, run the installer and follow the on-screen instructions. Make sure to leave all default settings unless you have specific preferences. Adjusting your PATH environment: Choose the default option to \"Use Git from Git Bash only\" to avoid potential conflicts with other software. Select \"Use the OpenSSL library\" for secure connections. Choosing the Terminal Emulator: You can use Git Bash as your terminal emulator, providing a Unix-like environment on Windows. Alternatively, you can choose to use the Windows Command Prompt or PowerShell. Configuring Line Endings: Select \"Checkout as-is, commit Unix-style line endings\" unless you have a specific reason to choose otherwise. Completing the Installation: Click \"Install\" to complete the installation process.","title":"Windows"},{"location":"Basics/git_install/#macos","text":"Install Homebrew: Open Terminal and run the following command to install Homebrew, a package manager for macOS: /bin/bash -c \" $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh ) \" 2. Install Git: Once Homebrew is installed, run the following command to install Git: brew install git","title":"macOS"},{"location":"Basics/git_install/#linux","text":"","title":"Linux"},{"location":"Basics/git_install/#ubuntudebian","text":"sudo apt update sudo apt install git-all","title":"Ubuntu/Debian"},{"location":"Basics/git_install/#fedora","text":"sudo dnf install git","title":"Fedora"},{"location":"Basics/git_install/#arch-linux","text":"sudo pacman -S git","title":"Arch Linux"},{"location":"Basics/git_install/#verify-installation","text":"Regardless of your operating system, after installation, open a terminal and run: git --version This should display the installed Git version, confirming a successful installation. Now that Git is installed, you're ready to start using version control for your projects!","title":"Verify Installation"},{"location":"Basics/git_remotes/","text":"SHARE & UPDATE Retrieving updates from another repository and updating local repos. Working with remotes in Git involves collaborating with repositories hosted on remote servers. Viewing Remote Information To see which remote servers you have configured, run the following command: git remote -v Displays the URLs of the remote repositories. It lists the shortnames of each remote handle you\u2019ve specified. If you\u2019ve cloned your repository, you should at least see origin\u2009\u2014\u2009that is the default name Git gives to the server you cloned from. The -v flag displays the full remote URLs. When you have multiple remotes then you can pull contributions from any of these remotes. Adding a Remote Here\u2019s how to add a new remote explicitly. git remote add <remote-name> <remote-url> git remote add origin https://github.com/user/repo.git Adds a remote repository with a given name and URL. Now you can use the string origin on the command line in lieu of the whole URL. For example, if you want to fetch all the information from the remote repository, you can use: git fetch origin Fetching Changes from a Remote The command goes out to that remote project and pulls down all the data from that remote project that you don\u2019t have yet. After you do this, you should have references to all the branches from that remote, which you can merge in or inspect at any time. git fetch <remote-name> git fetch origin Fetches changes from all branches in the remote repository but does not merge them into the local branch. git fetch <remote-name> <branch-name> git fetch origin main Fetches changes from the main branch in the remote repository and merges them into the local branch. Pulling Changes from a Remote git pull <remote-name> <branch-name> git pull origin main Fetches changes from the remote repository and merges them into the local branch. From Git version 2.27 onward, git pull will give a warning if the pull.rebase variable is not set. Git will keep warning you until you set the variable. If you want the default behavior of Git (fast-forward if possible, else create a merge commit): git config --global pull.rebase \"false\" If you want to rebase when pulling: git config --global pull.rebase \"true\" Pushing Changes to a Remote When you have your project at a point that you want to share, you have to push it upstream. The command for this is simple. git push <remote-name> <branch-name> git push origin main Pushes local commits to the remote repository. This command works only if you cloned from a server to which you have write access and if nobody has pushed in the meantime. If you and someone else clone at the same time and they push upstream and then you push upstream, your push will rightly be rejected. You\u2019ll have to fetch their work first and incorporate it into yours before you\u2019ll be allowed to push. Creating a Branch in a Remote Repository git push <remote-name> <local-branch-name>:<remote-branch-name> git push origin feature-branch:feature-branch Creates a new branch in the remote repository based on the local branch. Cloning a Repository git clone <remote-url> git clone https://github.com/user/repo.git Creates a local copy of a remote repository. Renaming a Remote git remote rename <old-name> <new-name> git remote rename origin upstream Renames an existing remote. Removing a Remote git remote remove <remote-name> git remote remove origin Removes a remote from the list of remotes. Inspecting Remote Branches git branch -r Lists remote branches. The git remote show command is used to display information about a specific remote repository. It provides details such as the URL of the remote repository, the branches it tracks, and additional information about the remote branches. git remote show <remote-name> git remote show origin The output of git remote show <remote-name> typically includes the following information: Remote URL: The URL of the remote repository. Fetch URL: The URL used by git fetch to fetch from the remote repository. This may differ from the remote URL if the repository supports fetching from a different location. Push URL: The URL used by git push to push to the remote repository. This may differ from the remote URL if the repository supports pushing to a different location. Remote branches: Lists the branches present in the remote repository. Local branch configured for git pull : Indicates the local branch that git pull will merge into. Local refs configured for git push : Indicates the local branch that git push will push to. Tracking information for each branch: Shows information about the local branch's relationship with the remote branches. This includes the branch name, the remote branch it tracks, whether it is up to date, and the number of commits behind or ahead. * remote origin Fetch URL: https://github.com/user/repo.git Push URL: https://github.com/user/repo.git HEAD branch: main Remote branches: main tracked feature tracked Local branch configured for 'git pull': main merges with remote main Local refs configured for 'git push': main pushes to main (up to date) feature pushes to feature (local out of date) The git remote show command is useful for inspecting the configuration and status of a remote repository. It helps in understanding how local branches are synchronized with remote branches. The output provides valuable information for managing and coordinating work with remote repositories. Using git remote show can provide insights into the state of your remote repository, aiding in decision-making when performing operations such as fetching, pulling, or pushing changes.","title":"Remotes"},{"location":"Basics/git_remotes/#viewing-remote-information","text":"To see which remote servers you have configured, run the following command: git remote -v Displays the URLs of the remote repositories. It lists the shortnames of each remote handle you\u2019ve specified. If you\u2019ve cloned your repository, you should at least see origin\u2009\u2014\u2009that is the default name Git gives to the server you cloned from. The -v flag displays the full remote URLs. When you have multiple remotes then you can pull contributions from any of these remotes.","title":"Viewing Remote Information"},{"location":"Basics/git_remotes/#adding-a-remote","text":"Here\u2019s how to add a new remote explicitly. git remote add <remote-name> <remote-url> git remote add origin https://github.com/user/repo.git Adds a remote repository with a given name and URL. Now you can use the string origin on the command line in lieu of the whole URL. For example, if you want to fetch all the information from the remote repository, you can use: git fetch origin","title":"Adding a Remote"},{"location":"Basics/git_remotes/#fetching-changes-from-a-remote","text":"The command goes out to that remote project and pulls down all the data from that remote project that you don\u2019t have yet. After you do this, you should have references to all the branches from that remote, which you can merge in or inspect at any time. git fetch <remote-name> git fetch origin Fetches changes from all branches in the remote repository but does not merge them into the local branch. git fetch <remote-name> <branch-name> git fetch origin main Fetches changes from the main branch in the remote repository and merges them into the local branch.","title":"Fetching Changes from a Remote"},{"location":"Basics/git_remotes/#pulling-changes-from-a-remote","text":"git pull <remote-name> <branch-name> git pull origin main Fetches changes from the remote repository and merges them into the local branch. From Git version 2.27 onward, git pull will give a warning if the pull.rebase variable is not set. Git will keep warning you until you set the variable. If you want the default behavior of Git (fast-forward if possible, else create a merge commit): git config --global pull.rebase \"false\" If you want to rebase when pulling: git config --global pull.rebase \"true\"","title":"Pulling Changes from a Remote"},{"location":"Basics/git_remotes/#pushing-changes-to-a-remote","text":"When you have your project at a point that you want to share, you have to push it upstream. The command for this is simple. git push <remote-name> <branch-name> git push origin main Pushes local commits to the remote repository. This command works only if you cloned from a server to which you have write access and if nobody has pushed in the meantime. If you and someone else clone at the same time and they push upstream and then you push upstream, your push will rightly be rejected. You\u2019ll have to fetch their work first and incorporate it into yours before you\u2019ll be allowed to push.","title":"Pushing Changes to a Remote"},{"location":"Basics/git_remotes/#creating-a-branch-in-a-remote-repository","text":"git push <remote-name> <local-branch-name>:<remote-branch-name> git push origin feature-branch:feature-branch Creates a new branch in the remote repository based on the local branch.","title":"Creating a Branch in a Remote Repository"},{"location":"Basics/git_remotes/#cloning-a-repository","text":"git clone <remote-url> git clone https://github.com/user/repo.git Creates a local copy of a remote repository.","title":"Cloning a Repository"},{"location":"Basics/git_remotes/#renaming-a-remote","text":"git remote rename <old-name> <new-name> git remote rename origin upstream Renames an existing remote.","title":"Renaming a Remote"},{"location":"Basics/git_remotes/#removing-a-remote","text":"git remote remove <remote-name> git remote remove origin Removes a remote from the list of remotes.","title":"Removing a Remote"},{"location":"Basics/git_remotes/#inspecting-remote-branches","text":"git branch -r Lists remote branches. The git remote show command is used to display information about a specific remote repository. It provides details such as the URL of the remote repository, the branches it tracks, and additional information about the remote branches. git remote show <remote-name> git remote show origin The output of git remote show <remote-name> typically includes the following information: Remote URL: The URL of the remote repository. Fetch URL: The URL used by git fetch to fetch from the remote repository. This may differ from the remote URL if the repository supports fetching from a different location. Push URL: The URL used by git push to push to the remote repository. This may differ from the remote URL if the repository supports pushing to a different location. Remote branches: Lists the branches present in the remote repository. Local branch configured for git pull : Indicates the local branch that git pull will merge into. Local refs configured for git push : Indicates the local branch that git push will push to. Tracking information for each branch: Shows information about the local branch's relationship with the remote branches. This includes the branch name, the remote branch it tracks, whether it is up to date, and the number of commits behind or ahead. * remote origin Fetch URL: https://github.com/user/repo.git Push URL: https://github.com/user/repo.git HEAD branch: main Remote branches: main tracked feature tracked Local branch configured for 'git pull': main merges with remote main Local refs configured for 'git push': main pushes to main (up to date) feature pushes to feature (local out of date) The git remote show command is useful for inspecting the configuration and status of a remote repository. It helps in understanding how local branches are synchronized with remote branches. The output provides valuable information for managing and coordinating work with remote repositories. Using git remote show can provide insights into the state of your remote repository, aiding in decision-making when performing operations such as fetching, pulling, or pushing changes.","title":"Inspecting Remote Branches"},{"location":"Basics/git_stage/","text":"The Lifecycle of Git files Understanding the lifecycle of the status of files in Git is crucial for effectively managing changes in your repository. The lifecycle consists of several stages that files can transition through as you work with Git. These stages are reflected in the output of git status and represent the state of files in relation to the repository. Transition between Stages: Files transition between these stages as you work with Git commands like git add , git commit , and others. Workflow: The typical workflow involves modifying files in the working directory, staging the changes with git add , and committing the changes with git commit . Visibility: Use git status to view the current status of files in your repository and identify which stage they are in. Stage Description Representation Action Untracked Files that exist in your working directory but are not yet tracked by Git. These files have not been added to the repository. Shown in red in the output of git status . Use git add <file> to stage untracked files for the next commit. Tracked (or Modified) Files that have been modified in the working directory after being staged or committed. Shown in red in the output of git status . Use git add <file> to stage the modified files, then commit the changes with git commit . Deleted Files that have been deleted from the working directory after being staged or committed. Shown in red in the output of git status . Use git add <file> to stage the deletion, then commit the changes with git commit . Renamed or Moved Files that have been renamed or moved in the working directory after being staged or committed. Shown as both deleted and untracked files in the output of git status . Use git add <file> to stage the rename or move, then commit the changes with git commit . Staged (or Indexed) Files that have been added to the staging area. These changes are ready to be included in the next commit. Shown in green in the output of git status . Use git commit to create a commit containing the staged changes. Committed (or Unmodified) Files are stored securely in the Git repository. They are unchanged and represent a specific snapshot in the project's history. Files that have not been modified since the last commit. Typically not displayed in the output of git status unless using certain flags. No action required unless you intend to stage or modify the files. The working tree is a single checkout of one version of the project. These files are pulled out of the compressed database in the Git directory and placed on disk for you to use or modify. The staging area is a file, generally contained in your Git directory, that stores information about what will go into your next commit. The Git directory is where Git stores the metadata and object database for your project. This is the most important part of Git, and it is what is copied when you clone a repository from another computer. Working with snapshots and the Git staging area For the basic workflow of staging content and committing it to your history, there are only a few basic commands. Command Example git status git status git add git add myfile.txt git diff git diff git commit git commit -m \"Add new feature\" Snapshooting The difference between Git's snapshooting and delta-based version control systems lies in how git store and track changes within a repository. Git's Snapshooting Git is a distributed version control system (DVCS) that operates based on snapshots of the entire repository at each point in time. When a commit is made in Git, the entire state of the project at that moment is captured as a snapshot, including all files and their contents. Each commit creates a new snapshot, and Git tracks the changes between snapshots rather than individual file changes. Advantages: Offers robustness and data integrity since each commit is self-contained and immutable. Allows for efficient branching and merging operations since entire snapshots are managed independently. Facilitates offline work and collaboration by enabling users to work with their local repositories and synchronize changes later. Delta-based Version Control (CVS, Subversion, Perforce) Delta-based version control systems track changes by storing the differences (or deltas) between successive versions of a file or repository. Instead of storing complete snapshots of files or repositories, delta-based systems store the changes (insertions, deletions, modifications) made to files over time. Each new version is represented as a set of changes applied to the previous version. Advantages: Can be more space-efficient for repositories with large binary files or frequent, small changes since only the differences are stored. Allows for quicker network operations when transmitting changes since only the deltas need to be transferred. May provide more granular control over individual file versions, especially for large files with small modifications. Key Differences Granularity: Git's snapshot-based approach captures the entire state of the repository at each commit, offering a holistic view of the project's history. Delta-based systems track changes at a finer granularity, focusing on individual file modifications. Efficiency: Git's approach can be less space-efficient for repositories with frequent changes or large binary files since it stores complete snapshots. Delta-based systems may offer better efficiency in such cases by only storing the differences between versions. Complexity: Managing deltas and applying them to reconstruct files can introduce complexity and potential performance overhead in delta-based systems. Git's snapshot-based approach simplifies operations like branching and merging since each commit represents a complete, self-contained snapshot. Network Operations: Git's approach may lead to larger repository sizes due to storing complete snapshots, but it offers efficient network operations since it transfers complete commits during push and pull operations. Delta-based systems may have smaller repository sizes but may require more processing to reconstruct files during network operations. Overall, Git's snapshot-based approach provides robustness, simplicity, and efficiency for version control, making it a popular choice for software development projects of all sizes. Delta-based version control systems offer advantages in specific use cases where space efficiency or granular control over individual file versions is paramount. git status Shows the status of your working directory, indicating which files are modified, untracked, and staged for the next commit. git status This command provides a detailed summary of the changes in your working directory. Files listed under \"Changes not staged for commit\" are modified but not staged, and files under \"Changes to be committed\" are staged for the next commit. git add Adds changes in the specified file to the staging area, preparing them for the next commit. # Create or modify a file echo \"Hello, Git!\" > myfile.txt # Stage the changes git add myfile.txt This sequence of commands creates or modifies myfile.txt and stages the changes for the next commit. Use git add . to stage all changes in the working directory. git diff The git diff command is used when you want to see differences between any two trees. This could be the difference between your working environment and your staging area (git diff by itself), between your staging area and your last commit (git diff --staged), or between two commits (git diff master branchB). # Make changes to myfile.txt echo \"Updated content\" >> myfile.txt # View the differences git diff This command displays the unstaged changes in myfile.txt since the last commit. git diff --staged Shows the differences between the staging area and the last commit (changes that are staged but not yet committed). # Stage the changes in myfile.txt git add myfile.txt # View the differences in the staging area git diff --staged This command displays the changes that are currently staged for the next commit. git difftool The git difftool command simply launches an external tool to show you the difference between two trees in case you want to use something other than the built in git diff command. For example, P4Merge is a visual diff and merge tool provided by Perforce. It offers a user-friendly interface for comparing and merging files and directories, making it a popular choice among developers and teams working with version control systems like Git. Here are some key features of P4Merge: Visual Diffing: P4Merge provides a graphical representation of the differences between files, allowing users to easily identify changes with color-coded highlights and line-by-line comparisons. Three-Way Merge: It supports three-way merging, which is essential for resolving conflicts that arise during collaborative development. P4Merge intelligently combines changes from two different branches or versions with a common ancestor, helping users reconcile differences efficiently. Image Comparison: In addition to text-based files, P4Merge can compare and merge images, making it suitable for projects involving graphical assets or multimedia content. Folder Diff: P4Merge can compare entire directories, displaying side-by-side comparisons of files within the folders. This feature is useful for understanding the overall differences between two directory structures and identifying missing or added files. Customizable Settings: Users can customize various aspects of P4Merge, such as colors, fonts, and keyboard shortcuts, to tailor the tool to their preferences and workflow. git commit The git commit command in Git is a powerful tool for creating and committing changes. It has several options, each affecting different parts of the Git repository. git commit When you run git commit without any arguments, it opens your editor of choice to create a commit message. You can see that the default commit message contains the latest output of the git status command commented out and one empty line on top. You can remove these comments and type your commit message, or you can leave them there to help you remember what you\u2019re committing. When you exit the editor, Git creates your commit with that commit message (with the comments and diff stripped out). Alternatively, you can type your commit message inline with the commit command by specifying it after a -m flag. This commits the changes that are staged in the snapshot, with a descriptive commit message. # Commit the changes with a message git commit -m \"Add new feature\" This command creates a new commit with the staged changes and the specified commit message. Combine git add and git commit in one step using git commit -am \"[descriptive message]\" to stage and commit changes. For an even more explicit reminder of what you\u2019ve modified, you can pass the -v option to git commit. Doing so also puts the diff of your change in the editor so you can see exactly what changes you\u2019re committing. Committing Specific Files # Stage changes in specific files git add file1.txt file2.txt # Commit the changes with a message git commit -m \"Fix issues in file1.txt and file2.txt\" Here, only specific files ( file1.txt and file2.txt ) are staged and then committed with a message describing the fix. Amending the Last Commit # Make additional changes echo \"Additional content\" >> myfile.txt # Amend the last commit with new changes git add myfile.txt git commit --amend -m \"Update myfile.txt with additional content\" This example adds new content to myfile.txt and then amends the last commit with the additional changes. Interactive Commit # Interactively stage changes git add -i # Follow the interactive prompts to stage changes and commit Running git add -i opens an interactive mode where you can choose which changes to stage, unstage, or commit. This provides a more granular control over the commit process. Committing with Multiple Messages # Stage changes in files git add file1.txt file2.txt # Commit changes with multiple messages git commit -m \"Fix issues in file1.txt\" -m \"Add new feature in file2.txt\" You can use the -m option multiple times to provide multiple commit messages. Each -m adds a new paragraph to the commit message. Committing with a Future Date # Stage changes git add . # Commit with a future date git commit --date = \"2023-01-01T12:00:00\" -m \"Commit with a future date\" This example commits changes with a specified future date using the --date option. Committing Only Tracked Changes # Stage changes in tracked files git add -u # Commit only tracked changes git commit -m \"Commit tracked changes\" The git add -u command stages only tracked files, and then a commit is made with a message indicating the commit of tracked changes.","title":"Snapshotting"},{"location":"Basics/git_stage/#the-lifecycle-of-git-files","text":"Understanding the lifecycle of the status of files in Git is crucial for effectively managing changes in your repository. The lifecycle consists of several stages that files can transition through as you work with Git. These stages are reflected in the output of git status and represent the state of files in relation to the repository. Transition between Stages: Files transition between these stages as you work with Git commands like git add , git commit , and others. Workflow: The typical workflow involves modifying files in the working directory, staging the changes with git add , and committing the changes with git commit . Visibility: Use git status to view the current status of files in your repository and identify which stage they are in. Stage Description Representation Action Untracked Files that exist in your working directory but are not yet tracked by Git. These files have not been added to the repository. Shown in red in the output of git status . Use git add <file> to stage untracked files for the next commit. Tracked (or Modified) Files that have been modified in the working directory after being staged or committed. Shown in red in the output of git status . Use git add <file> to stage the modified files, then commit the changes with git commit . Deleted Files that have been deleted from the working directory after being staged or committed. Shown in red in the output of git status . Use git add <file> to stage the deletion, then commit the changes with git commit . Renamed or Moved Files that have been renamed or moved in the working directory after being staged or committed. Shown as both deleted and untracked files in the output of git status . Use git add <file> to stage the rename or move, then commit the changes with git commit . Staged (or Indexed) Files that have been added to the staging area. These changes are ready to be included in the next commit. Shown in green in the output of git status . Use git commit to create a commit containing the staged changes. Committed (or Unmodified) Files are stored securely in the Git repository. They are unchanged and represent a specific snapshot in the project's history. Files that have not been modified since the last commit. Typically not displayed in the output of git status unless using certain flags. No action required unless you intend to stage or modify the files. The working tree is a single checkout of one version of the project. These files are pulled out of the compressed database in the Git directory and placed on disk for you to use or modify. The staging area is a file, generally contained in your Git directory, that stores information about what will go into your next commit. The Git directory is where Git stores the metadata and object database for your project. This is the most important part of Git, and it is what is copied when you clone a repository from another computer. Working with snapshots and the Git staging area For the basic workflow of staging content and committing it to your history, there are only a few basic commands. Command Example git status git status git add git add myfile.txt git diff git diff git commit git commit -m \"Add new feature\"","title":"The Lifecycle of Git files"},{"location":"Basics/git_stage/#snapshooting","text":"The difference between Git's snapshooting and delta-based version control systems lies in how git store and track changes within a repository. Git's Snapshooting Git is a distributed version control system (DVCS) that operates based on snapshots of the entire repository at each point in time. When a commit is made in Git, the entire state of the project at that moment is captured as a snapshot, including all files and their contents. Each commit creates a new snapshot, and Git tracks the changes between snapshots rather than individual file changes. Advantages: Offers robustness and data integrity since each commit is self-contained and immutable. Allows for efficient branching and merging operations since entire snapshots are managed independently. Facilitates offline work and collaboration by enabling users to work with their local repositories and synchronize changes later. Delta-based Version Control (CVS, Subversion, Perforce) Delta-based version control systems track changes by storing the differences (or deltas) between successive versions of a file or repository. Instead of storing complete snapshots of files or repositories, delta-based systems store the changes (insertions, deletions, modifications) made to files over time. Each new version is represented as a set of changes applied to the previous version. Advantages: Can be more space-efficient for repositories with large binary files or frequent, small changes since only the differences are stored. Allows for quicker network operations when transmitting changes since only the deltas need to be transferred. May provide more granular control over individual file versions, especially for large files with small modifications. Key Differences Granularity: Git's snapshot-based approach captures the entire state of the repository at each commit, offering a holistic view of the project's history. Delta-based systems track changes at a finer granularity, focusing on individual file modifications. Efficiency: Git's approach can be less space-efficient for repositories with frequent changes or large binary files since it stores complete snapshots. Delta-based systems may offer better efficiency in such cases by only storing the differences between versions. Complexity: Managing deltas and applying them to reconstruct files can introduce complexity and potential performance overhead in delta-based systems. Git's snapshot-based approach simplifies operations like branching and merging since each commit represents a complete, self-contained snapshot. Network Operations: Git's approach may lead to larger repository sizes due to storing complete snapshots, but it offers efficient network operations since it transfers complete commits during push and pull operations. Delta-based systems may have smaller repository sizes but may require more processing to reconstruct files during network operations. Overall, Git's snapshot-based approach provides robustness, simplicity, and efficiency for version control, making it a popular choice for software development projects of all sizes. Delta-based version control systems offer advantages in specific use cases where space efficiency or granular control over individual file versions is paramount.","title":"Snapshooting"},{"location":"Basics/git_stage/#git-status","text":"Shows the status of your working directory, indicating which files are modified, untracked, and staged for the next commit. git status This command provides a detailed summary of the changes in your working directory. Files listed under \"Changes not staged for commit\" are modified but not staged, and files under \"Changes to be committed\" are staged for the next commit.","title":"git status"},{"location":"Basics/git_stage/#git-add","text":"Adds changes in the specified file to the staging area, preparing them for the next commit. # Create or modify a file echo \"Hello, Git!\" > myfile.txt # Stage the changes git add myfile.txt This sequence of commands creates or modifies myfile.txt and stages the changes for the next commit. Use git add . to stage all changes in the working directory.","title":"git add"},{"location":"Basics/git_stage/#git-diff","text":"The git diff command is used when you want to see differences between any two trees. This could be the difference between your working environment and your staging area (git diff by itself), between your staging area and your last commit (git diff --staged), or between two commits (git diff master branchB). # Make changes to myfile.txt echo \"Updated content\" >> myfile.txt # View the differences git diff This command displays the unstaged changes in myfile.txt since the last commit.","title":"git diff"},{"location":"Basics/git_stage/#git-diff-staged","text":"Shows the differences between the staging area and the last commit (changes that are staged but not yet committed). # Stage the changes in myfile.txt git add myfile.txt # View the differences in the staging area git diff --staged This command displays the changes that are currently staged for the next commit.","title":"git diff --staged"},{"location":"Basics/git_stage/#git-difftool","text":"The git difftool command simply launches an external tool to show you the difference between two trees in case you want to use something other than the built in git diff command. For example, P4Merge is a visual diff and merge tool provided by Perforce. It offers a user-friendly interface for comparing and merging files and directories, making it a popular choice among developers and teams working with version control systems like Git. Here are some key features of P4Merge: Visual Diffing: P4Merge provides a graphical representation of the differences between files, allowing users to easily identify changes with color-coded highlights and line-by-line comparisons. Three-Way Merge: It supports three-way merging, which is essential for resolving conflicts that arise during collaborative development. P4Merge intelligently combines changes from two different branches or versions with a common ancestor, helping users reconcile differences efficiently. Image Comparison: In addition to text-based files, P4Merge can compare and merge images, making it suitable for projects involving graphical assets or multimedia content. Folder Diff: P4Merge can compare entire directories, displaying side-by-side comparisons of files within the folders. This feature is useful for understanding the overall differences between two directory structures and identifying missing or added files. Customizable Settings: Users can customize various aspects of P4Merge, such as colors, fonts, and keyboard shortcuts, to tailor the tool to their preferences and workflow.","title":"git difftool"},{"location":"Basics/git_stage/#git-commit","text":"The git commit command in Git is a powerful tool for creating and committing changes. It has several options, each affecting different parts of the Git repository. git commit When you run git commit without any arguments, it opens your editor of choice to create a commit message. You can see that the default commit message contains the latest output of the git status command commented out and one empty line on top. You can remove these comments and type your commit message, or you can leave them there to help you remember what you\u2019re committing. When you exit the editor, Git creates your commit with that commit message (with the comments and diff stripped out). Alternatively, you can type your commit message inline with the commit command by specifying it after a -m flag. This commits the changes that are staged in the snapshot, with a descriptive commit message. # Commit the changes with a message git commit -m \"Add new feature\" This command creates a new commit with the staged changes and the specified commit message. Combine git add and git commit in one step using git commit -am \"[descriptive message]\" to stage and commit changes. For an even more explicit reminder of what you\u2019ve modified, you can pass the -v option to git commit. Doing so also puts the diff of your change in the editor so you can see exactly what changes you\u2019re committing.","title":"git commit"},{"location":"Basics/git_stage/#committing-specific-files","text":"# Stage changes in specific files git add file1.txt file2.txt # Commit the changes with a message git commit -m \"Fix issues in file1.txt and file2.txt\" Here, only specific files ( file1.txt and file2.txt ) are staged and then committed with a message describing the fix.","title":"Committing Specific Files"},{"location":"Basics/git_stage/#amending-the-last-commit","text":"# Make additional changes echo \"Additional content\" >> myfile.txt # Amend the last commit with new changes git add myfile.txt git commit --amend -m \"Update myfile.txt with additional content\" This example adds new content to myfile.txt and then amends the last commit with the additional changes.","title":"Amending the Last Commit"},{"location":"Basics/git_stage/#interactive-commit","text":"# Interactively stage changes git add -i # Follow the interactive prompts to stage changes and commit Running git add -i opens an interactive mode where you can choose which changes to stage, unstage, or commit. This provides a more granular control over the commit process.","title":"Interactive Commit"},{"location":"Basics/git_stage/#committing-with-multiple-messages","text":"# Stage changes in files git add file1.txt file2.txt # Commit changes with multiple messages git commit -m \"Fix issues in file1.txt\" -m \"Add new feature in file2.txt\" You can use the -m option multiple times to provide multiple commit messages. Each -m adds a new paragraph to the commit message.","title":"Committing with Multiple Messages"},{"location":"Basics/git_stage/#committing-with-a-future-date","text":"# Stage changes git add . # Commit with a future date git commit --date = \"2023-01-01T12:00:00\" -m \"Commit with a future date\" This example commits changes with a specified future date using the --date option.","title":"Committing with a Future Date"},{"location":"Basics/git_stage/#committing-only-tracked-changes","text":"# Stage changes in tracked files git add -u # Commit only tracked changes git commit -m \"Commit tracked changes\" The git add -u command stages only tracked files, and then a commit is made with a message indicating the commit of tracked changes.","title":"Committing Only Tracked Changes"},{"location":"Basics/git_start/","text":"This section describes the process of initializing a Git project. You typically obtain a Git repository in one of two ways: you can take a local directory that is currently not under version control, and turn it into a Git repository, or you can clone an existing Git repository from elsewhere. In either case, you end up with a Git repository on your local machine, ready for work. Initialize the Git Repository Before initializing a Git repository, navigate to the directory of your existing project or create a new project folder. Open a terminal or command prompt and change into the project directory: cd path/to/your/project Initializing a Git repository involves setting up Git to manage your project's version control. It creates a hidden subfolder within your project that houses the internal data structure required for version control. Version control allows you to track changes, collaborate with others, and revert to previous states of your project. Initializing a Git repository is the first step to harnessing these benefits. Run the following command to initialize a Git repository in your project folder: git init After running git init , Git creates a .git directory in your project folder. This directory contains all the necessary files for version control.The .git directory is where Git stores information about your project's history, branches, configurations, and more. git init Options Initialize a New Git Repository git init Initializes a new Git repository in the current working directory. Initialize in a Specific Directory git init <directory> Initializes a new Git repository in the specified directory. Example: git init my_project git init Flags --bare The git init --bare command is used to create a new Git repository with a bare structure. A bare repository does not have a working directory like a typical Git repository. Instead, it only contains the version history, branches, tags, and configuration files. This type of repository is commonly used for remote repositories in a centralized workflow, where multiple developers collaborate on the same codebase. To create a bare repository using git init --bare , you simply run the command in the desired location where you want to create the repository: git init --bare <repository_name> <repository_name> : The name of the bare repository directory to be created. This parameter is optional, and if not provided, Git will create the repository in the current directory. Characteristics of a Bare Repository No Working Directory: Unlike a regular Git repository, a bare repository does not have a working directory where you can edit files. It only contains the version history and other metadata. Storage of Commits and Branches: The bare repository stores commits, branches, tags, and other version control information directly in its .git directory, without the need for a separate working directory. Remote Access: Bare repositories are typically used as central repositories that multiple developers can push changes to and pull changes from. They are accessed over a network, often via protocols like SSH or HTTP. Collaboration: Bare repositories facilitate collaboration by serving as a central point where developers can share their changes and synchronize their work. Use Cases Centralized Workflow: In a centralized workflow, a bare repository is set up on a server or a central location accessible to all team members. Developers push their changes to this repository, and other team members pull changes from it. Remote Hosting Services Many remote hosting services, such as GitHub, GitLab, and Bitbucket, use bare repositories to store project code. When you create a new repository on one of these platforms, it is typically initialized as a bare repository on the server. Advantages of Bare Repositories Efficient Collaboration: Bare repositories simplify collaboration by providing a central location for sharing changes and synchronizing work among team members. Reduced Disk Usage: Bare repositories consume less disk space compared to regular repositories since they do not store individual working copies of files. Security: Since a bare repository does not have a working directory, it cannot accidentally expose sensitive information or execute malicious code. It is not recommended to work directly with a bare repository on your local machine. Instead, clone the bare repository to create a working copy with a proper working directory where you can edit files and commit changes. --template=<tmplt_dir> git init --template = <template_directory> Initializes a new Git repository using the specified template directory. This can be useful for setting up a custom project structure. Example: git init --template = /path/to/custom/template The git init --template command is used to initialize a new Git repository with a custom template directory. This feature allows you to provide a set of predefined files and directories that will be automatically copied into the newly initialized repository. It can be useful for setting up a standardized project structure, including default configuration files, README templates, or other resources commonly used in your projects. Let's say you have a template directory named my_template with the following structure: my_template/ \u251c\u2500\u2500 .gitignore \u251c\u2500\u2500 README.md \u2514\u2500\u2500 scripts/ \u2514\u2500\u2500 setup.sh To initialize a new Git repository using this template, you would run the following command: git init --template = my_template After running this command, Git will create a new repository in the current directory, copying the files and directories from the my_template directory into the newly created repository. The resulting repository will have the same structure as the template directory, including the .gitignore file, README.md , and the scripts directory with its contents. Use Cases: Standardized Project Setup: You can use a template directory to define a standardized project structure, including default configuration files, license files, and directory layouts. Consistent READMEs: By including a README template in the template directory, you can ensure that all new repositories start with a consistent README file that includes essential project information. Custom Gitignore Files: Including a .gitignore file in the template directory allows you to specify default patterns for ignoring files and directories commonly found in your projects. The --template option is available in Git version 1.7.1 and later. You can customize the template directory to suit your specific needs, including any files or directories that you want to include in all new repositories. Using git init --template allows you to streamline the process of setting up new Git repositories by providing a standardized starting point for your projects. It promotes consistency and helps ensure that all new repositories adhere to your project's conventions and best practices. --separate-git-dir=<git_dir> The git init --separate-git-dir=<git_dir> command is used to initialize a new Git repository while specifying a separate directory ( <git_dir> ) to store the Git metadata ( .git directory). This allows you to decouple the location of the repository's working directory from the location of the .git directory, providing flexibility in managing your Git setup. git init --separate-git-dir = <git_dir> [ <working_dir> ] <git_dir> : The path to the directory where Git should store its metadata ( .git directory). <working_dir> : (Optional) The path to the directory where the working directory should be created. If not provided, the current directory is used. Let's say you want to create a new Git repository with the working directory located in the ~/projects/my_project directory and the Git metadata stored in the ~/git/my_project.git directory. You would use the following command: git init --separate-git-dir = ~/git/my_project.git ~/projects/my_project After running this command, Git will initialize the repository in the specified working directory ( ~/projects/my_project ) and create the .git directory with all the necessary metadata in the separate location ( ~/git/my_project.git ). Decoupling Working Directory and Git Metadata: This command allows you to separate the working directory from the Git metadata, which can be useful in various scenarios, such as managing multiple working directories that share the same Git repository. Centralized Git Metadata Storage: You can centralize the storage of Git metadata by specifying a shared location for the .git directory, which can be accessed by multiple working directories. Custom Git Metadata Location: You may have specific requirements or constraints that necessitate storing the Git metadata in a custom location, such as a network drive or a designated system directory. When using git init --separate-git-dir , the specified <git_dir> directory must not exist prior to running the command. Git will create the directory and initialize it as a new Git repository. If <working_dir> is not provided, the current directory is used as the working directory. Using git init --separate-git-dir=<git_dir> provides flexibility in managing your Git repositories by allowing you to customize the location of the Git metadata independently of the working directory. This can be beneficial in various workflows and setups, especially when dealing with multiple repositories or centralized storage of Git metadata. --quiet or -q git init --quiet Suppresses all output during the initialization process. Example: git init --quiet Clone an existing Git Repository The git clone command is used to create a copy of a remote Git repository. It copies the entire repository, including the commit history, branches, and files, to your local machine. Here's a detailed explanation of the git clone command along with some commonly used flags and options: 1. git clone <repository_url> Clones a remote Git repository to your local machine in the folder that you are in. To obtain a local copy of a project, collaborate with others, or contribute to open-source projects. git clone <repository_url> Example: git clone https://github.com/example/repo.git 2. git clone --branch <branch_name> Clones a specific branch from the remote repository. To clone a specific branch instead of the default branch (usually master or main ). git clone --branch <branch_name> <repository_url> Example: git clone --branch develop https://github.com/example/repo.git 3. git clone --branch <branch_name> <repository_url> Clones a specific branch from the remote repository to a specific folder. To clone a specific branch instead of the default branch (usually master or main ) into a specific folder. git clone --branch <branch_name> <repository_url> <path/to/folder> Example: git clone --branch master git@github.com:ArceLopera/git_refresher.git mylocalrepo 4. git clone --depth <depth> Clones a specified number of commits from the remote repository, creating a shallow clone.To reduce the size of the clone by fetching only a limited commit history. git clone --depth <depth> <repository_url> Example: git clone --depth 1 https://github.com/example/repo.git 5. git clone --recursive Clones submodules along with the main repository. To clone and initialize submodules contained within the repository. git clone --recursive <repository_url> Example: git clone --recursive https://github.com/example/repo.git","title":"Starting a Project"},{"location":"Basics/git_start/#initialize-the-git-repository","text":"Before initializing a Git repository, navigate to the directory of your existing project or create a new project folder. Open a terminal or command prompt and change into the project directory: cd path/to/your/project Initializing a Git repository involves setting up Git to manage your project's version control. It creates a hidden subfolder within your project that houses the internal data structure required for version control. Version control allows you to track changes, collaborate with others, and revert to previous states of your project. Initializing a Git repository is the first step to harnessing these benefits. Run the following command to initialize a Git repository in your project folder: git init After running git init , Git creates a .git directory in your project folder. This directory contains all the necessary files for version control.The .git directory is where Git stores information about your project's history, branches, configurations, and more.","title":"Initialize the Git Repository"},{"location":"Basics/git_start/#git-init-options","text":"","title":"git init Options"},{"location":"Basics/git_start/#git-init-flags","text":"","title":"git init Flags"},{"location":"Basics/git_start/#-bare","text":"The git init --bare command is used to create a new Git repository with a bare structure. A bare repository does not have a working directory like a typical Git repository. Instead, it only contains the version history, branches, tags, and configuration files. This type of repository is commonly used for remote repositories in a centralized workflow, where multiple developers collaborate on the same codebase. To create a bare repository using git init --bare , you simply run the command in the desired location where you want to create the repository: git init --bare <repository_name> <repository_name> : The name of the bare repository directory to be created. This parameter is optional, and if not provided, Git will create the repository in the current directory. Characteristics of a Bare Repository No Working Directory: Unlike a regular Git repository, a bare repository does not have a working directory where you can edit files. It only contains the version history and other metadata. Storage of Commits and Branches: The bare repository stores commits, branches, tags, and other version control information directly in its .git directory, without the need for a separate working directory. Remote Access: Bare repositories are typically used as central repositories that multiple developers can push changes to and pull changes from. They are accessed over a network, often via protocols like SSH or HTTP. Collaboration: Bare repositories facilitate collaboration by serving as a central point where developers can share their changes and synchronize their work. Use Cases Centralized Workflow: In a centralized workflow, a bare repository is set up on a server or a central location accessible to all team members. Developers push their changes to this repository, and other team members pull changes from it. Remote Hosting Services Many remote hosting services, such as GitHub, GitLab, and Bitbucket, use bare repositories to store project code. When you create a new repository on one of these platforms, it is typically initialized as a bare repository on the server. Advantages of Bare Repositories Efficient Collaboration: Bare repositories simplify collaboration by providing a central location for sharing changes and synchronizing work among team members. Reduced Disk Usage: Bare repositories consume less disk space compared to regular repositories since they do not store individual working copies of files. Security: Since a bare repository does not have a working directory, it cannot accidentally expose sensitive information or execute malicious code. It is not recommended to work directly with a bare repository on your local machine. Instead, clone the bare repository to create a working copy with a proper working directory where you can edit files and commit changes.","title":"--bare"},{"location":"Basics/git_start/#-templatetmplt_dir","text":"git init --template = <template_directory> Initializes a new Git repository using the specified template directory. This can be useful for setting up a custom project structure. Example: git init --template = /path/to/custom/template The git init --template command is used to initialize a new Git repository with a custom template directory. This feature allows you to provide a set of predefined files and directories that will be automatically copied into the newly initialized repository. It can be useful for setting up a standardized project structure, including default configuration files, README templates, or other resources commonly used in your projects. Let's say you have a template directory named my_template with the following structure: my_template/ \u251c\u2500\u2500 .gitignore \u251c\u2500\u2500 README.md \u2514\u2500\u2500 scripts/ \u2514\u2500\u2500 setup.sh To initialize a new Git repository using this template, you would run the following command: git init --template = my_template After running this command, Git will create a new repository in the current directory, copying the files and directories from the my_template directory into the newly created repository. The resulting repository will have the same structure as the template directory, including the .gitignore file, README.md , and the scripts directory with its contents. Use Cases: Standardized Project Setup: You can use a template directory to define a standardized project structure, including default configuration files, license files, and directory layouts. Consistent READMEs: By including a README template in the template directory, you can ensure that all new repositories start with a consistent README file that includes essential project information. Custom Gitignore Files: Including a .gitignore file in the template directory allows you to specify default patterns for ignoring files and directories commonly found in your projects. The --template option is available in Git version 1.7.1 and later. You can customize the template directory to suit your specific needs, including any files or directories that you want to include in all new repositories. Using git init --template allows you to streamline the process of setting up new Git repositories by providing a standardized starting point for your projects. It promotes consistency and helps ensure that all new repositories adhere to your project's conventions and best practices.","title":"--template=&lt;tmplt_dir&gt;"},{"location":"Basics/git_start/#-separate-git-dirgit_dir","text":"The git init --separate-git-dir=<git_dir> command is used to initialize a new Git repository while specifying a separate directory ( <git_dir> ) to store the Git metadata ( .git directory). This allows you to decouple the location of the repository's working directory from the location of the .git directory, providing flexibility in managing your Git setup. git init --separate-git-dir = <git_dir> [ <working_dir> ] <git_dir> : The path to the directory where Git should store its metadata ( .git directory). <working_dir> : (Optional) The path to the directory where the working directory should be created. If not provided, the current directory is used. Let's say you want to create a new Git repository with the working directory located in the ~/projects/my_project directory and the Git metadata stored in the ~/git/my_project.git directory. You would use the following command: git init --separate-git-dir = ~/git/my_project.git ~/projects/my_project After running this command, Git will initialize the repository in the specified working directory ( ~/projects/my_project ) and create the .git directory with all the necessary metadata in the separate location ( ~/git/my_project.git ). Decoupling Working Directory and Git Metadata: This command allows you to separate the working directory from the Git metadata, which can be useful in various scenarios, such as managing multiple working directories that share the same Git repository. Centralized Git Metadata Storage: You can centralize the storage of Git metadata by specifying a shared location for the .git directory, which can be accessed by multiple working directories. Custom Git Metadata Location: You may have specific requirements or constraints that necessitate storing the Git metadata in a custom location, such as a network drive or a designated system directory. When using git init --separate-git-dir , the specified <git_dir> directory must not exist prior to running the command. Git will create the directory and initialize it as a new Git repository. If <working_dir> is not provided, the current directory is used as the working directory. Using git init --separate-git-dir=<git_dir> provides flexibility in managing your Git repositories by allowing you to customize the location of the Git metadata independently of the working directory. This can be beneficial in various workflows and setups, especially when dealing with multiple repositories or centralized storage of Git metadata.","title":"--separate-git-dir=&lt;git_dir&gt;"},{"location":"Basics/git_start/#-quiet-or-q","text":"git init --quiet Suppresses all output during the initialization process. Example: git init --quiet","title":"--quiet or -q"},{"location":"Basics/git_start/#clone-an-existing-git-repository","text":"The git clone command is used to create a copy of a remote Git repository. It copies the entire repository, including the commit history, branches, and files, to your local machine. Here's a detailed explanation of the git clone command along with some commonly used flags and options:","title":"Clone an existing Git Repository"},{"location":"Basics/git_start/#1-git-clone-repository_url","text":"Clones a remote Git repository to your local machine in the folder that you are in. To obtain a local copy of a project, collaborate with others, or contribute to open-source projects. git clone <repository_url>","title":"1. git clone &lt;repository_url&gt;"},{"location":"Basics/git_start/#2-git-clone-branch-branch_name","text":"Clones a specific branch from the remote repository. To clone a specific branch instead of the default branch (usually master or main ). git clone --branch <branch_name> <repository_url>","title":"2. git clone --branch &lt;branch_name&gt;"},{"location":"Basics/git_start/#3-git-clone-branch-branch_name-repository_url","text":"Clones a specific branch from the remote repository to a specific folder. To clone a specific branch instead of the default branch (usually master or main ) into a specific folder. git clone --branch <branch_name> <repository_url> <path/to/folder>","title":"3. git clone --branch &lt;branch_name&gt; &lt;repository_url&gt;"},{"location":"Basics/git_start/#4-git-clone-depth-depth","text":"Clones a specified number of commits from the remote repository, creating a shallow clone.To reduce the size of the clone by fetching only a limited commit history. git clone --depth <depth> <repository_url>","title":"4. git clone --depth &lt;depth&gt;"},{"location":"Basics/git_start/#5-git-clone-recursive","text":"Clones submodules along with the main repository. To clone and initialize submodules contained within the repository. git clone --recursive <repository_url>","title":"5. git clone --recursive"},{"location":"Basics/git_undoingthings/","text":"Undoing changes in Git involves various commands and strategies, depending on the nature of the changes and the stage at which they are. Here is a comprehensive guide on common Git undo commands and strategies: Summary table of common Git undo commands and strategies: Action Command Description Undoing Commits git commit --amend Amend the last commit by adding new changes or modifying the commit message. git revert <commit-hash> Create a new commit that undoes changes introduced by a specific commit. git rebase -i <commit-hash> Open an interactive rebase session, allowing you to edit, squash, or drop commits. Undoing Uncommitted Changes git checkout -- file.txt Discard changes in a specific file, reverting it to the state in the last commit. git reset --hard Discard all uncommitted changes, reverting the working directory to the state of the last commit. Undoing Staged Changes git reset file.txt Unstage changes in a specific file, moving them back to the working directory. git reset --soft HEAD^ Undo the last commit, keeping changes staged in the working directory. git reset --mixed HEAD^ Undo the last commit, unstaging changes but keeping them in the working directory. git reset --hard HEAD^ Undo the last commit, discarding changes both in the commit and the working directory. Undoing Remote Changes git push --force origin <branch-name> Force push local changes to a remote branch (use with caution, as it rewrites remote history). Restoring Files git restore file.txt Restore the specified file to the state in the last commit (introduced in Git 2.23). Rewriting history git rebase main Apply any commits of the current branch ahead of the specified one. git filter-branch Rewrite branches to remove unwanted data Removing files git rm Remove files git mv Rename files git checkout -f [branch] Switch branches, discarding any local changes git clean -ffd Erase all untracked files and directories in the working directory Please note that some commands, like force push and hard reset, should be used with caution, especially when collaborating with others, as they can alter Git history. Always be mindful of the consequences and potential impacts on collaborators before executing these commands. 1. Undoing Commits git commit --amend , and git revert are all Git commands used to manipulate commit history, but they serve different purposes and are used in different scenarios. Amend the Last Commit git commit --amend git commit --amend is used to modify the most recent commit by adding or changing files or the commit message. It allows you to make corrections to the most recent commit before pushing it to the remote repository. Use git commit --amend when you want to make minor adjustments to the most recent commit, such as fixing typos in the commit message or adding files that were forgotten to be included. Only amend commits that are still local and have not been pushed somewhere. Amending previously pushed commits and force pushing the branch will cause problems for your collaborators. Reverting Commits git revert <commit-hash> This command creates a new commit that undoes the changes introduced by a specific commit. git revert is used to undo the changes introduced by a specific commit by creating a new commit that undoes those changes. It's a safe way to undo commits without altering the commit history. Use git revert when you want to undo the changes introduced by a particular commit while preserving the commit history. It's useful for reverting changes that have already been shared with others or pushed to a remote repository. Interactively Reverting or Editing Commits git rebase -i <commit-hash> This command opens an interactive rebase session, allowing you to edit, squash, or drop commits. The git rebase -i HEAD~6 command initiates an interactive rebase for the last six commits starting from the current HEAD . This allows you to modify, reorder, squash, or drop commits interactively before applying them onto a new base commit. Let's break down the components of this command: git rebase : The main command for reorganizing or combining commits. -i : Stands for \"interactive,\" which opens an interactive rebase session. HEAD~6 : Specifies the commit range to rebase. In this case, it's the last six commits from the current HEAD . git rebase -i HEAD~6 This command opens a text editor with a list of the last six commits in your default branch. The list might look something like this: pick abc123 Commit message 1 pick def456 Commit message 2 pick 789ghi Commit message 3 pick jkl012 Commit message 4 pick mno345 Commit message 5 pick pqr678 Commit message 6 In the interactive rebase editor, you can choose actions for each commit: pick : Keep the commit as is. reword : Change the commit message. edit : Pause for amending the commit. squash or fixup : Combine the commit with the previous one. drop : Remove the commit. For example, to squash the last three commits into a single commit, you can modify the file to look like this: pick abc123 Commit message 1 pick def456 Commit message 2 squash 789ghi Commit message 3 squash jkl012 Commit message 4 squash mno345 Commit message 5 pick pqr678 Commit message 6 After saving and closing the file, Git will prompt you to modify the commit message for the new squashed commit. Interactive rebasing allows you to create a cleaner and more organized commit history. Use edit to pause at a specific commit and make changes (e.g., amend, add files, or reword the commit message). Always make sure to review and understand the changes you're making during an interactive rebase, as it rewrites commit history. Interactive rebasing is a powerful but potentially risky operation. Be cautious and ensure you have a backup or a way to recover your changes if needed. 2. Undoing Uncommitted Changes Discard Changes in a File git checkout -- file.txt This command discards changes in the specified file, reverting it to the state in the last commit. It\u2019s important to understand that git checkout -- <file> is a dangerous command. Any local changes you made to that file are gone\u2009\u2014\u2009Git just replaced that file with the last staged or committed version. Don\u2019t ever use this command unless you absolutely know that you don\u2019t want those unsaved local changes. Discard All Changes git reset --hard This command discards all uncommitted changes in the working directory, reverting it to the state of the last commit. For more details on the difference between git reset and git checkout, see the differences . 3. Undoing Staged Changes The git reset command in Git is a powerful tool for manipulating the commit history, moving branches, and resetting the staging area. It has several options, each affecting different parts of the Git repository. git reset --soft <commit> Resets the current branch's HEAD to the specified commit, leaving the changes staged. Moves the HEAD pointer to the specified commit, keeping the changes from commits after that commit staged for a new commit. git reset --soft HEAD~3 This command resets the current branch's HEAD to three commits behind the current position, keeping the changes staged. It essentially undid the last 3 git commit commands.You could now update the index (by adding or removing files) and run git commit again to accomplish what git commit --amend would have done. git reset --mixed <commit> Resets the current branch's HEAD to the specified commit, unstaging the changes. This is also the default, so if you specify no option at all (just git reset HEAD~3 in this case). Moves the HEAD pointer to the specified commit, unstaging the changes from commits after that commit. git reset --mixed HEAD~3 This command resets the current branch's HEAD to three commits behind the current position, unstaging the changes. You rolled back to before you ran all your git add and git commit commands. git reset --hard <commit> Resets the current branch's HEAD to the specified commit, discarding all changes. Moves the HEAD pointer to the specified commit, discarding all changes made after that commit. git reset --hard HEAD~3 This command resets the current branch's HEAD to three commits behind the current position, discarding all changes. Use when you want to completely replace the current branch with the specified commit by discarding all changes made after that commit. Remember to use git reset with caution, especially the --hard option, as it can lead to irreversible data loss. Always make sure you understand the consequences of the reset operation before executing it. git reset file.txt The command git reset with a path to a file (since a commit SHA-1 or branch is not specified) is shorthand for git reset --mixed HEAD file.txt. It will: Move the branch HEAD points to (skipped). Make the index look like HEAD (stop here). So it essentially just copies file.txt from HEAD to the index. This has the practical effect of unstaging the file. If we look at the diagram for that command and think about what git add does, they are exact opposites. This is why the output of the git status command suggests that you run this to unstage a file. We could just as easily not let Git assume we meant \u201cpull the data from HEAD\u201d by specifying a specific commit to pull that file version from. We would just run something like: git reset eb43bf file.txt git reset vs git checkout Without Paths Running git checkout [branch] is pretty similar to running git reset --hard [branch] in that it updates all three trees for you to look like [branch], but there are two important differences. Unlike git reset --hard, git checkout is working-directory safe. \u2009It tries to do a trivial merge in the working directory, so all of the files you haven\u2019t changed will be updated. git reset --hard, on the other hand, will simply replace everything across the board without checking. git checkout will move HEAD itself to point to another branch or commit, while git reset will move the branch that HEAD points to. That is why when using git checkout you may end up with a detached HEAD, which is not possible with git reset. With Paths The other way to run checkout is with a file path, which, like reset, does not move HEAD. It is just like git reset [branch] file in that it updates the index with that file at that commit, but it also overwrites the file in the working directory. It would be exactly like git reset --hard [branch] file (if reset would let you run that)\u2009\u2014\u2009it\u2019s not working-directory safe, and it does not move HEAD. Cheat-sheet This table shows a cheat-sheet for which commands affect which trees. The \u201cHEAD\u201d column reads \u201cREF\u201d if that command moves the reference (branch) that HEAD points to, and \u201cHEAD\u201d if it moves HEAD itself. Pay especial attention to the 'WD Safe?' column\u2009\u2014\u2009if it says NO, take a second to think before running that command. HEAD Index Workdir WD Safe? Commit Level reset --soft [commit] REF NO NO YES reset [commit] REF YES NO YES reset --hard [commit] REF YES YES NO checkout HEAD YES YES YES File Level reset [commit] NO YES NO YES checkout [commit] NO YES YES NO 4. Undoing Remote Changes Force Push to Remote (use with caution) git push --force origin <branch-name> Use this command to force push local changes to a remote branch. Be cautious as it rewrites the remote history. 5. Restoring Files The git restore command is a versatile command introduced in Git version 2.23. It is designed to restore parts of the working directory or discard changes in a way that is more explicit and flexible than some of the previous commands. git reset VS git restore git reset and git restore are both Git commands that deal with modifying the working directory, staging area, and commit history, but they serve slightly different purposes. Feature git reset git restore Purpose Resets the state of the repository, moving the HEAD pointer to a different commit or updating the staging area and working directory. Restores files in the working directory to a specified state, either from the index or a commit. Designed for restoring files, either discarding changes or moving them between the working directory and staging area. Syntax git reset [--soft | --mixed | --hard] [<commit>] git restore [--source=<commit>] [--staged] [--worktree] <pathspec>\u2026 Unmodifying a Modified File git checkout -- <file> git restore <file> Unstaging a Staged File git reset <file> git restore --staged <file> Restore Entire Working Directory git reset --hard <commit> git restore --source=<commit> --worktree --staged --worktree . When comparing using git restore with git reset there are a few key differences to consider: Effect on Staging Area and Working Directory: git reset : When using git reset , you have the option to reset changes directly in the staging area and/or the working directory. However, resetting changes with git reset typically involves moving the HEAD pointer to a different commit, potentially altering the commit history. git restore : With git restore , you explicitly specify the source of the changes you want to restore to the staging area ( --staged ) and/or the working directory ( --worktree ). This allows for more granular control over which changes are affected, without altering the commit history. Granularity: git reset : git reset allows you to reset changes at a commit level or a file level. You can choose to reset all changes introduced by the last commit, specific files, or even specific hunks within files. git restore : git restore allows you to restore changes at a file or directory level. You can restore changes from a specific commit to the staging area and/or the working directory, but it doesn't provide the same level of granularity for selecting individual hunks within files. Ease of Use: git reset : While git reset can be powerful, it requires a bit more care and understanding, especially when choosing between --soft , --mixed , or --hard reset modes. Choosing the wrong mode can lead to unintended consequences, such as losing changes in the working directory. git restore : git restore offers a simpler and more explicit way to restore changes to the staging area and/or the working directory. By specifying the source of the changes and the target locations, you can be more confident in the outcome. In summary, both git reset and git restore offer a powerful tool for managing changes in the working directory and staging area. They differ in granularity, control, and ease of use. git reset offers more options but requires careful consideration of its modes, while git restore provides a simpler and more explicit approach for restoring changes. Discard Uncommitted Changes in a File To discard uncommitted changes in a specific file and restore it to the state in the last commit: git restore file.txt This command reverts the changes made to file.txt in the working directory, making it identical to the state of the file in the last commit. Unstaged Changes in a File To unstage changes in a file and move them back to the working directory: git restore --staged file.txt This command effectively undoes the staging of changes in file.txt and puts them back into the working directory. It is similar to git reset file.txt , but git restore is more explicit in this context. Restore Entire Working Directory To discard all uncommitted changes and restore the entire working directory to the state of the last commit: git restore --source = <commit> --worktree --staged --worktree . --source=<commit> : Specifies the commit from which to take the files states. --staged : Restores all changes to the staging area. --worktree : Restores all changes to the working directory. The git restore command provides a clearer and more explicit syntax for specific use cases, making it a powerful tool for managing changes in the working directory and staging area. Always use it with care, especially when dealing with commands that modify or discard changes. # restore working tree from HEAD content, # without touching the index/staging area git restore . # restore working tree from master content, # without touching the index/staging area git restore -s master . Both worktree and index could also be restored at the same time (from a tree) when both --staged and --worktree are specified. This overlaps with 'git checkout [tree] [paths]'. Specify the restore location. If neither option is specified, by default the working tree is restored. Specifying --staged will only restore the index. Specifying both restores both. 6. Rewriting history In Git, rewriting branches, updating commits, and clearing history are common tasks that allow you to modify the commit history of a repository. These actions can be useful for cleaning up history, organizing commits, or incorporating changes from other branches. git rebase [branch] Apply any commits of the current branch ahead of the specified one. git rebase main Incorporate changes from another branch ( main in this example) into the current branch, moving your commits to the tip of the specified branch. git filter-branch Rewrite branches to remove unwanted data, such as sensitive information or large files. git filter-branch --tree-filter 'rm -f passwords.txt' HEAD Filter branch content by applying a specified command to each commit, useful for history rewriting tasks. 7. Removing Files Versioning file removes and path changes Command Example git rm git rm file.txt git mv git mv oldfile.txt newfile.txt git checkout git checkout -f feature-branch git clean git clean -ffd git rm Removes files from both your working directory and the staging area. It stages the removal of the specified files, and you need to commit to apply the changes. # Remove a file from the staging area and stage the removal git rm -f file.txt # Commit the removal git commit -m \"Remove file.txt\" This sequence removes file.txt from both the staging area and the working directory , and the removal is committed. Another useful thing you may want to do is to keep the file in your working tree but remove it from your staging area. # Remove a file from the staging area git rm --cached file.txt You can pass files, directories, and file-glob patterns to the git rm command. That means you can do things such as: $ git rm log/ \\* .log Note the backslash () in front of the *. This is necessary because Git does its own filename expansion in addition to your shell\u2019s filename expansion. This command removes all files that have the .log extension in the log/ directory. Or, you can do something like this: $ git rm \\* ~ This command removes all files whose names end with a ~. git mv Renames or moves files in both your working directory and the Git repository. Similar to git rm , it stages the rename/move, and you need to commit to apply the changes. # Rename a file and stage the change git mv oldfile.txt newfile.txt # Commit the rename git commit -m \"Rename oldfile.txt to newfile.txt\" This example renames oldfile.txt to newfile.txt , stages the change, and commits the rename. With git mv , you can also use it to move files to a different directory, like git mv file.txt new_directory/ . Use -r with git rm and git mv to handle removals or moves recursively in directories. git checkout When switching branches, proceed even if the index or the working tree differs from HEAD, and even if there are untracked files in the way. This command is used to forcefully switch branches, discarding any local changes or untracked files that may prevent the branch switch. git checkout -f feature-branch - Note: Be cautious when using this command, as it will discard any local changes without warning. git clean Erase all untracked files and directories in the working directory. This command is used to clean up the working directory by removing any untracked files or directories that are not under version control. git clean -ffd - Note: The -f option is used to force the clean operation, and the -d option is used to include untracked directories. These commands are useful for cleaning up a Git repository before starting fresh or resolving conflicts that prevent branch switching. However, they should be used with caution, as they can permanently delete local changes and untracked files. It's essential to understand the implications of using these commands and ensure that any necessary changes or files are backed up before proceeding. # List untracked files that will be removed (dry run) git clean -n # Remove untracked files git clean -f The command ( git clean -n ) is a dry run that shows you what files would be removed. The second command ( git clean -f ) actually removes the untracked files. git clean has additional options, such as -i for an interactive mode where you can choose which files to clean.","title":"Undoing Things"},{"location":"Basics/git_undoingthings/#summary-table","text":"of common Git undo commands and strategies: Action Command Description Undoing Commits git commit --amend Amend the last commit by adding new changes or modifying the commit message. git revert <commit-hash> Create a new commit that undoes changes introduced by a specific commit. git rebase -i <commit-hash> Open an interactive rebase session, allowing you to edit, squash, or drop commits. Undoing Uncommitted Changes git checkout -- file.txt Discard changes in a specific file, reverting it to the state in the last commit. git reset --hard Discard all uncommitted changes, reverting the working directory to the state of the last commit. Undoing Staged Changes git reset file.txt Unstage changes in a specific file, moving them back to the working directory. git reset --soft HEAD^ Undo the last commit, keeping changes staged in the working directory. git reset --mixed HEAD^ Undo the last commit, unstaging changes but keeping them in the working directory. git reset --hard HEAD^ Undo the last commit, discarding changes both in the commit and the working directory. Undoing Remote Changes git push --force origin <branch-name> Force push local changes to a remote branch (use with caution, as it rewrites remote history). Restoring Files git restore file.txt Restore the specified file to the state in the last commit (introduced in Git 2.23). Rewriting history git rebase main Apply any commits of the current branch ahead of the specified one. git filter-branch Rewrite branches to remove unwanted data Removing files git rm Remove files git mv Rename files git checkout -f [branch] Switch branches, discarding any local changes git clean -ffd Erase all untracked files and directories in the working directory Please note that some commands, like force push and hard reset, should be used with caution, especially when collaborating with others, as they can alter Git history. Always be mindful of the consequences and potential impacts on collaborators before executing these commands.","title":"Summary table"},{"location":"Basics/git_undoingthings/#1-undoing-commits","text":"git commit --amend , and git revert are all Git commands used to manipulate commit history, but they serve different purposes and are used in different scenarios.","title":"1. Undoing Commits"},{"location":"Basics/git_undoingthings/#2-undoing-uncommitted-changes","text":"","title":"2. Undoing Uncommitted Changes"},{"location":"Basics/git_undoingthings/#3-undoing-staged-changes","text":"The git reset command in Git is a powerful tool for manipulating the commit history, moving branches, and resetting the staging area. It has several options, each affecting different parts of the Git repository.","title":"3. Undoing Staged Changes"},{"location":"Basics/git_undoingthings/#git-reset-soft-commit","text":"Resets the current branch's HEAD to the specified commit, leaving the changes staged. Moves the HEAD pointer to the specified commit, keeping the changes from commits after that commit staged for a new commit. git reset --soft HEAD~3 This command resets the current branch's HEAD to three commits behind the current position, keeping the changes staged. It essentially undid the last 3 git commit commands.You could now update the index (by adding or removing files) and run git commit again to accomplish what git commit --amend would have done.","title":"git reset --soft &lt;commit>"},{"location":"Basics/git_undoingthings/#git-reset-mixed-commit","text":"Resets the current branch's HEAD to the specified commit, unstaging the changes. This is also the default, so if you specify no option at all (just git reset HEAD~3 in this case). Moves the HEAD pointer to the specified commit, unstaging the changes from commits after that commit. git reset --mixed HEAD~3 This command resets the current branch's HEAD to three commits behind the current position, unstaging the changes. You rolled back to before you ran all your git add and git commit commands.","title":"git reset --mixed &lt;commit>"},{"location":"Basics/git_undoingthings/#git-reset-hard-commit","text":"Resets the current branch's HEAD to the specified commit, discarding all changes. Moves the HEAD pointer to the specified commit, discarding all changes made after that commit. git reset --hard HEAD~3 This command resets the current branch's HEAD to three commits behind the current position, discarding all changes. Use when you want to completely replace the current branch with the specified commit by discarding all changes made after that commit. Remember to use git reset with caution, especially the --hard option, as it can lead to irreversible data loss. Always make sure you understand the consequences of the reset operation before executing it.","title":"git reset --hard &lt;commit>"},{"location":"Basics/git_undoingthings/#git-reset-filetxt","text":"The command git reset with a path to a file (since a commit SHA-1 or branch is not specified) is shorthand for git reset --mixed HEAD file.txt. It will: Move the branch HEAD points to (skipped). Make the index look like HEAD (stop here). So it essentially just copies file.txt from HEAD to the index. This has the practical effect of unstaging the file. If we look at the diagram for that command and think about what git add does, they are exact opposites. This is why the output of the git status command suggests that you run this to unstage a file. We could just as easily not let Git assume we meant \u201cpull the data from HEAD\u201d by specifying a specific commit to pull that file version from. We would just run something like: git reset eb43bf file.txt","title":"git reset file.txt"},{"location":"Basics/git_undoingthings/#git-reset-vs-git-checkout","text":"","title":"git reset vs git checkout"},{"location":"Basics/git_undoingthings/#cheat-sheet","text":"This table shows a cheat-sheet for which commands affect which trees. The \u201cHEAD\u201d column reads \u201cREF\u201d if that command moves the reference (branch) that HEAD points to, and \u201cHEAD\u201d if it moves HEAD itself. Pay especial attention to the 'WD Safe?' column\u2009\u2014\u2009if it says NO, take a second to think before running that command. HEAD Index Workdir WD Safe? Commit Level reset --soft [commit] REF NO NO YES reset [commit] REF YES NO YES reset --hard [commit] REF YES YES NO checkout HEAD YES YES YES File Level reset [commit] NO YES NO YES checkout [commit] NO YES YES NO","title":"Cheat-sheet"},{"location":"Basics/git_undoingthings/#4-undoing-remote-changes","text":"Force Push to Remote (use with caution) git push --force origin <branch-name> Use this command to force push local changes to a remote branch. Be cautious as it rewrites the remote history.","title":"4. Undoing Remote Changes"},{"location":"Basics/git_undoingthings/#5-restoring-files","text":"The git restore command is a versatile command introduced in Git version 2.23. It is designed to restore parts of the working directory or discard changes in a way that is more explicit and flexible than some of the previous commands.","title":"5. Restoring Files"},{"location":"Basics/git_undoingthings/#git-reset-vs-git-restore","text":"git reset and git restore are both Git commands that deal with modifying the working directory, staging area, and commit history, but they serve slightly different purposes. Feature git reset git restore Purpose Resets the state of the repository, moving the HEAD pointer to a different commit or updating the staging area and working directory. Restores files in the working directory to a specified state, either from the index or a commit. Designed for restoring files, either discarding changes or moving them between the working directory and staging area. Syntax git reset [--soft | --mixed | --hard] [<commit>] git restore [--source=<commit>] [--staged] [--worktree] <pathspec>\u2026 Unmodifying a Modified File git checkout -- <file> git restore <file> Unstaging a Staged File git reset <file> git restore --staged <file> Restore Entire Working Directory git reset --hard <commit> git restore --source=<commit> --worktree --staged --worktree . When comparing using git restore with git reset there are a few key differences to consider: Effect on Staging Area and Working Directory: git reset : When using git reset , you have the option to reset changes directly in the staging area and/or the working directory. However, resetting changes with git reset typically involves moving the HEAD pointer to a different commit, potentially altering the commit history. git restore : With git restore , you explicitly specify the source of the changes you want to restore to the staging area ( --staged ) and/or the working directory ( --worktree ). This allows for more granular control over which changes are affected, without altering the commit history. Granularity: git reset : git reset allows you to reset changes at a commit level or a file level. You can choose to reset all changes introduced by the last commit, specific files, or even specific hunks within files. git restore : git restore allows you to restore changes at a file or directory level. You can restore changes from a specific commit to the staging area and/or the working directory, but it doesn't provide the same level of granularity for selecting individual hunks within files. Ease of Use: git reset : While git reset can be powerful, it requires a bit more care and understanding, especially when choosing between --soft , --mixed , or --hard reset modes. Choosing the wrong mode can lead to unintended consequences, such as losing changes in the working directory. git restore : git restore offers a simpler and more explicit way to restore changes to the staging area and/or the working directory. By specifying the source of the changes and the target locations, you can be more confident in the outcome. In summary, both git reset and git restore offer a powerful tool for managing changes in the working directory and staging area. They differ in granularity, control, and ease of use. git reset offers more options but requires careful consideration of its modes, while git restore provides a simpler and more explicit approach for restoring changes.","title":"git reset VS git restore"},{"location":"Basics/git_undoingthings/#6-rewriting-history","text":"In Git, rewriting branches, updating commits, and clearing history are common tasks that allow you to modify the commit history of a repository. These actions can be useful for cleaning up history, organizing commits, or incorporating changes from other branches.","title":"6. Rewriting history"},{"location":"Basics/git_undoingthings/#7-removing-files","text":"Versioning file removes and path changes Command Example git rm git rm file.txt git mv git mv oldfile.txt newfile.txt git checkout git checkout -f feature-branch git clean git clean -ffd","title":"7. Removing Files"},{"location":"Github/git_ssh/","text":"Setting up SSH keys with GitHub allows you to securely authenticate with GitHub without needing to enter your username and password every time you interact with a repository. Here's a step-by-step guide to setting up SSH keys with GitHub: Check for Existing SSH Keys Before generating new SSH keys, check if you already have SSH keys on your system. ls -al ~/.ssh Generate a New SSH Key If you don't have an SSH key pair, generate one using the ssh-keygen command. Press Enter to accept the default file location and optionally set a passphrase for added security. ssh-keygen -t ed25519 -C \"your_email@example.com\" Add SSH Key to SSH Agent Start the SSH agent and add your SSH private key to the agent. eval \" $( ssh-agent -s ) \" ssh-add ~/.ssh/id_rsa Copy SSH Public Key Copy the SSH public key to your clipboard using the pbcopy command (macOS) or display it in the terminal and manually copy it. pbcopy < ~/.ssh/id_rsa.pub # macOS cat ~/.ssh/id_rsa.pub # Linux Add SSH Key to GitHub Go to your GitHub account settings. Click on \"SSH and GPG keys\" in the left sidebar. Click on \"New SSH key\" or \"Add SSH key.\" Paste your SSH public key into the \"Key\" field. Provide a descriptive title for the SSH key. Click on \"Add SSH key\" or \"Save SSH key.\" Test SSH Connection To verify that your SSH key is correctly set up, try connecting to GitHub. ssh -T git@github.com Configure SSH for Multiple Accounts (Optional) If you have multiple GitHub accounts, you may need to configure SSH to use different keys for different accounts. This involves creating a config file in your ~/.ssh directory. touch ~/.ssh/config Edit the config file and specify which SSH key to use for each GitHub hostname: # Default GitHub Host github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa # Second GitHub account Host github-other HostName github.com User git IdentityFile ~/.ssh/other_id_rsa Setting up SSH keys with GitHub provides a secure and convenient way to authenticate with GitHub repositories. By generating SSH keys, adding them to your GitHub account, and configuring your SSH client, you can securely interact with GitHub repositories without needing to enter your username and password for each operation.","title":"Adding SSH Keys"},{"location":"Github/git_ssh/#check-for-existing-ssh-keys","text":"Before generating new SSH keys, check if you already have SSH keys on your system. ls -al ~/.ssh","title":"Check for Existing SSH Keys"},{"location":"Github/git_ssh/#generate-a-new-ssh-key","text":"If you don't have an SSH key pair, generate one using the ssh-keygen command. Press Enter to accept the default file location and optionally set a passphrase for added security. ssh-keygen -t ed25519 -C \"your_email@example.com\"","title":"Generate a New SSH Key"},{"location":"Github/git_ssh/#add-ssh-key-to-ssh-agent","text":"Start the SSH agent and add your SSH private key to the agent. eval \" $( ssh-agent -s ) \" ssh-add ~/.ssh/id_rsa","title":"Add SSH Key to SSH Agent"},{"location":"Github/git_ssh/#copy-ssh-public-key","text":"Copy the SSH public key to your clipboard using the pbcopy command (macOS) or display it in the terminal and manually copy it. pbcopy < ~/.ssh/id_rsa.pub # macOS cat ~/.ssh/id_rsa.pub # Linux","title":"Copy SSH Public Key"},{"location":"Github/git_ssh/#add-ssh-key-to-github","text":"Go to your GitHub account settings. Click on \"SSH and GPG keys\" in the left sidebar. Click on \"New SSH key\" or \"Add SSH key.\" Paste your SSH public key into the \"Key\" field. Provide a descriptive title for the SSH key. Click on \"Add SSH key\" or \"Save SSH key.\"","title":"Add SSH Key to GitHub"},{"location":"Github/git_ssh/#test-ssh-connection","text":"To verify that your SSH key is correctly set up, try connecting to GitHub. ssh -T git@github.com","title":"Test SSH Connection"},{"location":"Github/git_ssh/#configure-ssh-for-multiple-accounts-optional","text":"If you have multiple GitHub accounts, you may need to configure SSH to use different keys for different accounts. This involves creating a config file in your ~/.ssh directory. touch ~/.ssh/config Edit the config file and specify which SSH key to use for each GitHub hostname: # Default GitHub Host github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa # Second GitHub account Host github-other HostName github.com User git IdentityFile ~/.ssh/other_id_rsa Setting up SSH keys with GitHub provides a secure and convenient way to authenticate with GitHub repositories. By generating SSH keys, adding them to your GitHub account, and configuring your SSH client, you can securely interact with GitHub repositories without needing to enter your username and password for each operation.","title":"Configure SSH for Multiple Accounts (Optional)"}]}